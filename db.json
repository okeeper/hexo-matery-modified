{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/matery/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"source/images/2.png","path":"images/2.png","modified":1,"renderable":0},{"_id":"themes/matery/source/js/matery.js","path":"js/matery.js","modified":1,"renderable":1},{"_id":"themes/matery/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/matery/source/css/matery.css","path":"css/matery.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my.css","path":"css/my.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/logo.png","path":"medias/logo.png","modified":1,"renderable":1},{"_id":"themes/matery/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"source/images/rocketmq-vs-kafka/1562836232412_3.webp","path":"images/rocketmq-vs-kafka/1562836232412_3.webp","modified":1,"renderable":0},{"_id":"source/images/未命名/getImage-20220825155543961.png","path":"images/未命名/getImage-20220825155543961.png","modified":1,"renderable":0},{"_id":"source/images/未命名/getImage-20220825155544126-1414144.png","path":"images/未命名/getImage-20220825155544126-1414144.png","modified":1,"renderable":0},{"_id":"source/images/未命名/getImage-20220825155544126.png","path":"images/未命名/getImage-20220825155544126.png","modified":1,"renderable":0},{"_id":"source/images/Untitled/getImage-20220825182247230.png","path":"images/Untitled/getImage-20220825182247230.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508135.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120508135.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508078.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120508078.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508291.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120508291.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508312.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120508312.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508408.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120508408.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508512.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120508512.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508413.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120508413.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508546.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120508546.png","modified":1,"renderable":0},{"_id":"themes/matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/explosion.min.js","path":"libs/others/explosion.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/snow.js","path":"libs/others/snow.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/text.js","path":"libs/others/text.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/fireworks.js","path":"libs/others/fireworks.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/babyq.png","path":"medias/avatars/babyq.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/cww97.jpg","path":"medias/avatars/cww97.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/fun4go.png","path":"medias/avatars/fun4go.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/hael.jpg","path":"medias/avatars/hael.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/huaji.jpg","path":"medias/avatars/huaji.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/hzwer.jpg","path":"medias/avatars/hzwer.jpg","modified":1,"renderable":1},{"_id":"source/images/rocketmq-vs-kafka/1562838493614_11.jpeg","path":"images/rocketmq-vs-kafka/1562838493614_11.jpeg","modified":1,"renderable":0},{"_id":"themes/matery/source/medias/avatars/ids2.jpg","path":"medias/avatars/ids2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/ldy.jpg","path":"medias/avatars/ldy.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/kewlgrl.jpg","path":"medias/avatars/kewlgrl.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lijiaqian.png","path":"medias/avatars/lijiaqian.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/liyangzone.jpg","path":"medias/avatars/liyangzone.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/liyucheng.jpg","path":"medias/avatars/liyucheng.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/michael.jpg","path":"medias/avatars/michael.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mpy634.png","path":"medias/avatars/mpy634.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mouse.jpg","path":"medias/avatars/mouse.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qiqiang.jpg","path":"medias/avatars/qiqiang.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/sunchangzhi.jpg","path":"medias/avatars/sunchangzhi.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/taowei.jpg","path":"medias/avatars/taowei.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/spacesac.png","path":"medias/avatars/spacesac.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhaokangzhe.jpg","path":"medias/avatars/zhaokangzhe.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":1,"renderable":1},{"_id":"source/images/Untitled/getImage-20220825182247523.png","path":"images/Untitled/getImage-20220825182247523.png","modified":1,"renderable":0},{"_id":"source/images/未命名/getImage-20220825155544225.png","path":"images/未命名/getImage-20220825155544225.png","modified":1,"renderable":0},{"_id":"source/images/Untitled/getImage-20220825182246944.png","path":"images/Untitled/getImage-20220825182246944.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508157.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120508157.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508350.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120508350.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508831.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120508831.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508680.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120508680.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508784.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120508784.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508663.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120508663.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508972.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120508972.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120509028.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120509028.png","modified":1,"renderable":0},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","path":"libs/jquery/jquery-2.2.0.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/antnlp.ico","path":"medias/avatars/antnlp.ico","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/duyupei.jpg","path":"medias/avatars/duyupei.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/gsy.jpg","path":"medias/avatars/gsy.jpg","modified":1,"renderable":1},{"_id":"source/images/rocketmq-vs-kafka/1562838500422_13.jpeg","path":"images/rocketmq-vs-kafka/1562838500422_13.jpeg","modified":1,"renderable":0},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","path":"medias/avatars/myzhihu.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/milyyy.jpg","path":"medias/avatars/milyyy.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mizunashi.png","path":"medias/avatars/mizunashi.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qiandongwei.jpg","path":"medias/avatars/qiandongwei.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhangting.jpg","path":"medias/avatars/zhangting.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/xuzhongyou.jpg","path":"medias/avatars/xuzhongyou.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zzw.jpg","path":"medias/avatars/zzw.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":1,"renderable":1},{"_id":"source/images/Untitled/getImage-20220825182248034.png","path":"images/Untitled/getImage-20220825182248034.png","modified":1,"renderable":0},{"_id":"source/images/Untitled/getImage-20220825182247961.png","path":"images/Untitled/getImage-20220825182247961.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508906.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120508906.png","modified":1,"renderable":0},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":1,"renderable":1},{"_id":"source/images/rocketmq-vs-kafka/1562836313289_5.png","path":"images/rocketmq-vs-kafka/1562836313289_5.png","modified":1,"renderable":0},{"_id":"themes/matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":1,"renderable":1},{"_id":"source/images/1.jpg","path":"images/1.jpg","modified":1,"renderable":0},{"_id":"themes/matery/source/medias/avatars/0xbird.png","path":"medias/avatars/0xbird.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lyn-draw.jpg","path":"medias/avatars/lyn-draw.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lzh.png","path":"medias/avatars/lzh.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/tiantangdemogui.jpg","path":"medias/music/avatars/tiantangdemogui.jpg","modified":1,"renderable":1},{"_id":"source/images/Untitled/getImage-20220825182247269.png","path":"images/Untitled/getImage-20220825182247269.png","modified":1,"renderable":0},{"_id":"themes/matery/source/medias/music/avatars/yifuzhiming.jpg","path":"medias/music/avatars/yifuzhiming.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/yequ.jpg","path":"medias/music/avatars/yequ.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/yiluxiangbei.jpg","path":"medias/music/avatars/yiluxiangbei.jpg","modified":1,"renderable":1},{"_id":"source/images/Untitled/getImage-20220825182248165.png","path":"images/Untitled/getImage-20220825182248165.png","modified":1,"renderable":0},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","path":"libs/awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mashiro.jpg","path":"medias/avatars/mashiro.jpg","modified":1,"renderable":1},{"_id":"source/images/14.jpg","path":"images/14.jpg","modified":1,"renderable":0},{"_id":"themes/matery/source/medias/avatars/qianqian.png","path":"medias/avatars/qianqian.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/25.jpg","path":"medias/featureimages/25.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/26.jpg","path":"medias/featureimages/26.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/27.jpg","path":"medias/banner/27.jpg","modified":1,"renderable":1},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120509067.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120509067.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120509220.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120509220.png","modified":1,"renderable":0},{"_id":"source/images/区块链技术之比特币运作原理/getImage.png","path":"images/区块链技术之比特币运作原理/getImage.png","modified":1,"renderable":0},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","path":"libs/awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","path":"libs/awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","path":"libs/awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","path":"libs/awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/jitao.jpg","path":"medias/avatars/jitao.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhangyi.jpg","path":"medias/avatars/zhangyi.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/24.jpg","path":"medias/featureimages/24.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":1,"renderable":1},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508575.png","path":"images/区块链技术之比特币运作原理/getImage-20220824120508575.png","modified":1,"renderable":0},{"_id":"themes/matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/27.jpg","path":"medias/featureimages/27.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","path":"libs/awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/avatar.jpg","path":"medias/avatars/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/jingjing.jpg","path":"medias/avatars/jingjing.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":1,"renderable":1},{"_id":"source/images/Untitled/getImage-20220825182247846.png","path":"images/Untitled/getImage-20220825182247846.png","modified":1,"renderable":0},{"_id":"themes/matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":1,"renderable":1},{"_id":"source/images/Untitled/getImage-20220825182248427.png","path":"images/Untitled/getImage-20220825182248427.png","modified":1,"renderable":0},{"_id":"themes/matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/28.jpg","path":"medias/banner/28.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/daoshu.jpg","path":"medias/music/avatars/daoshu.jpg","modified":1,"renderable":1},{"_id":"source/images/Untitled/getImage-20220825182248268.png","path":"images/Untitled/getImage-20220825182248268.png","modified":1,"renderable":0},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","path":"libs/awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/myimage.jpg","path":"medias/avatars/myimage.jpg","modified":1,"renderable":1},{"_id":"source/images/rocketmq-vs-kafka/1562837115046_7.png","path":"images/rocketmq-vs-kafka/1562837115046_7.png","modified":1,"renderable":0},{"_id":"source/images/blog-introduce/image-20191128160144163.png","path":"images/blog-introduce/image-20191128160144163.png","modified":1,"renderable":0},{"_id":"source/images/rocketmq-vs-kafka/1562837115046_7-1574933554003.png","path":"images/rocketmq-vs-kafka/1562837115046_7-1574933554003.png","modified":1,"renderable":0},{"_id":"themes/matery/source/medias/banner/22.jpg","path":"medias/banner/22.jpg","modified":1,"renderable":1},{"_id":"source/images/rocketmq-vs-kafka/1562837123812_9.png","path":"images/rocketmq-vs-kafka/1562837123812_9.png","modified":1,"renderable":0},{"_id":"themes/matery/source/medias/banner/12.jpg","path":"medias/banner/12.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/13.jpg","path":"medias/banner/13.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/16.jpg","path":"medias/banner/16.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/11.jpg","path":"medias/banner/11.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/26.jpg","path":"medias/banner/26.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/17.jpg","path":"medias/banner/17.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/25.jpg","path":"medias/banner/25.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/23.jpg","path":"medias/banner/23.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/15.jpg","path":"medias/banner/15.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/9.jpg","path":"medias/banner/9.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/10.jpg","path":"medias/banner/10.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/14.jpg","path":"medias/banner/14.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/7.jpg","path":"medias/banner/7.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/8.jpg","path":"medias/banner/8.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/20.jpg","path":"medias/banner/20.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/24.jpg","path":"medias/banner/24.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/19.jpg","path":"medias/banner/19.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/周杰伦-以父之名.mp3","path":"medias/music/周杰伦-以父之名.mp3","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/18.jpg","path":"medias/banner/18.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/21.jpg","path":"medias/banner/21.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/matery/README.md","hash":"7ef16198a2c5ff580f006582286354caf160c7fe","modified":1629120458133},{"_id":"themes/matery/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1629120458132},{"_id":"themes/matery/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1629120458133},{"_id":"themes/matery/_config.yml","hash":"f3414c3de009cd1a56a7f3b4dc4f3283cad64224","modified":1661425869577},{"_id":"themes/matery/README_CN.md","hash":"a94324950e0299bcfcbc106cf2ca65c93e1fe843","modified":1629120458134},{"_id":"source/404.md","hash":"d97f69ff63501de89cfd341c68e4d6ed5c8a5b3a","modified":1629120458077},{"_id":"source/CNAME","hash":"1ff2105576e3553c6c122d30e28f9376f84f6c8f","modified":1629120458077},{"_id":"source/.DS_Store","hash":"9c430cfd8e4302846647bbb85db79d6f947bba37","modified":1661414268603},{"_id":"themes/matery/languages/default.yml","hash":"527c795b8c41fe62bf35603ffebfa6d4a7929a2c","modified":1629120458135},{"_id":"themes/matery/languages/zh-CN.yml","hash":"d92db4b986bb6f0d228e9a8249383103bf56342d","modified":1629120458135},{"_id":"themes/matery/layout/404.ejs","hash":"f08a0f507b36f3652520a41381f71167488405c7","modified":1629120458135},{"_id":"themes/matery/layout/about.ejs","hash":"e87752e59f021b5139b1155a264da11ab469a9aa","modified":1629120458146},{"_id":"themes/matery/layout/archive.ejs","hash":"1b5023571894404d75caffa28128fc9c49f9095d","modified":1629120458147},{"_id":"themes/matery/layout/categories.ejs","hash":"c431e772d0f7700592228bbd9502793bdc28a893","modified":1629120458147},{"_id":"themes/matery/layout/category.ejs","hash":"2d421e10c3b8fd2c4f725e5eaa967c4a1429c707","modified":1629120458147},{"_id":"themes/matery/layout/index.ejs","hash":"eb1c25cff220968f4ea089c919273286aa4d99e1","modified":1661426354793},{"_id":"themes/matery/layout/friends.ejs","hash":"b9b75ff45324da5b4ddbb6e16ea1ecd239dbc310","modified":1629120458148},{"_id":"themes/matery/layout/contact.ejs","hash":"1513c5a40b7cc0b6e5854cf8c3253958bcb486cb","modified":1629120458148},{"_id":"themes/matery/layout/layout.ejs","hash":"8a25ca5ee2415afca8d744cbe931c12adc3266f7","modified":1629120458149},{"_id":"themes/matery/layout/post.ejs","hash":"9ecae79690293cacdccc172118f1fe481705b1f2","modified":1629120458149},{"_id":"themes/matery/layout/tag.ejs","hash":"5cdf3a1d72f54285ee9cb826fd0e4a0449093215","modified":1629120458149},{"_id":"themes/matery/layout/tags.ejs","hash":"851c0ee599e91e7b1d657673859e8b6ff79cf50b","modified":1629120458150},{"_id":"themes/matery/source/favicon.png","hash":"4f514cb1bc8d0a6676420e0930d34b6b25c07db2","modified":1629120458152},{"_id":"source/_data/musics.json","hash":"a2def511b26f6405cf858ce22d4861b3de352a0f","modified":1629120458078},{"_id":"source/_posts/2019-11-28-动态壁纸接口.md","hash":"7d499af5b338b5d3f129d9ec92fe63ffdb771816","modified":1629120458078},{"_id":"source/_posts/blog-introduce.md","hash":"3ed3d26ae823fe95ffeb065eb36dd05a11350b50","modified":1629120458079},{"_id":"source/_posts/rocketmq-vs-kafka.md","hash":"50d440296e1bc8c9c4e650e20d1e7fcc8d13030b","modified":1629120458079},{"_id":"source/_data/friends.json","hash":"1a114872e94c467389c9b2669b9aa0638aefd8e8","modified":1661314270495},{"_id":"source/_posts/.DS_Store","hash":"00ce9f570967c358c24e275649c6da1c93b92f86","modified":1661313026261},{"_id":"source/categories/index.md","hash":"76889deb16e0d61d5c585f26a0e69f01de6cab74","modified":1629120458082},{"_id":"source/archives/index.md","hash":"a62b7d9b8a8bdf966ec5c823e71581d2b185156e","modified":1629120458081},{"_id":"source/_posts/软件开发方法.md","hash":"2c77ab6a834a89e04b750d17663c3c9af79964a7","modified":1661313065113},{"_id":"source/contact/index.md","hash":"6d84ed05540943c54480521c6801efda2a231ba4","modified":1629120458083},{"_id":"source/friends/index.md","hash":"745927e907295a2e77a8489662a4899dde109529","modified":1629120458083},{"_id":"source/tags/index.md","hash":"98697833897097a5c65521ea02baa1c6f85948d8","modified":1629120458132},{"_id":"source/about/index.md","hash":"ec411ef12d36a6831968261b6f2ad9c68dd5ea4b","modified":1629120458080},{"_id":"source/images/2.png","hash":"4f514cb1bc8d0a6676420e0930d34b6b25c07db2","modified":1629120458092},{"_id":"themes/matery/layout/_partial/back-top.ejs","hash":"cb99dc352397ec5d0765794d7b8884972e61973b","modified":1629120458136},{"_id":"themes/matery/layout/_partial/bg-cover-content.ejs","hash":"71bf954fcf7a1b619b0cafc1e7c7f33fa0ad1bcc","modified":1629120458136},{"_id":"themes/matery/layout/_partial/bg-cover.ejs","hash":"d5a7b9bb96e04c0a3485dd873748f19c50a6a04f","modified":1629120458136},{"_id":"themes/matery/layout/_partial/disqus.ejs","hash":"42dda8e67f7f09d148347887e52f18aea546df26","modified":1629120458137},{"_id":"themes/matery/layout/_partial/footer.ejs","hash":"2da7eb87874c2e63d834a66d4637b2f7cdd75d5b","modified":1629120458137},{"_id":"themes/matery/layout/_partial/gitalk.ejs","hash":"a3a140e6aeeb6f289e4b821a577ef548267f3de1","modified":1629120458137},{"_id":"themes/matery/layout/_partial/github-link.ejs","hash":"fd4034bca2eb3987dcf113e6477260bee97eb1e7","modified":1629120458138},{"_id":"themes/matery/layout/_partial/gitment.ejs","hash":"d8c40dbc8106b5bc53ceb727ad968c1d8f234261","modified":1629120458138},{"_id":"themes/matery/layout/_partial/google-analytics.ejs","hash":"890c8f04c1f4905dfceb3ea9fd6efdd040d79c01","modified":1629120458138},{"_id":"themes/matery/layout/_partial/head.ejs","hash":"46bf12d01ece774a722d6aa80f2658bb64719519","modified":1629120458138},{"_id":"themes/matery/layout/_partial/header.ejs","hash":"821e1af65990521c9e0288178d8e5b18c73a9cab","modified":1629120458138},{"_id":"themes/matery/layout/_partial/index-cover.ejs","hash":"d4042e5521ceb5f3255cd4455ac7ccd227fee6df","modified":1629120458139},{"_id":"themes/matery/layout/_partial/livere.ejs","hash":"42728561c09589f79b698eb059ab4def53ed3642","modified":1629120458139},{"_id":"themes/matery/layout/_partial/mobile-nav.ejs","hash":"e761f0104fbf431671bbe6bebc91ca82f737f4d2","modified":1629120458139},{"_id":"themes/matery/layout/_partial/navigation.ejs","hash":"3a82fcb6f31d69971cb564985842c14ac02cdca0","modified":1629120458139},{"_id":"themes/matery/layout/_partial/post-cover.ejs","hash":"166c0b9753f3f913bd801e82ad5b268004be198d","modified":1629120458140},{"_id":"themes/matery/layout/_partial/paging.ejs","hash":"dfdeea9c59d157acb851d4bf44bf95f81787523c","modified":1629120458140},{"_id":"themes/matery/layout/_partial/post-detail-toc.ejs","hash":"82cb8090cde663fa7ad67418a802997b3057e957","modified":1629120458140},{"_id":"themes/matery/layout/_partial/post-detail.ejs","hash":"3f208f33e4e12becdb8323e6e64e20ad60c3fb2a","modified":1629120458140},{"_id":"themes/matery/layout/_partial/post-statis.ejs","hash":"3b42900247d5ea4ea5b68e2be44420a0d54785ad","modified":1629120458141},{"_id":"themes/matery/layout/_partial/prev-next.ejs","hash":"4e73f10eacb5d00a0681cb44fe5c039cd8ab03cd","modified":1629120458141},{"_id":"themes/matery/layout/_partial/reprint-statement.ejs","hash":"f85a222ec3f9bc27eb7978015e63a16514b38791","modified":1629120458141},{"_id":"themes/matery/layout/_partial/reward.ejs","hash":"73624d9db81e87ff0c12310bb873fbd0b5221021","modified":1629120458141},{"_id":"themes/matery/layout/_partial/search.ejs","hash":"e859fe6e0259e0c123cb7ceda6e4cac836318ffc","modified":1629120458142},{"_id":"themes/matery/layout/_partial/share.ejs","hash":"0f2e1e27d21492cf228e786daead985b1e1dcea4","modified":1629120458142},{"_id":"themes/matery/layout/_partial/social-link.ejs","hash":"55272fab7a3303e94f1839ebd7ca6cf9965fb328","modified":1629120458142},{"_id":"themes/matery/layout/_partial/valine.ejs","hash":"c3039180ddb2eb17e724b8441e5f93e79859aef7","modified":1629120458142},{"_id":"themes/matery/layout/_widget/category-cloud.ejs","hash":"b2b22d4fc4e46b051f67216c391f629f4ff552b5","modified":1629120458143},{"_id":"themes/matery/layout/_widget/category-radar.ejs","hash":"5284712d84bbaa4f0d88026ac3ec5a8c13e00056","modified":1629120458143},{"_id":"themes/matery/layout/_widget/dream.ejs","hash":"2af85ddef6e61a44cbe10e8f6272a8324681ee3f","modified":1629120458143},{"_id":"themes/matery/layout/_widget/music.ejs","hash":"fc50cb4bbc1f4d0e4c9f5941f1c3c74bea742db7","modified":1629120458143},{"_id":"themes/matery/layout/_widget/my-gallery.ejs","hash":"9ea672db65f1e5b8fad1ffafb1614f25adc97e63","modified":1629120458144},{"_id":"themes/matery/layout/_widget/my-projects.ejs","hash":"785cb588a31215876f6737213054ba0e8552fff0","modified":1629120458144},{"_id":"themes/matery/layout/_widget/my-skills.ejs","hash":"c6f713316ce75ad08ac5d1587bd8ce42e894e9ae","modified":1629120458144},{"_id":"themes/matery/layout/_widget/post-calendar.ejs","hash":"4608af6151f0e32f668c89f09343748340021478","modified":1629120458145},{"_id":"themes/matery/layout/_widget/post-charts.ejs","hash":"0aaf0a111b9aa07ff37f6286eeac5506283f47f8","modified":1629120458145},{"_id":"themes/matery/layout/_widget/recommend.ejs","hash":"d439d86818de179d64965d4f7f5fa56147fd9221","modified":1629120458145},{"_id":"themes/matery/layout/_widget/tag-cloud.ejs","hash":"6310903eb0e434d6f9a59ca669aab7fae38d4797","modified":1629120458146},{"_id":"themes/matery/layout/_widget/tag-wordcloud.ejs","hash":"bf604fe9c435f0fb9a559cac9c35772579b590e8","modified":1629120458146},{"_id":"themes/matery/layout/_widget/video.ejs","hash":"05f5e2acace5730cdf7bed650375ad88f6b5d1b7","modified":1629120458146},{"_id":"themes/matery/source/js/matery.js","hash":"208b7806caa943c115aa0825c9c72a0781404775","modified":1629120458153},{"_id":"themes/matery/source/js/search.js","hash":"77ecae23dd3edd8ad962c5b12954652bb2f7a1b6","modified":1629120458153},{"_id":"themes/matery/source/css/matery.css","hash":"b815241f5002884abae640b8ce67db8c92a99810","modified":1629120458151},{"_id":"themes/matery/source/css/my.css","hash":"37683a9f11c68903a53e2b8593ca8c095a721896","modified":1629120458151},{"_id":"themes/matery/source/css/my-gitalk.css","hash":"4e3e855767ac5a48b13af1d6a42df13d8975e03f","modified":1629120458151},{"_id":"themes/matery/source/medias/logo.png","hash":"245bf683033c88588e6b0e74bde5398866731652","modified":1629120458862},{"_id":"source/_posts/区块链/从零开始使用Solidity编写以太坊智能合约并使用Nodejs SDK访问以太坊网络.md","hash":"b782f00266bb3dea184ec009dacd461ef4467438","modified":1661425539784},{"_id":"source/_posts/区块链/区块链技术之比特币运作原理.md","hash":"0ed6ccd358ff519f5cbe89e79fbe2b57ff342f6b","modified":1661425539780},{"_id":"source/_posts/后端&架构/Java学习大纲.md","hash":"dc08af345d32e6597ec740d75095b65dfab991dd","modified":1661424128427},{"_id":"source/_posts/后端&架构/分库分表的分页查询.md","hash":"96c093baa5a1d7480e802b4f077592292a67e6ca","modified":1661424042344},{"_id":"source/_posts/操作系统原理/操作系统原理——进程管理.md","hash":"066099c18debb2a6e0ff17516fbfa7729d8e6f42","modified":1661418732942},{"_id":"source/_posts/操作系统原理/操作系统原理——进程调度与死锁.md","hash":"d1405cddc8ce01ad5fc1b16c0004defcea2da1ae","modified":1661418738836},{"_id":"source/_posts/操作系统原理/操作系统原理——内存管理.md","hash":"d33c51bb57e2658e0dfe840389c1fcfed8dca748","modified":1661418781886},{"_id":"source/_posts/学习/Dubbo源码学习.md","hash":"65af63cbd47cfd6b867f1d227da838d9d89ae796","modified":1661424745569},{"_id":"source/_posts/后端&架构/限流相关.md","hash":"00af535d004a6a702d1e7cacb0f0cfbe890776ef","modified":1661424178726},{"_id":"source/_posts/操作系统原理/操作系统原理——初识操作系统.md","hash":"9439cc6136fdae421e485b1aa6cf634ea719254b","modified":1661418781883},{"_id":"source/_posts/学习/高性能无锁阻塞队列——Disruptor.md","hash":"324d14b36099c633a1159fd5ecc8b1e22e4d7357","modified":1661425548895},{"_id":"source/_posts/学习/HTTP及HTTPS的理解.md","hash":"bd92d95b5fa6b1539f6d67fa9aa941304368ac40","modified":1661425503812},{"_id":"source/_posts/学习/关于Unicode  UTF-8 、UTF-16字符集编码的理解.md","hash":"20704c7484af1c5ff1531a8c28f52c7f3d18fcfa","modified":1661425503809},{"_id":"source/_posts/软件笔记/Idea maven 插件安装.md","hash":"1412940cce242fe6a43c3612247f1217bc293531","modified":1661423484183},{"_id":"source/_posts/软件笔记/Centos 下Redis 安装以及集群搭建.md","hash":"1aa1197173bf8448f75f79289914e2477541cdeb","modified":1661424414806},{"_id":"source/_posts/软件笔记/Java 8常用转换.md","hash":"8c5eb69618012a150ec447648dff17ba8e3a7a21","modified":1661423981333},{"_id":"source/_posts/软件笔记/Java开发环境准备.md","hash":"5edb1893d5f5854cf92d831d8cf2c96eff331209","modified":1661424457517},{"_id":"source/_posts/软件笔记/Java bean的Getter Setter 自动编译生成工具Lombok.md","hash":"0a412c93de73f1078c60dc6196d379972ec1179a","modified":1661423524988},{"_id":"source/_posts/软件笔记/Selenium.md","hash":"ca42a216edee8cb52ea904f1e2a9fbae8a49f745","modified":1661423841749},{"_id":"source/_posts/软件笔记/Redis批量删除命令.md","hash":"11c70ec9036e7aaad37b2d764044a5870fc77918","modified":1661424358981},{"_id":"source/_posts/软件笔记/docker ES安装.md","hash":"3f35a71608ab5617340605e20f548eea213d5886","modified":1661424388805},{"_id":"source/_posts/软件笔记/iterm2 rz sz 安装.md","hash":"80b7709d0e3dd5d9614b7bfe6688aa0ba4f1fbda","modified":1661423175212},{"_id":"source/_posts/软件笔记/使用Jmeter进行Dubbo接口压测.md","hash":"e2d6490d04f843db139efb1660a04e635c377c80","modified":1661423087584},{"_id":"source/_posts/软件笔记/git重命名的坑.md","hash":"a8e84eb57ca24984fcc6850eef0becdf03bf721c","modified":1661423568412},{"_id":"source/_posts/软件笔记/maven 包冲突 解决.md","hash":"99055868b57cee5d88a9aa74ca3b26365a681fda","modified":1661424121719},{"_id":"source/_posts/软件笔记/idea 突然闪退，内存溢出.md","hash":"946fb75bba2400cfcfd11bdc5ebb9dbe85f5c9f7","modified":1661423721798},{"_id":"source/_posts/软件笔记/使用Maven命令指定上传打包到私库.md","hash":"4f194c2884294f569e0155835ffb1df67a25a211","modified":1661423550816},{"_id":"source/_posts/软件笔记/护眼神器Dark Reader.md","hash":"2883e7d04f846b5cf711cf80ec4acc6727f3f363","modified":1661423397713},{"_id":"source/_posts/软件笔记/抓包工具Charles安装、破解及使用.md","hash":"8509beddf74b699c6a48491f77acfa3b9d10471a","modified":1661423442335},{"_id":"source/_posts/软件笔记/靠谱的maven仓库地址.md","hash":"e8c811695895fbaaba5a0b6805f89a6b635b71c9","modified":1661423587540},{"_id":"source/_posts/软件笔记/磁盘空间满处理.md","hash":"7549d7c202412d846089c36d05e895ac6d9eeea7","modified":1661424603790},{"_id":"source/_posts/软件笔记/科学上网神器,熊猫VPN, 亲测很舒服.md","hash":"e8bb86f33c7e2480d076d63914bb368fd924dcb5","modified":1661423343123},{"_id":"source/_posts/软考/企业信息化和政务信息化.md","hash":"03329d0fb3b8c61492f5d19385eaca4d2157d57d","modified":1661423949076},{"_id":"source/_posts/软考/软件开发方法.md","hash":"1a84f58ac19df61dd34f697c05cd5823d6fff924","modified":1661423946825},{"_id":"themes/matery/source/css/gitment.css","hash":"d5ef623065d1fbc897119f7b70ccf7563e329917","modified":1629120458150},{"_id":"source/images/rocketmq-vs-kafka/1562836232412_3.webp","hash":"232decd2fa4d540585f188fa2a6355de4073e5f8","modified":1629120458102},{"_id":"source/images/未命名/getImage-20220825155543961.png","hash":"7e19a53cbcac977eb3caaa3f23b6e68ff545eee7","modified":1661414143962},{"_id":"source/images/未命名/getImage-20220825155544126-1414144.png","hash":"c0b788977276c48d87765d7d7324ce9a17dcf87b","modified":1661414144128},{"_id":"source/images/未命名/getImage-20220825155544126.png","hash":"c0b788977276c48d87765d7d7324ce9a17dcf87b","modified":1661414144128},{"_id":"source/images/Untitled/getImage-20220825182247230.png","hash":"a8afc9eebe44c67a4322c1d8e66fc4975d4e9c9f","modified":1661422967231},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508135.png","hash":"bba8c948db365c80cdbd79823a2d0fb07372b959","modified":1661313908136},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508078.png","hash":"a07329292aeb8c52eee73c5efa071f58e4157bbe","modified":1661313908079},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508291.png","hash":"6d5fab2f920b8765e6fc4d0813392f083b0fe7a1","modified":1661313908291},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508312.png","hash":"5c6a57b517ff9bf746285b52b3a0ca95bc1f1154","modified":1661313908313},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508408.png","hash":"d15e739f3713e76db02aac4d35b41166c52db4f1","modified":1661313908408},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508512.png","hash":"88f600995d0850ff99548ee23904790bc32a3fb5","modified":1661313908512},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508413.png","hash":"73ececbab9b487db4fd8f69605843b007c5ab66b","modified":1661313908414},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508546.png","hash":"724362c894c7045bcd9b015e5c36f68643f61c0d","modified":1661313908546},{"_id":"themes/matery/source/libs/aos/aos.css","hash":"ded9739f803d114c9168d3351fded72b3b478b4c","modified":1629120458154},{"_id":"themes/matery/source/libs/animate/animate.min.css","hash":"5dfcbcee866e9dc564916416281885f3e320871e","modified":1629120458154},{"_id":"themes/matery/source/libs/aos/aos.js","hash":"5a8e6d07ffa55642418ab3fd4b263aa08284b77a","modified":1629120458155},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","hash":"7f4f8913f2d46ade2def5134e2cc8684a4b87939","modified":1629120458155},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","hash":"021898a16279ac2ffe75af4f902fab2a0a39f11a","modified":1629120458177},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","hash":"33810b2b757fc4327bc1d3b83bb5e0d3dc1fec5b","modified":1629120458170},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","hash":"a0625d8b432af8bdc820f8768d36cde439e7257c","modified":1629120458181},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","hash":"4e6538c8312aeeab845d361c37a8c1a0931241f0","modified":1629120458183},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","hash":"5d52d3b34fceb9d7e11f1beaf7ed380b4249dec4","modified":1629120458171},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"26849509f196a2d21bbfd15696e5d5153163b8f1","modified":1629120458183},{"_id":"themes/matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1629120458192},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1629120458192},{"_id":"themes/matery/source/libs/others/explosion.min.js","hash":"5b76fa72a85cfb27d54b00128393ece773d65386","modified":1629120458192},{"_id":"themes/matery/source/libs/others/snow.js","hash":"b393f069781eef788a0ae66b2681cece8fea2851","modified":1629120458193},{"_id":"themes/matery/source/libs/others/text.js","hash":"fdf18f65977e4bc358dfb5fb0b7c98492ae72efd","modified":1629120458193},{"_id":"themes/matery/source/libs/others/fireworks.js","hash":"e9c74f2dd3953d4d8dec44e9977574d00702e84d","modified":1629120458193},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1629120458194},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","hash":"f646f2bb75bcd1eb65b2788ac7bf15d4fd243ce9","modified":1629120458198},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","hash":"f81cd7bfcf7aa2d043bd3e6077df42656fc44b82","modified":1629120458189},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1629120458198},{"_id":"themes/matery/source/medias/avatars/babyq.png","hash":"be5432588003e5a52c02e690622eec72b5f7346c","modified":1629120458206},{"_id":"themes/matery/source/medias/avatars/cww97.jpg","hash":"6af987cafc55d8d031534dd5e0f722fff19f70ec","modified":1629120458207},{"_id":"themes/matery/source/medias/avatars/fun4go.png","hash":"0f4333973a972a629cfbabf601bc7c192b65376c","modified":1629120458210},{"_id":"themes/matery/source/medias/avatars/hael.jpg","hash":"e66ccedab38bb2e8fc45fac024e234ab8e7b9d54","modified":1629120458212},{"_id":"themes/matery/source/medias/avatars/huaji.jpg","hash":"86be7eed2a491455ccfe3e7da46366ff477765ca","modified":1629120458212},{"_id":"themes/matery/source/medias/avatars/hzwer.jpg","hash":"53a66bb5e65d2abd5b7412edf094c1e0b1094492","modified":1629120458212},{"_id":"source/images/rocketmq-vs-kafka/1562838493614_11.jpeg","hash":"8904d12401293fa92294ad46fb9bec8f5b069eb6","modified":1629120458130},{"_id":"themes/matery/source/medias/avatars/ids2.jpg","hash":"2c8d3ac6ab5ac6196bac83766fde975daca91c32","modified":1629120458213},{"_id":"themes/matery/source/medias/avatars/ldy.jpg","hash":"906ef214d1f2fe52a663738340ad5623f826bd82","modified":1629120458218},{"_id":"themes/matery/source/medias/avatars/kewlgrl.jpg","hash":"3af0fd1029a1511bb3c0e90871e41b35e714b01f","modified":1629120458218},{"_id":"themes/matery/source/medias/avatars/lijiaqian.png","hash":"9d96b3838acfae9a23b6e290fcfafceff0419c63","modified":1629120458219},{"_id":"themes/matery/source/medias/avatars/liyangzone.jpg","hash":"febab557e4c0d859ab4cc14b57d8106f5e3fccfb","modified":1629120458219},{"_id":"themes/matery/source/medias/avatars/liyucheng.jpg","hash":"12055a27fa667c87d2319475968056e1a8ad0f08","modified":1629120458219},{"_id":"themes/matery/source/medias/avatars/michael.jpg","hash":"331a2ab20c299196f5a3089b8445fc8f55346cb6","modified":1629120458232},{"_id":"themes/matery/source/medias/avatars/mpy634.png","hash":"30f88e09c02b37c2dc684d4ee3237e327bb23f8b","modified":1629120458236},{"_id":"themes/matery/source/medias/avatars/mouse.jpg","hash":"2eae273885b9859150a1f98f74b3df12ca9a207c","modified":1629120458236},{"_id":"themes/matery/source/medias/avatars/qiqiang.jpg","hash":"081459866f922d9558a88cd4d7155d91fa730322","modified":1629120458242},{"_id":"themes/matery/source/medias/avatars/sunchangzhi.jpg","hash":"bbe2a15fd474ab62dbd14fea72deb1113a4fb005","modified":1629120458244},{"_id":"themes/matery/source/medias/avatars/taowei.jpg","hash":"e58b03b70656aa7a27238be38dac3896d9d16f10","modified":1629120458245},{"_id":"themes/matery/source/medias/avatars/spacesac.png","hash":"ff1bdb058f1f0499312da1a082ba97d78590db1a","modified":1629120458243},{"_id":"themes/matery/source/medias/avatars/zhaokangzhe.jpg","hash":"c8242bd13f08a9ddb97e26f216bc729b12ed9058","modified":1629120458251},{"_id":"themes/matery/source/medias/reward/alipay.jpg","hash":"7d7834a52e131a3922af7ebcebbd4cda771d001a","modified":1629120458909},{"_id":"source/images/Untitled/getImage-20220825182247523.png","hash":"624123f234c705f26af83978b27d2ce94cfacc0c","modified":1661422967523},{"_id":"source/images/未命名/getImage-20220825155544225.png","hash":"707b2dbb0dd192c4a7f2edfc113817daed75a30c","modified":1661414144226},{"_id":"source/images/Untitled/getImage-20220825182246944.png","hash":"9bba1973aada36af77c4ebb04578ef300d1e9a1f","modified":1661422966946},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508157.png","hash":"ae87613c51eb080bb08c9dc95b5e4134e060a6aa","modified":1661313908158},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508350.png","hash":"2109948d3ebf330659c6cd2998ebab596f4c5910","modified":1661313908351},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508831.png","hash":"89404f06cbd793f5ca0df1a4a7e2a73823eb5193","modified":1661313908831},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508680.png","hash":"13c9a97a8e629a3d4155c925a5922fda244f5a78","modified":1661313908680},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508784.png","hash":"90cde3ff21a737a119f80d800a10f585736a1b8f","modified":1661313908785},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508663.png","hash":"2f67ade6890439288449d8537751d5061cdea092","modified":1661313908664},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508972.png","hash":"44ee840c07acc3b3a80d3588393879f3e8051e8b","modified":1661313908973},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120509028.png","hash":"3f8834e643f5275df86e3d6746c37e2aec2093fe","modified":1661313909029},{"_id":"source/_posts/images/HTTP及HTTPS的理解/getImage-20220825184528912.png","hash":"ac4cec099cfb80bddaadb7d265a244aab05ca0b6","modified":1661424328912},{"_id":"source/_posts/images/docker ES安装/getImage-20220825184627503.png","hash":"2edbe79875dd8daaa246842398e074d640d0d28d","modified":1661424387505},{"_id":"source/_posts/images/docker ES安装/getImage-20220825184627531.png","hash":"b85ee81fc71c316a0fdce6a20518c75fc4b05a44","modified":1661424387531},{"_id":"source/_posts/images/护眼神器Dark Reader/getImage-20220825182956835.png","hash":"044d9e300d7cf6156c6aab7dd2eb3d526ba2cd27","modified":1661423396836},{"_id":"source/_posts/images/抓包工具Charles安装、破解及使用/getImage-20220825183038169.png","hash":"24aa663f868775ac105b8a8495bade70d2e8c5cc","modified":1661423438169},{"_id":"source/_posts/images/分库分表的分页查询/getImage-20220825184040363.png","hash":"f904ac0c768f5338186a0fe296f36f407a00ad40","modified":1661424040364},{"_id":"source/_posts/images/分库分表的分页查询/getImage-20220825184040369.png","hash":"d1f808058d833b4d766ae716d0fe51225e8d25f1","modified":1661424040369},{"_id":"source/_posts/images/分库分表的分页查询/getImage-20220825184040384.png","hash":"9bd2eede2071c3b0a7105cf1031eb41c06e48360","modified":1661424040385},{"_id":"source/_posts/images/分库分表的分页查询/getImage-20220825184040381.png","hash":"b06752d5744530426427282324b1cad220939633","modified":1661424040381},{"_id":"source/_posts/images/分库分表的分页查询/getImage-20220825184040393.png","hash":"d9ef1ec09b45eec8561f1bd0518d93aafa7bd730","modified":1661424040394},{"_id":"source/_posts/images/分库分表的分页查询/getImage-20220825184040402.png","hash":"436d73a4b217c9ab977c508d35775af9ed6e5da2","modified":1661424040403},{"_id":"source/_posts/images/分库分表的分页查询/getImage-20220825184040515.png","hash":"9f9b8c330f4d3bdf0d1e84b3c75158aa439d09a7","modified":1661424040515},{"_id":"source/_posts/images/分库分表的分页查询/getImage-20220825184040525.png","hash":"ee4f3536b670c016479a2b68e94aff37357da3d7","modified":1661424040526},{"_id":"source/_posts/images/限流相关/getImage-20220825184239739-1424159.png","hash":"7259644377729d67ea8d0f907c14959f053d24af","modified":1661424159740},{"_id":"source/_posts/images/限流相关/getImage-20220825184239638.png","hash":"35a79662b285fcb10b70f2e38962bbe0ef354241","modified":1661424159639},{"_id":"source/_posts/images/限流相关/getImage-20220825184239708.png","hash":"4acfb25b9e2b3032aca8a9f289b68056c19ffd4d","modified":1661424159709},{"_id":"source/_posts/images/限流相关/getImage-20220825184239739.png","hash":"74f911b1312d06348472561de5f7a618b2f2c8a1","modified":1661424159739},{"_id":"source/_posts/images/高性能无锁阻塞队列——Disruptor/getImage-20220825184418757.png","hash":"a3080db280d346f454120dac42c7388d307b44d3","modified":1661424258758},{"_id":"source/_posts/images/限流相关/getImage-20220825184239907.png","hash":"60493079672b2d999cd72040b9f20e027d5e1d58","modified":1661424159908},{"_id":"source/_posts/images/高性能无锁阻塞队列——Disruptor/getImage-20220825184418735.png","hash":"9edd3480f8b5519433b02beea609cc474e35ed50","modified":1661424258736},{"_id":"source/_posts/images/限流相关/getImage-20220825184239758.png","hash":"5660ef96bda24cec8527c33701c9d6850d88d315","modified":1661424159758},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","hash":"70c0c4a9bf698747b7c058c21287ad617355e5dd","modified":1629120458156},{"_id":"themes/matery/source/libs/gitment/gitment.js","hash":"5a13983930b019450e4fe01a407c64b3dd316be4","modified":1629120458182},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","hash":"7a551393b8360731104fdef1af36a6f3638f5855","modified":1629120458184},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","hash":"82276be41d2001e820020a219b90ad5b026302d1","modified":1629120458171},{"_id":"themes/matery/source/libs/valine/Valine.min.js","hash":"828da5443b6ccd96f16a3791efd21f54717ed730","modified":1629120458199},{"_id":"themes/matery/source/medias/avatars/antnlp.ico","hash":"29475f350b989331cebd702a315f020917d06ed8","modified":1629120458204},{"_id":"themes/matery/source/medias/avatars/duyupei.jpg","hash":"3c02ed4cf57dc37e4f4b8314bf5094833a854cb0","modified":1629120458209},{"_id":"themes/matery/source/medias/avatars/gsy.jpg","hash":"6a175e2ba56a2280d40a2e654b559be41c3a0a48","modified":1629120458211},{"_id":"source/images/rocketmq-vs-kafka/1562838500422_13.jpeg","hash":"68f27b6ca4950fc5f294c51455557ddeccbb093f","modified":1629120458131},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","hash":"245bf683033c88588e6b0e74bde5398866731652","modified":1629120458240},{"_id":"themes/matery/source/medias/avatars/milyyy.jpg","hash":"ac2826d9c28346efeb967df01465a2c74d9041fe","modified":1629120458234},{"_id":"themes/matery/source/medias/avatars/mizunashi.png","hash":"5fc300701d3b4250a307ed70e3a3aa0d5395c808","modified":1629120458235},{"_id":"themes/matery/source/medias/avatars/qiandongwei.jpg","hash":"6873551596a4513d01898ad866c4073c68270c57","modified":1629120458241},{"_id":"themes/matery/source/medias/avatars/zhangting.jpg","hash":"10ee25ae3531f046a8bd3696c1cc8a16f0f25e1b","modified":1629120458248},{"_id":"themes/matery/source/medias/avatars/xuzhongyou.jpg","hash":"1db4dfaf23cf250f222a398326562d4170d3aaa1","modified":1629120458246},{"_id":"themes/matery/source/medias/avatars/zzw.jpg","hash":"5d385b5732644b07b937a4919abc83cb95e14513","modified":1629120458252},{"_id":"themes/matery/source/medias/reward/wechat.png","hash":"fc11af60c3f79581fe15bc4f3dde43e65649eff1","modified":1629120458914},{"_id":"source/images/Untitled/getImage-20220825182248034.png","hash":"f8c4f35119ae26b118fde346d6796fb956836a0d","modified":1661422968034},{"_id":"source/images/Untitled/getImage-20220825182247961.png","hash":"ae71d3e4fbf811c5cfe0200b69ad59541b520974","modified":1661422967962},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508906.png","hash":"46594da743e4583f2a2dca3259c38a1ab0b050d3","modified":1661313908907},{"_id":"source/_posts/images/Idea maven 插件安装/getImage-20220825183122891.png","hash":"1ec28e1c1529cbcdb1a92b8b04129f4d4bbeef65","modified":1661423482892},{"_id":"source/_posts/images/抓包工具Charles安装、破解及使用/getImage-20220825183037648.png","hash":"6ec8c9be38e0396ab72fe32bbd7562cf1099287a","modified":1661423437649},{"_id":"source/_posts/images/抓包工具Charles安装、破解及使用/getImage-20220825183038566.png","hash":"65c04249dc2376efb9c89412a46f1fa0970111d1","modified":1661423438567},{"_id":"source/_posts/images/软件开发方法/getImage-20220825183846024.png","hash":"6f82fff53bdc06fb57db7fc4d9ab16d1679d764a","modified":1661423926024},{"_id":"source/_posts/images/高性能无锁阻塞队列——Disruptor/getImage-20220825184418828.png","hash":"67f98eeb5cbc5e323536afd7bdfb9b560aafe6ef","modified":1661424258828},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1629120458186},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1629120458186},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1629120458186},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1629120458187},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1629120458187},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1629120458186},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1629120458188},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1629120458188},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"f8cd48e1fff82ecd54a7ce3e69de8dba7c92d113","modified":1629120458189},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1629120458195},{"_id":"themes/matery/source/libs/share/css/share.min.css","hash":"7126de5cec8371e580b7b1f22512da0985cc39e5","modified":1629120458194},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1629120458195},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1629120458196},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1629120458196},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1629120458197},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1629120458197},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","hash":"2c27939768606603bee3b5e6c8a722596a667e60","modified":1629120458190},{"_id":"source/images/rocketmq-vs-kafka/1562836313289_5.png","hash":"0675238ec65e341c0730a48bba3c4fdc8b915855","modified":1629120458104},{"_id":"themes/matery/source/libs/valine/av-min.js","hash":"04c6b2782ce4610c429563110f6a20a47432fc4c","modified":1629120458200},{"_id":"source/images/1.jpg","hash":"cd3fc47d2042a3277e4b375ad084365abdc28f5d","modified":1629120458087},{"_id":"themes/matery/source/medias/avatars/0xbird.png","hash":"f9d597dfcb49e1e2be06138b24028291f5638610","modified":1629120458203},{"_id":"themes/matery/source/medias/avatars/lyn-draw.jpg","hash":"837d5d5df4dcb086d2da114d0d85084b4ec18768","modified":1629120458222},{"_id":"themes/matery/source/medias/avatars/lzh.png","hash":"8ffcbf19d6b38b891dbe408d9a4e9513b56f247e","modified":1629120458224},{"_id":"themes/matery/source/medias/featureimages/16.jpg","hash":"0d8315876e8285abec48ce71797a14734fdc980c","modified":1629120458795},{"_id":"themes/matery/source/medias/featureimages/17.jpg","hash":"5f27406bd8661bef44291601edc2784b5af63c23","modified":1629120458797},{"_id":"themes/matery/source/medias/featureimages/2.jpg","hash":"c86ede693175156922041c5cdb31b9f1432a0e8a","modified":1629120458806},{"_id":"themes/matery/source/medias/featureimages/6.jpg","hash":"7bdf83e0822794a7294fe554c5d21edda1e0c28f","modified":1629120458850},{"_id":"themes/matery/source/medias/music/avatars/tiantangdemogui.jpg","hash":"f005578ddb4d3d731838db89a708f39f18d50e60","modified":1629120458864},{"_id":"source/images/Untitled/getImage-20220825182247269.png","hash":"2cc5a16133382112dd99d565c72a48934034ea1f","modified":1661422967270},{"_id":"themes/matery/source/medias/music/avatars/yifuzhiming.jpg","hash":"fc118fa166566355bc814fc32d67bdf0fab814b3","modified":1629120458866},{"_id":"themes/matery/source/medias/music/avatars/yequ.jpg","hash":"103beb9ab33434b434fa37a30aecdb29db633024","modified":1629120458866},{"_id":"themes/matery/source/medias/music/avatars/yiluxiangbei.jpg","hash":"01b12e3aca7385a88412c12539e1a608a78896fa","modified":1629120458867},{"_id":"source/images/Untitled/getImage-20220825182248165.png","hash":"868c7a42a09d3a21d232049c41caaa7e911e21d8","modified":1661422968165},{"_id":"source/_posts/images/抓包工具Charles安装、破解及使用/getImage-20220825183037940.png","hash":"263535cca45ba0b1d0327ebc12374dff2bc5c868","modified":1661423437940},{"_id":"source/_posts/images/抓包工具Charles安装、破解及使用/getImage-20220825183038687.png","hash":"b831b0e35765149d437bc6ad75abbc1dba6f364a","modified":1661423438688},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1629120458185},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1629120458169},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","hash":"f63c7c489524ccb5d95e74fcd6618116c58fb305","modified":1629120458180},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","hash":"c843f0dc497314574c608ca28cc742bb041786d5","modified":1629120458191},{"_id":"themes/matery/source/medias/avatars/mashiro.jpg","hash":"250e911c16eeb6acb1e6214ad3e6a3d762850a8e","modified":1629120458231},{"_id":"source/images/14.jpg","hash":"f515cb01de6d2b1981f50f0487e9b5beb99baf43","modified":1629120458091},{"_id":"themes/matery/source/medias/avatars/qianqian.png","hash":"fed254c4e7eb58ee22d647acb83f1d08f4508f8f","modified":1629120458242},{"_id":"themes/matery/source/medias/featureimages/20.jpg","hash":"6dcacca5f1d93dec5c12cab74516e415243c0a64","modified":1629120458808},{"_id":"themes/matery/source/medias/featureimages/25.jpg","hash":"35a945ed6f2f8a0d055f9da6e90b974b7f30c5b0","modified":1629120458826},{"_id":"themes/matery/source/medias/featureimages/26.jpg","hash":"7e6241a0793404fb3668b1030795e5031e0f1ba7","modified":1629120458831},{"_id":"themes/matery/source/medias/banner/27.jpg","hash":"db3ed6e4cf779824a73255b6173d1aef102c98f8","modified":1629120458662},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120509067.png","hash":"134b7a7d712b2617e769b58457534eaca81a6565","modified":1661313909068},{"_id":"source/_posts/images/HTTP及HTTPS的理解/getImage-20220825184529343.png","hash":"49cb8ad4e67ca741a26279adb5004ce373d91ba2","modified":1661424329344},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120509220.png","hash":"8f4616a3b4438b1eb59144115f2629729e2b0032","modified":1661313909220},{"_id":"source/images/区块链技术之比特币运作原理/getImage.png","hash":"2300ca643e6c7747505898e47246be111e404b2a","modified":1661313908062},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1629120458157},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1629120458161},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1629120458169},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1629120458166},{"_id":"themes/matery/source/medias/avatars/jitao.jpg","hash":"5934b9baccebccbc2be2ead5d84ad32dd41f9559","modified":1629120458217},{"_id":"themes/matery/source/medias/avatars/zhangyi.jpg","hash":"c9130036aac9a7ac8d62e33550a9d64896cdc364","modified":1629120458250},{"_id":"themes/matery/source/medias/featureimages/15.jpg","hash":"18cc714b6693d0336c1bbaef47ed79cc8a1d95e7","modified":1629120458793},{"_id":"themes/matery/source/medias/featureimages/18.jpg","hash":"5efc3856cd2da8863e9c808005c3724c09843c3c","modified":1629120458801},{"_id":"themes/matery/source/medias/featureimages/24.jpg","hash":"44d047bc0d29d6ae3e1d65b6cb95143d0d1b6ec2","modified":1629120458823},{"_id":"themes/matery/source/medias/featureimages/21.jpg","hash":"c04a6292dc85cc47a9ec370e1bee81e0e7e65652","modified":1629120458811},{"_id":"themes/matery/source/medias/featureimages/3.jpg","hash":"447bf84c1d9bd71491545922c8735b5b41e2121f","modified":1629120458839},{"_id":"themes/matery/source/medias/featureimages/7.jpg","hash":"d41c54ff1c41f5bfd4ccf5af303229059577c351","modified":1629120458853},{"_id":"source/images/区块链技术之比特币运作原理/getImage-20220824120508575.png","hash":"dd3883572dc7e2bd1b2a07f75a49f37319c40d92","modified":1661313908575},{"_id":"source/_posts/images/HTTP及HTTPS的理解/getImage-20220825184529221.png","hash":"6e9b6efb52a135a367f883ed1f5dfbfd63be4865","modified":1661424329222},{"_id":"source/_posts/images/抓包工具Charles安装、破解及使用/getImage-20220825183038204.png","hash":"1b06911a1c5decbdbf624032c064a7b24449364e","modified":1661423438205},{"_id":"source/_posts/images/抓包工具Charles安装、破解及使用/getImage-20220825183038586.png","hash":"a172f5e946523aeb1c0b9ca3a858b70ad83d0c83","modified":1661423438586},{"_id":"themes/matery/source/medias/featureimages/12.jpg","hash":"c72b487cf410eb99697ac6e416b1db9c10fa92ce","modified":1629120458786},{"_id":"themes/matery/source/medias/featureimages/1.jpg","hash":"e177d97cfbb0071d2ac15e99d15666cf09d5eacb","modified":1629120458777},{"_id":"themes/matery/source/medias/featureimages/19.jpg","hash":"7a07b854a602cb9c8fa0db80ebd2c9b989f3de22","modified":1629120458804},{"_id":"themes/matery/source/medias/featureimages/14.jpg","hash":"f515cb01de6d2b1981f50f0487e9b5beb99baf43","modified":1629120458791},{"_id":"themes/matery/source/medias/featureimages/27.jpg","hash":"f4d026ea224b9d216357d4b42fbe9f002bcaa2b0","modified":1629120458835},{"_id":"themes/matery/source/medias/featureimages/4.jpg","hash":"f46e3860fbcbb63cd76023d91b7a4715e27fb231","modified":1629120458843},{"_id":"themes/matery/source/medias/featureimages/8.jpg","hash":"4cedcb5a87fa5fbc1f343c9180d4e52bb4331220","modified":1629120458857},{"_id":"themes/matery/source/medias/banner/0.jpg","hash":"4d6f31f86966584360bcdbfecb6f6a2ec94f944d","modified":1629120458255},{"_id":"themes/matery/source/medias/banner/1.jpg","hash":"cd3fc47d2042a3277e4b375ad084365abdc28f5d","modified":1629120458256},{"_id":"themes/matery/source/medias/banner/2.jpg","hash":"c2980f75f2c047d0957e3c8227b3f8d84e67f752","modified":1629120458476},{"_id":"themes/matery/source/medias/banner/4.jpg","hash":"73bae0e6812c46509b91e3155bd12ce8640b245a","modified":1629120458674},{"_id":"themes/matery/source/medias/banner/6.jpg","hash":"5be9274e63d6ac02607e3d659fd32532291385fa","modified":1629120458684},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1629120458159},{"_id":"themes/matery/source/medias/avatars/avatar.jpg","hash":"cf7bb618431be2744931e8791d3a509c7d2cb1e3","modified":1629120458206},{"_id":"themes/matery/source/medias/avatars/jingjing.jpg","hash":"bfcab0139edb2509de984cb0a9b156879c355158","modified":1629120458215},{"_id":"themes/matery/source/medias/featureimages/11.jpg","hash":"3fa19adaa3c19d58e34be573f1c3233c9b57b242","modified":1629120458782},{"_id":"themes/matery/source/medias/featureimages/10.jpg","hash":"6339e06736ff6618d97cca389d7887439c87415a","modified":1629120458779},{"_id":"themes/matery/source/medias/featureimages/5.jpg","hash":"4c001e19790f5ac73259138ad1713338ea34c664","modified":1629120458846},{"_id":"themes/matery/source/medias/banner/3.jpg","hash":"5c494c93ad30b8f71c7865b42b3cf613279a914e","modified":1629120458670},{"_id":"themes/matery/source/medias/banner/5.jpg","hash":"6f5795e2fa01a6a7f09e3419941a0fc147ea83c5","modified":1629120458680},{"_id":"source/images/Untitled/getImage-20220825182247846.png","hash":"d040b477e6efbd23ca49a5886560521f308c1a5d","modified":1661422967847},{"_id":"source/_posts/images/抓包工具Charles安装、破解及使用/getImage-20220825183037795.png","hash":"13bd96af326830581710e365ba7c44e9985faca3","modified":1661423437798},{"_id":"source/_posts/images/抓包工具Charles安装、破解及使用/getImage-20220825183038117.png","hash":"d49918bad9abae9a47625b0c19db07f7d97672c3","modified":1661423438118},{"_id":"source/_posts/images/软件开发方法/getImage-20220825183846654.png","hash":"6f8589ab61ae340ee348a10684751fa5f9b677df","modified":1661423926655},{"_id":"source/_posts/images/抓包工具Charles安装、破解及使用/getImage-20220825183038795.png","hash":"6b4d280cd2ccc50c7e3362df235cf6bf46773b27","modified":1661423438795},{"_id":"themes/matery/source/medias/featureimages/13.jpg","hash":"575cb26b73b220a3fea685108812466fb8b68e62","modified":1629120458789},{"_id":"themes/matery/source/medias/featureimages/0.jpg","hash":"39a1cb44e4ab3006577fefcbeecaddd1a2f62cfa","modified":1629120458774},{"_id":"themes/matery/source/medias/featureimages/23.jpg","hash":"8cc1c127ca8ff09d4a07f5c3b845ef2340a1106f","modified":1629120458821},{"_id":"themes/matery/source/medias/featureimages/9.jpg","hash":"1829b3464d5715136d3feec2849c7716541e83ed","modified":1629120458861},{"_id":"source/images/Untitled/getImage-20220825182248427.png","hash":"1c0f316954c5dd9faaaa67dc0cf7e652d1d50ea3","modified":1661422968427},{"_id":"source/_posts/images/抓包工具Charles安装、破解及使用/getImage-20220825183038645.png","hash":"a061d313b32fe66aa88559a3be3dfb793cdba457","modified":1661423438646},{"_id":"themes/matery/source/medias/featureimages/22.jpg","hash":"43d1db28c3f3f953c5fd399fd959f6e92ee88fe7","modified":1629120458816},{"_id":"themes/matery/source/medias/banner/28.jpg","hash":"ab68a275b8b1fd3a2dc1ba6cf5f6aadc6df275d8","modified":1629120458666},{"_id":"themes/matery/source/medias/music/avatars/daoshu.jpg","hash":"eee120fdf5ccbe86aa7d51826c4c773e76e6357f","modified":1629120458864},{"_id":"source/_posts/images/软件开发方法/getImage-20220825183846811.png","hash":"69564fd2b38b04d44c255af162bf3771d8e7ae98","modified":1661423926811},{"_id":"source/images/Untitled/getImage-20220825182248268.png","hash":"5e480bad6bcff2bb003de792eaf39cae3538b84b","modified":1661422968269},{"_id":"source/_posts/images/HTTP及HTTPS的理解/getImage-20220825184529465.png","hash":"43beae033b6be8536ba2af7aab98a5ab6a657694","modified":1661424329468},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1629120458164},{"_id":"source/_posts/images/软件开发方法/getImage-20220825183846916.png","hash":"dfe3096630fe756d466515191e48b99958a4b9e7","modified":1661423926916},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","hash":"8789b5e4daf0029a6c88f238f10e54d01c4fce82","modified":1629120458176},{"_id":"themes/matery/source/medias/avatars/myimage.jpg","hash":"beadc8fcc4dd5a6d374b8ab7f58e01533701e763","modified":1629120458239},{"_id":"source/images/rocketmq-vs-kafka/1562837115046_7.png","hash":"daf4e5e92d1a59c78edc6c20bf027f6501d86771","modified":1629120458116},{"_id":"source/_posts/images/Java学习大纲/getImage-20220825184207294.png","hash":"00726c15fafbf49655479fad1ecc960fc6a402a2","modified":1661424127294},{"_id":"source/images/blog-introduce/image-20191128160144163.png","hash":"b5f3abcbece210c239e97cd9842eac0a7edff7dd","modified":1629120458099},{"_id":"source/images/rocketmq-vs-kafka/1562837115046_7-1574933554003.png","hash":"daf4e5e92d1a59c78edc6c20bf027f6501d86771","modified":1629120458112},{"_id":"themes/matery/source/medias/banner/22.jpg","hash":"84546466c749cddf5500df74bab39d4636537f66","modified":1629120458571},{"_id":"source/images/rocketmq-vs-kafka/1562837123812_9.png","hash":"36365f05b517bc27a2da876b6510ef4ba3b1ffcf","modified":1629120458126},{"_id":"themes/matery/source/medias/banner/12.jpg","hash":"c8ad1207361352c25fab66a98568da99bb2aea4e","modified":1629120458298},{"_id":"themes/matery/source/medias/banner/13.jpg","hash":"fe209e35fe71c08a1902ea4157574a2721b56438","modified":1629120458306},{"_id":"themes/matery/source/medias/banner/16.jpg","hash":"eced09df7191b951e3b4b35ab1a545d5134f73be","modified":1629120458367},{"_id":"themes/matery/source/medias/banner/11.jpg","hash":"421e8428d2433b4eaeca56c4475f43ef8f7e0304","modified":1629120458292},{"_id":"themes/matery/source/medias/banner/26.jpg","hash":"252a47fd5d8eb33fc0948ddb60d55b9b1179757d","modified":1629120458656},{"_id":"themes/matery/source/medias/banner/17.jpg","hash":"04daf3307bc0c6e3022dd105276906a05e570f88","modified":1629120458382},{"_id":"themes/matery/source/medias/banner/25.jpg","hash":"252a47fd5d8eb33fc0948ddb60d55b9b1179757d","modified":1629120458649},{"_id":"themes/matery/source/medias/banner/23.jpg","hash":"b90fd79257f707515e441f5a0805ec0fdd8abf08","modified":1629120458590},{"_id":"themes/matery/source/medias/banner/15.jpg","hash":"aad54148afd507bee2feba71712d8bbdf107ea2a","modified":1629120458355},{"_id":"themes/matery/source/medias/banner/9.jpg","hash":"96a188f02569c1c8464250449d144f484a28df04","modified":1629120458767},{"_id":"themes/matery/source/medias/banner/10.jpg","hash":"11b86fc02b76b00ec99664be7f592d8b036321e1","modified":1629120458279},{"_id":"themes/matery/source/medias/banner/14.jpg","hash":"d0d7a5d6b9c1dbae66d7c77f878db98799e682b1","modified":1629120458332},{"_id":"themes/matery/source/medias/banner/7.jpg","hash":"86552c3444a88c7f21f9794d895cd5faf2720901","modified":1629120458719},{"_id":"themes/matery/source/medias/banner/8.jpg","hash":"6c761c95740b9865b855d0d869032a21539ff040","modified":1629120458744},{"_id":"themes/matery/source/medias/banner/20.jpg","hash":"a48752d1e497cafd3fda5d055525665a278a63be","modified":1629120458504},{"_id":"themes/matery/source/medias/banner/24.jpg","hash":"9b7c0e373b9e2d9241b05b4fd9c971d1765784a4","modified":1629120458626},{"_id":"themes/matery/source/medias/banner/19.jpg","hash":"f92f585f7dee0d9bb0b138eac362a9b17fb95646","modified":1629120458469},{"_id":"themes/matery/source/medias/music/周杰伦-以父之名.mp3","hash":"7583d47168d3e46a3780df8541ce1c8f41914a6a","modified":1629120458906},{"_id":"themes/matery/source/medias/banner/18.jpg","hash":"f7cdf1a259242b5ef314cc972fddd796622a82da","modified":1629120458428},{"_id":"themes/matery/source/medias/banner/21.jpg","hash":"d0c8163884f9b2fa9c81c3547c2dcb7c84aeee0c","modified":1629120458557}],"Category":[{"name":"分享","_id":"cl78yczg00005vwm1cwyncgxg"},{"name":"RocketMQ","_id":"cl78yczg7000bvwm1u05r6p3a"},{"name":"架构","_id":"cl78yczg8000fvwm1dig0go7m"},{"name":"区块链","_id":"cl78ycziq0011vwm1ruugkk8k"},{"name":"学习","_id":"cl78yczix001bvwm1q5v78wce"},{"name":"操作系统原理","_id":"cl78ycziz001ivwm1hbgoqa4g"}],"Data":[{"_id":"musics","data":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}]},{"_id":"friends","data":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}],"Page":[{"title":"404","date":"2019-07-19T08:41:10.000Z","type":"404","layout":"404","description":"你来到了没有知识的荒原 :(","_content":"","source":"404.md","raw":"---\ntitle: 404\ndate: 2019-07-19 16:41:10\ntype: \"404\"\nlayout: \"404\"\ndescription: \"你来到了没有知识的荒原 :(\"\n---\n","updated":"2021-08-16T13:27:38.077Z","path":"404.html","comments":1,"_id":"cl78yczdx0000vwm1n3jjcghv","content":"","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":""},{"title":"categories","date":"2019-07-19T08:39:20.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-07-19 16:39:20\ntype: \"categories\"\nlayout: \"categories\"\n---","updated":"2021-08-16T13:27:38.082Z","path":"categories/index.html","comments":1,"_id":"cl78yczfx0002vwm16349ohbt","content":"","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":""},{"title":"archives","date":"2019-07-19T08:39:20.000Z","type":"archives","layout":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2019-07-19 16:39:20\ntype: \"archives\"\nlayout: \"archives\"\n---","updated":"2021-08-16T13:27:38.081Z","path":"archives/index.html","comments":1,"_id":"cl78yczfz0004vwm1kb5xgvmm","content":"","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":""},{"title":"contact","date":"2019-07-26T09:17:02.000Z","type":"contact","layout":"contact","_content":"\n# 欢迎留言\n大家有任何问题，都可以在评论区给我留言，或者加我联系方式：\n* QQ：**610998697**\n* 微信：**zhangyue0808**\n\n我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。\n**当然不介意小改改加我哦~~**\n\n# 友链交换\n想要交换友链的小伙伴，欢迎在评论区留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n\n例如我的博客友链，大家可以加到自己博客里哦：\n* **名称：**Okeeper\n* **地址：**https://okeeper.com\n* **简介：**一个喜欢周杰伦，既不文艺也没有才艺，平淡无奇的程序员而已\n* **头像：**https://okeeper.com/medias/avatars/avatar.jpg","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2019-07-26 17:17:02\ntype: \"contact\"\nlayout: \"contact\"\n---\n\n# 欢迎留言\n大家有任何问题，都可以在评论区给我留言，或者加我联系方式：\n* QQ：**610998697**\n* 微信：**zhangyue0808**\n\n我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。\n**当然不介意小改改加我哦~~**\n\n# 友链交换\n想要交换友链的小伙伴，欢迎在评论区留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n\n例如我的博客友链，大家可以加到自己博客里哦：\n* **名称：**Okeeper\n* **地址：**https://okeeper.com\n* **简介：**一个喜欢周杰伦，既不文艺也没有才艺，平淡无奇的程序员而已\n* **头像：**https://okeeper.com/medias/avatars/avatar.jpg","updated":"2021-08-16T13:27:38.083Z","path":"contact/index.html","comments":1,"_id":"cl78yczi0000vvwm1b0w0jaa1","content":"<h1 id=\"欢迎留言\"><a href=\"#欢迎留言\" class=\"headerlink\" title=\"欢迎留言\"></a>欢迎留言</h1><p>大家有任何问题，都可以在评论区给我留言，或者加我联系方式：</p>\n<ul>\n<li>QQ：<strong>610998697</strong></li>\n<li>微信：<strong>zhangyue0808</strong></li>\n</ul>\n<p>我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。<br><strong>当然不介意小改改加我哦~~</strong></p>\n<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在评论区留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n<p>例如我的博客友链，大家可以加到自己博客里哦：</p>\n<ul>\n<li><strong>名称：</strong>Okeeper</li>\n<li><strong>地址：</strong><a href=\"https://okeeper.com\">https://okeeper.com</a></li>\n<li><strong>简介：</strong>一个喜欢周杰伦，既不文艺也没有才艺，平淡无奇的程序员而已</li>\n<li><strong>头像：</strong><a href=\"https://okeeper.com/medias/avatars/avatar.jpg\">https://okeeper.com/medias/avatars/avatar.jpg</a></li>\n</ul>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"欢迎留言\"><a href=\"#欢迎留言\" class=\"headerlink\" title=\"欢迎留言\"></a>欢迎留言</h1><p>大家有任何问题，都可以在评论区给我留言，或者加我联系方式：</p>\n<ul>\n<li>QQ：<strong>610998697</strong></li>\n<li>微信：<strong>zhangyue0808</strong></li>\n</ul>\n<p>我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。<br><strong>当然不介意小改改加我哦~~</strong></p>\n<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在评论区留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n<p>例如我的博客友链，大家可以加到自己博客里哦：</p>\n<ul>\n<li><strong>名称：</strong>Okeeper</li>\n<li><strong>地址：</strong><a href=\"https://okeeper.com\">https://okeeper.com</a></li>\n<li><strong>简介：</strong>一个喜欢周杰伦，既不文艺也没有才艺，平淡无奇的程序员而已</li>\n<li><strong>头像：</strong><a href=\"https://okeeper.com/medias/avatars/avatar.jpg\">https://okeeper.com/medias/avatars/avatar.jpg</a></li>\n</ul>\n"},{"title":"friends","date":"2019-07-19T08:42:10.000Z","type":"friends","layout":"friends","_content":"\n# 来啊，友链交换啊\n[传送门](https://okeeper.com/contact/)","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2019-07-19 16:42:10\ntype: \"friends\"\nlayout: \"friends\"\n---\n\n# 来啊，友链交换啊\n[传送门](https://okeeper.com/contact/)","updated":"2021-08-16T13:27:38.083Z","path":"friends/index.html","comments":1,"_id":"cl78yczi1000wvwm1ezy9sb1b","content":"<h1 id=\"来啊，友链交换啊\"><a href=\"#来啊，友链交换啊\" class=\"headerlink\" title=\"来啊，友链交换啊\"></a>来啊，友链交换啊</h1><p><a href=\"https://okeeper.com/contact/\">传送门</a></p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"来啊，友链交换啊\"><a href=\"#来啊，友链交换啊\" class=\"headerlink\" title=\"来啊，友链交换啊\"></a>来啊，友链交换啊</h1><p><a href=\"https://okeeper.com/contact/\">传送门</a></p>\n"},{"title":"tags","date":"2019-07-19T08:40:27.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-07-19 16:40:27\ntype: \"tags\"\nlayout: \"tags\"\n---","updated":"2021-08-16T13:27:38.132Z","path":"tags/index.html","comments":1,"_id":"cl78yczi1000xvwm1cjpqrtzr","content":"","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":""},{"title":"about","date":"2019-07-19T08:41:10.000Z","type":"about","layout":"about","_content":"\n# 教育经历\nJVTC Software technology graduate\n\n# 工作经历\n* <b>2018.3-2019.9 菜鸟网络</b>\n国际仓储WMS系统研发\n* <b>2015.5-2018.3 广东贵金属旗下合作公司百倍网络</b>\n微盘撮合交易系统核心开发兼架构\n\n# 获得荣誉\n* <b>一等奖学金</b>\n大三学年\n* <b>全国二等奖</b>\n蓝桥杯Java组\n* <b>省级一等奖</b>\n蓝桥杯Java组（江西）\n\n# 联系方式\n* <b>电子邮箱</b>\nzhangyue0808@qq.com\nokeeper.com@gmail.com\n* <b>微信</b>\nzhangyue0808\n* <b>QQ</b>\n610998697","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-07-19 16:41:10\ntype: \"about\"\nlayout: \"about\"\n---\n\n# 教育经历\nJVTC Software technology graduate\n\n# 工作经历\n* <b>2018.3-2019.9 菜鸟网络</b>\n国际仓储WMS系统研发\n* <b>2015.5-2018.3 广东贵金属旗下合作公司百倍网络</b>\n微盘撮合交易系统核心开发兼架构\n\n# 获得荣誉\n* <b>一等奖学金</b>\n大三学年\n* <b>全国二等奖</b>\n蓝桥杯Java组\n* <b>省级一等奖</b>\n蓝桥杯Java组（江西）\n\n# 联系方式\n* <b>电子邮箱</b>\nzhangyue0808@qq.com\nokeeper.com@gmail.com\n* <b>微信</b>\nzhangyue0808\n* <b>QQ</b>\n610998697","updated":"2021-08-16T13:27:38.080Z","path":"about/index.html","comments":1,"_id":"cl78yczi2000yvwm1k4lx3p5p","content":"<h1 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h1><p>JVTC Software technology graduate</p>\n<h1 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h1><ul>\n<li><b>2018.3-2019.9 菜鸟网络</b><br>国际仓储WMS系统研发</li>\n<li><b>2015.5-2018.3 广东贵金属旗下合作公司百倍网络</b><br>微盘撮合交易系统核心开发兼架构</li>\n</ul>\n<h1 id=\"获得荣誉\"><a href=\"#获得荣誉\" class=\"headerlink\" title=\"获得荣誉\"></a>获得荣誉</h1><ul>\n<li><b>一等奖学金</b><br>大三学年</li>\n<li><b>全国二等奖</b><br>蓝桥杯Java组</li>\n<li><b>省级一等奖</b><br>蓝桥杯Java组（江西）</li>\n</ul>\n<h1 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h1><ul>\n<li><b>电子邮箱</b><br><a href=\"mailto:zhangyue0808@qq.com\" target=\"_blank\" rel=\"noopener\">zhangyue0808@qq.com</a><br><a href=\"mailto:okeeper.com@gmail.com\" target=\"_blank\" rel=\"noopener\">okeeper.com@gmail.com</a></li>\n<li><b>微信</b><br>zhangyue0808</li>\n<li><b>QQ</b><br>610998697</li>\n</ul>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h1><p>JVTC Software technology graduate</p>\n<h1 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h1><ul>\n<li><b>2018.3-2019.9 菜鸟网络</b><br>国际仓储WMS系统研发</li>\n<li><b>2015.5-2018.3 广东贵金属旗下合作公司百倍网络</b><br>微盘撮合交易系统核心开发兼架构</li>\n</ul>\n<h1 id=\"获得荣誉\"><a href=\"#获得荣誉\" class=\"headerlink\" title=\"获得荣誉\"></a>获得荣誉</h1><ul>\n<li><b>一等奖学金</b><br>大三学年</li>\n<li><b>全国二等奖</b><br>蓝桥杯Java组</li>\n<li><b>省级一等奖</b><br>蓝桥杯Java组（江西）</li>\n</ul>\n<h1 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h1><ul>\n<li><b>电子邮箱</b><br><a href=\"mailto:zhangyue0808@qq.com\" target=\"_blank\" rel=\"noopener\">zhangyue0808@qq.com</a><br><a href=\"mailto:okeeper.com@gmail.com\" target=\"_blank\" rel=\"noopener\">okeeper.com@gmail.com</a></li>\n<li><b>微信</b><br>zhangyue0808</li>\n<li><b>QQ</b><br>610998697</li>\n</ul>\n"}],"Post":[{"title":"博客搭建的介绍","date":"2018-01-12T01:25:00.000Z","author":"okeeper","img":"/images/1.jpg","top":true,"cover":true,"coverImg":"/images/14.jpg","toc":true,"mathjax":false,"summary":"博客第一篇，介绍博客搭建的过程","_content":"\n# 介绍\n这是我修改自[hexo-theme-matery](https://github.com/godweiyang/hexo-matery-modified)的个性化hexo博客模板，主要修改了一些个性化配置，为了方便大家直接搭建使用。\n\n![image-20191128160144163](../images/blog-introduce/image-20191128160144163.png)\n\n\n# 我的博客演示\n\n[https://okeeper.com](https://okeeper.com)\n\n\n# 快速方法\n## 1. 下载主题源码\n为了减小源码的体积，我将插件目录`node_modules`进行了压缩，大家下载完后需要解压。另外添加水印需要的字体文件我也删除了，大家可以直接从电脑自带的字体库中拷贝。\n\n* 首先运行`git clone git@github.com:godweiyang/hexo-matery-modified.git`将所有文件下载到本地。\n* 解压`node_modules.zip`，然后删除`node_modules.zip`和`.git`文件夹。\n* 还缺一个字体（为图片添加水印需要用到），去`C:\\Windows\\Fonts`下找到`STSong Regular`，复制到`hexo-matery-modified`文件夹下。\n\n## 2. 环境准备\n### 2.1 安装Node.js\n首先下载稳定版Node.js，我这里给的是64位的。\n安装选项全部默认，一路点击Next。\n\n最后安装好之后，按Win+R打开命令提示符，输入`node -v`和`npm -v`，如果出现版本号，那么就安装成功了。\n\n添加国内镜像源\n如果没有梯子的话，可以使用阿里的国内镜像进行加速。\n```\nnpm config set registry https://registry.npm.taobao.org\n```\n\n### 2.2 安装hexo\n```\nnpm i hexo-cli -g\nhexo -v\nhexo init\n\n# 安装必要组件\nnpm install\n\n# 生成静态文件\nhexo g\n#启动服务器\nhexo s\n```\n\n## 3. 修改配置`_config.yml`\n```properties\n# 修改git配置，当执行 `hexo d` 时, 将自动提交到这个git地址\ndeploy:\n- type: git\n  repository: https://github.com/okeeper/okeeper.github.io.git\n  branch: master\n\n# 修改标题和关键字\n```\n\n## 4. 在github中添加你的博客项目\n一般为 {你的id}.github.io, 这样后续就可以直接通过 {你的id}.github.io访问到你的blog\n\n## 5. 编译&发布\n```\n# 编译source目录下的文章生成public静态文件\nhexo g\n# 提交到你的blog仓库\nhexo d\n```\n\n# 个性化\n### 1. 添加水印\n为了防止别人抄袭你文章，可以把所有的图片都加上水印，方法很简单。\n首先在博客根目录下新建一个watermark.py，代码如下：\n```python\n# -*- coding: utf-8 -*-\nimport sys\nimport glob\nfrom PIL import Image\nfrom PIL import ImageDraw\nfrom PIL import ImageFont\n\n\ndef watermark(post_name):\n    if post_name == 'all':\n        post_name = '*'\n    dir_name = 'source/_posts/' + post_name + '/*'\n    for files in glob.glob(dir_name):\n        im = Image.open(files)\n        if len(im.getbands()) < 3:\n            im = im.convert('RGB')\n            print(files)\n        font = ImageFont.truetype('STSONG.TTF', max(30, int(im.size[1] / 20)))\n        draw = ImageDraw.Draw(im)\n        draw.text((im.size[0] / 2, im.size[1] / 2),\n                  u'@godweiyang', fill=(0, 0, 0), font=font)\n        im.save(files)\n\n\nif __name__ == '__main__':\n    if len(sys.argv) == 2:\n        watermark(sys.argv[1])\n    else:\n        print('[usage] <input>')\n```\n字体也放根目录下，自己找字体。然后每次写完一篇文章可以运行python3 watermark.py postname添加水印，如果第一次运行要给所有文章添加水印，可以运行python3 watermark.py all\n\n### 2. 添加快速评论\n注册：https://leancloud.cn/\n```yaml\n# Valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey.\nvaline:\n  enable: true\n  appId: ***修改成你自己的appId\n  appKey: ***修改成你自己的appKey\n  notify: false\n  verify: false\n  visitor: false\n  avatar: 'wavatar' # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide\n  pageSize: 10\n  placeholder: '来都来了，不留点啥啊！' # Comment Box placeholder\n```\n\n### 3. 给文章添加背景音乐\n在.md的markdown文件的开头添加这段代码\n```\n<div align=\"middle\"><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66\"></iframe></div>\n```\n\n### 4. Front-matter 选项详解\n\n`Front-matter` 选项中的所有内容均为**非必填**的。但我仍然建议至少填写 `title` 和 `date` 的值。\n\n| 配置选项   | 默认值                      | 描述                                                         |\n| ---------- | --------------------------- | ------------------------------------------------------------ |\n| title      | `Markdown` 的文件标题        | 文章标题，强烈建议填写此选项                                 |\n| date       | 文件创建时的日期时间          | 发布时间，强烈建议填写此选项，且最好保证全局唯一             |\n| author     | 根 `_config.yml` 中的 `author` | 文章作者                                                     |\n| img        | `featureImages` 中的某个值   | 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: `http://xxx.com/xxx.jpg` |\n| top        | `true`                      | 推荐文章（文章是否置顶），如果 `top` 值为 `true`，则会作为首页推荐文章 |\n| cover      | `false`                     | `v1.0.2`版本新增，表示该文章是否需要加入到首页轮播封面中 |\n| coverImg   | 无                          | `v1.0.2`版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 |\n| password   | 无                          | 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 `password` 的值，该值必须是用 `SHA256` 加密后的密码，防止被他人识破。前提是在主题的 `config.yml` 中激活了 `verifyPassword` 选项 |\n| toc        | `true`                      | 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 `config.yml` 中激活了 `toc` 选项 |\n| mathjax    | `false`                     | 是否开启数学公式支持 ，本文章是否开启 `mathjax`，且需要在主题的 `_config.yml` 文件中也需要开启才行 |\n| summary    | 无                          | 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 |\n| categories | 无                          | 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 |\n| tags       | 无                          | 文章标签，一篇文章可以多个标签                              |\n| reprintPolicy       | cc_by                          | 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 |\n\n> **注意**:\n> 1. 如果 `img` 属性不填写的话，文章特色图会根据文章标题的 `hashcode` 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图**各有特色**。\n> 2. `date` 的值尽量保证每篇文章是唯一的，因为本主题中 `Gitalk` 和 `Gitment` 识别 `id` 是通过 `date` 的值来作为唯一标识的。\n> 3. 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 `_config.yml` 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：[开源中国在线工具](http://tool.oschina.net/encrypt?type=2)、[chahuo](http://encode.chahuo.com/)、[站长工具](http://tool.chinaz.com/tools/hash.aspx)。\n> 4. 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则\n\n\n以下为文章的 `Front-matter` 示例。\n```yaml\n---\ntitle: typora-vue-theme主题介绍\ndate: 2018-09-07 09:25:00\nauthor: 赵奇\nimg: /source/images/xxx.jpg\ntop: true\ncover: true\ncoverImg: /images/1.jpg\npassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92\ntoc: false\nmathjax: false\nsummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要\ncategories: Markdown\ntags:\n  - Typora\n  - Markdown\n---\n```\n\n# 搭建教程请参考\n[https://godweiyang.com/2018/04/13/hexo-blog/](https://godweiyang.com/2018/04/13/hexo-blog/)\n\n\n# 写文章、发布文章\n\n然后输入`hexo new post \"article title\"`，新建一篇文章。\n\n然后打开`source\\_posts`的目录，可以发现下面多了一个文件夹和一个`.md`文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。\n\n编写完markdown文件后，根目录下输入`hexo g`生成静态网页，然后输入`hexo s`可以本地预览效果，最后输入`hexo d`上传到github上。这时打开你的github.io主页就能看到发布的文章啦。\n\n\n# 结合Typora的markdown编辑器\n\n有强迫症的人适合当程序员，应为容不得半点不舒服\n\n对比了市面上的主流markdown编辑器，兼顾以下几个点的，好像只有Typora了\n\n- 即时预览，当你输入markdown关键字时自动变换预览格式\n- 截图直接粘贴生成图片存入指定目录，设置见文件->偏好设置>图像>路径配置\n- 简洁并支持主题自定义\n- 开源免费\n\n","source":"_posts/blog-introduce.md","raw":"---\ntitle: 博客搭建的介绍\ndate: 2018-1-12 09:25:00\nauthor: okeeper\nimg: /images/1.jpg\ntop: true\ncover: true\ncoverImg: /images/14.jpg\ntoc: true\nmathjax: false\nsummary: 博客第一篇，介绍博客搭建的过程\ncategories: 分享\ntags:\n  - Blog\n  - typora-vue-theme\n  - hexo\n---\n\n# 介绍\n这是我修改自[hexo-theme-matery](https://github.com/godweiyang/hexo-matery-modified)的个性化hexo博客模板，主要修改了一些个性化配置，为了方便大家直接搭建使用。\n\n![image-20191128160144163](../images/blog-introduce/image-20191128160144163.png)\n\n\n# 我的博客演示\n\n[https://okeeper.com](https://okeeper.com)\n\n\n# 快速方法\n## 1. 下载主题源码\n为了减小源码的体积，我将插件目录`node_modules`进行了压缩，大家下载完后需要解压。另外添加水印需要的字体文件我也删除了，大家可以直接从电脑自带的字体库中拷贝。\n\n* 首先运行`git clone git@github.com:godweiyang/hexo-matery-modified.git`将所有文件下载到本地。\n* 解压`node_modules.zip`，然后删除`node_modules.zip`和`.git`文件夹。\n* 还缺一个字体（为图片添加水印需要用到），去`C:\\Windows\\Fonts`下找到`STSong Regular`，复制到`hexo-matery-modified`文件夹下。\n\n## 2. 环境准备\n### 2.1 安装Node.js\n首先下载稳定版Node.js，我这里给的是64位的。\n安装选项全部默认，一路点击Next。\n\n最后安装好之后，按Win+R打开命令提示符，输入`node -v`和`npm -v`，如果出现版本号，那么就安装成功了。\n\n添加国内镜像源\n如果没有梯子的话，可以使用阿里的国内镜像进行加速。\n```\nnpm config set registry https://registry.npm.taobao.org\n```\n\n### 2.2 安装hexo\n```\nnpm i hexo-cli -g\nhexo -v\nhexo init\n\n# 安装必要组件\nnpm install\n\n# 生成静态文件\nhexo g\n#启动服务器\nhexo s\n```\n\n## 3. 修改配置`_config.yml`\n```properties\n# 修改git配置，当执行 `hexo d` 时, 将自动提交到这个git地址\ndeploy:\n- type: git\n  repository: https://github.com/okeeper/okeeper.github.io.git\n  branch: master\n\n# 修改标题和关键字\n```\n\n## 4. 在github中添加你的博客项目\n一般为 {你的id}.github.io, 这样后续就可以直接通过 {你的id}.github.io访问到你的blog\n\n## 5. 编译&发布\n```\n# 编译source目录下的文章生成public静态文件\nhexo g\n# 提交到你的blog仓库\nhexo d\n```\n\n# 个性化\n### 1. 添加水印\n为了防止别人抄袭你文章，可以把所有的图片都加上水印，方法很简单。\n首先在博客根目录下新建一个watermark.py，代码如下：\n```python\n# -*- coding: utf-8 -*-\nimport sys\nimport glob\nfrom PIL import Image\nfrom PIL import ImageDraw\nfrom PIL import ImageFont\n\n\ndef watermark(post_name):\n    if post_name == 'all':\n        post_name = '*'\n    dir_name = 'source/_posts/' + post_name + '/*'\n    for files in glob.glob(dir_name):\n        im = Image.open(files)\n        if len(im.getbands()) < 3:\n            im = im.convert('RGB')\n            print(files)\n        font = ImageFont.truetype('STSONG.TTF', max(30, int(im.size[1] / 20)))\n        draw = ImageDraw.Draw(im)\n        draw.text((im.size[0] / 2, im.size[1] / 2),\n                  u'@godweiyang', fill=(0, 0, 0), font=font)\n        im.save(files)\n\n\nif __name__ == '__main__':\n    if len(sys.argv) == 2:\n        watermark(sys.argv[1])\n    else:\n        print('[usage] <input>')\n```\n字体也放根目录下，自己找字体。然后每次写完一篇文章可以运行python3 watermark.py postname添加水印，如果第一次运行要给所有文章添加水印，可以运行python3 watermark.py all\n\n### 2. 添加快速评论\n注册：https://leancloud.cn/\n```yaml\n# Valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey.\nvaline:\n  enable: true\n  appId: ***修改成你自己的appId\n  appKey: ***修改成你自己的appKey\n  notify: false\n  verify: false\n  visitor: false\n  avatar: 'wavatar' # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide\n  pageSize: 10\n  placeholder: '来都来了，不留点啥啊！' # Comment Box placeholder\n```\n\n### 3. 给文章添加背景音乐\n在.md的markdown文件的开头添加这段代码\n```\n<div align=\"middle\"><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66\"></iframe></div>\n```\n\n### 4. Front-matter 选项详解\n\n`Front-matter` 选项中的所有内容均为**非必填**的。但我仍然建议至少填写 `title` 和 `date` 的值。\n\n| 配置选项   | 默认值                      | 描述                                                         |\n| ---------- | --------------------------- | ------------------------------------------------------------ |\n| title      | `Markdown` 的文件标题        | 文章标题，强烈建议填写此选项                                 |\n| date       | 文件创建时的日期时间          | 发布时间，强烈建议填写此选项，且最好保证全局唯一             |\n| author     | 根 `_config.yml` 中的 `author` | 文章作者                                                     |\n| img        | `featureImages` 中的某个值   | 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: `http://xxx.com/xxx.jpg` |\n| top        | `true`                      | 推荐文章（文章是否置顶），如果 `top` 值为 `true`，则会作为首页推荐文章 |\n| cover      | `false`                     | `v1.0.2`版本新增，表示该文章是否需要加入到首页轮播封面中 |\n| coverImg   | 无                          | `v1.0.2`版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 |\n| password   | 无                          | 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 `password` 的值，该值必须是用 `SHA256` 加密后的密码，防止被他人识破。前提是在主题的 `config.yml` 中激活了 `verifyPassword` 选项 |\n| toc        | `true`                      | 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 `config.yml` 中激活了 `toc` 选项 |\n| mathjax    | `false`                     | 是否开启数学公式支持 ，本文章是否开启 `mathjax`，且需要在主题的 `_config.yml` 文件中也需要开启才行 |\n| summary    | 无                          | 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 |\n| categories | 无                          | 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 |\n| tags       | 无                          | 文章标签，一篇文章可以多个标签                              |\n| reprintPolicy       | cc_by                          | 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 |\n\n> **注意**:\n> 1. 如果 `img` 属性不填写的话，文章特色图会根据文章标题的 `hashcode` 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图**各有特色**。\n> 2. `date` 的值尽量保证每篇文章是唯一的，因为本主题中 `Gitalk` 和 `Gitment` 识别 `id` 是通过 `date` 的值来作为唯一标识的。\n> 3. 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 `_config.yml` 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：[开源中国在线工具](http://tool.oschina.net/encrypt?type=2)、[chahuo](http://encode.chahuo.com/)、[站长工具](http://tool.chinaz.com/tools/hash.aspx)。\n> 4. 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则\n\n\n以下为文章的 `Front-matter` 示例。\n```yaml\n---\ntitle: typora-vue-theme主题介绍\ndate: 2018-09-07 09:25:00\nauthor: 赵奇\nimg: /source/images/xxx.jpg\ntop: true\ncover: true\ncoverImg: /images/1.jpg\npassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92\ntoc: false\nmathjax: false\nsummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要\ncategories: Markdown\ntags:\n  - Typora\n  - Markdown\n---\n```\n\n# 搭建教程请参考\n[https://godweiyang.com/2018/04/13/hexo-blog/](https://godweiyang.com/2018/04/13/hexo-blog/)\n\n\n# 写文章、发布文章\n\n然后输入`hexo new post \"article title\"`，新建一篇文章。\n\n然后打开`source\\_posts`的目录，可以发现下面多了一个文件夹和一个`.md`文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。\n\n编写完markdown文件后，根目录下输入`hexo g`生成静态网页，然后输入`hexo s`可以本地预览效果，最后输入`hexo d`上传到github上。这时打开你的github.io主页就能看到发布的文章啦。\n\n\n# 结合Typora的markdown编辑器\n\n有强迫症的人适合当程序员，应为容不得半点不舒服\n\n对比了市面上的主流markdown编辑器，兼顾以下几个点的，好像只有Typora了\n\n- 即时预览，当你输入markdown关键字时自动变换预览格式\n- 截图直接粘贴生成图片存入指定目录，设置见文件->偏好设置>图像>路径配置\n- 简洁并支持主题自定义\n- 开源免费\n\n","slug":"blog-introduce","published":1,"updated":"2021-08-16T13:27:38.079Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczfu0001vwm1ebk1ipr7","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>这是我修改自<a href=\"https://github.com/godweiyang/hexo-matery-modified\" target=\"_blank\" rel=\"noopener\">hexo-theme-matery</a>的个性化hexo博客模板，主要修改了一些个性化配置，为了方便大家直接搭建使用。</p>\n<p><img src=\"../images/blog-introduce/image-20191128160144163.png\" alt=\"image-20191128160144163\"></p>\n<h1 id=\"我的博客演示\"><a href=\"#我的博客演示\" class=\"headerlink\" title=\"我的博客演示\"></a>我的博客演示</h1><p><a href=\"https://okeeper.com\">https://okeeper.com</a></p>\n<h1 id=\"快速方法\"><a href=\"#快速方法\" class=\"headerlink\" title=\"快速方法\"></a>快速方法</h1><h2 id=\"1-下载主题源码\"><a href=\"#1-下载主题源码\" class=\"headerlink\" title=\"1. 下载主题源码\"></a>1. 下载主题源码</h2><p>为了减小源码的体积，我将插件目录<code>node_modules</code>进行了压缩，大家下载完后需要解压。另外添加水印需要的字体文件我也删除了，大家可以直接从电脑自带的字体库中拷贝。</p>\n<ul>\n<li>首先运行<code>git clone git@github.com:godweiyang/hexo-matery-modified.git</code>将所有文件下载到本地。</li>\n<li>解压<code>node_modules.zip</code>，然后删除<code>node_modules.zip</code>和<code>.git</code>文件夹。</li>\n<li>还缺一个字体（为图片添加水印需要用到），去<code>C:\\Windows\\Fonts</code>下找到<code>STSong Regular</code>，复制到<code>hexo-matery-modified</code>文件夹下。</li>\n</ul>\n<h2 id=\"2-环境准备\"><a href=\"#2-环境准备\" class=\"headerlink\" title=\"2. 环境准备\"></a>2. 环境准备</h2><h3 id=\"2-1-安装Node-js\"><a href=\"#2-1-安装Node-js\" class=\"headerlink\" title=\"2.1 安装Node.js\"></a>2.1 安装Node.js</h3><p>首先下载稳定版Node.js，我这里给的是64位的。<br>安装选项全部默认，一路点击Next。</p>\n<p>最后安装好之后，按Win+R打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p>\n<p>添加国内镜像源<br>如果没有梯子的话，可以使用阿里的国内镜像进行加速。</p>\n<pre><code>npm config set registry https://registry.npm.taobao.org</code></pre><h3 id=\"2-2-安装hexo\"><a href=\"#2-2-安装hexo\" class=\"headerlink\" title=\"2.2 安装hexo\"></a>2.2 安装hexo</h3><pre><code>npm i hexo-cli -g\nhexo -v\nhexo init\n\n# 安装必要组件\nnpm install\n\n# 生成静态文件\nhexo g\n#启动服务器\nhexo s</code></pre><h2 id=\"3-修改配置-config-yml\"><a href=\"#3-修改配置-config-yml\" class=\"headerlink\" title=\"3. 修改配置_config.yml\"></a>3. 修改配置<code>_config.yml</code></h2><pre class=\"line-numbers language-properties\"><code class=\"language-properties\"><span class=\"token comment\" spellcheck=\"true\"># 修改git配置，当执行 `hexo d` 时, 将自动提交到这个git地址</span>\n<span class=\"token attr-name\">deploy</span><span class=\"token punctuation\">:</span>\n<span class=\"token attr-name\">-</span> <span class=\"token attr-value\">type: git</span>\n<span class=\"token attr-name\">  repository</span><span class=\"token punctuation\">:</span> <span class=\"token attr-value\">https://github.com/okeeper/okeeper.github.io.git</span>\n<span class=\"token attr-name\">  branch</span><span class=\"token punctuation\">:</span> <span class=\"token attr-value\">master</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 修改标题和关键字</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"4-在github中添加你的博客项目\"><a href=\"#4-在github中添加你的博客项目\" class=\"headerlink\" title=\"4. 在github中添加你的博客项目\"></a>4. 在github中添加你的博客项目</h2><p>一般为 {你的id}.github.io, 这样后续就可以直接通过 {你的id}.github.io访问到你的blog</p>\n<h2 id=\"5-编译-amp-发布\"><a href=\"#5-编译-amp-发布\" class=\"headerlink\" title=\"5. 编译&amp;发布\"></a>5. 编译&amp;发布</h2><pre><code># 编译source目录下的文章生成public静态文件\nhexo g\n# 提交到你的blog仓库\nhexo d</code></pre><h1 id=\"个性化\"><a href=\"#个性化\" class=\"headerlink\" title=\"个性化\"></a>个性化</h1><h3 id=\"1-添加水印\"><a href=\"#1-添加水印\" class=\"headerlink\" title=\"1. 添加水印\"></a>1. 添加水印</h3><p>为了防止别人抄袭你文章，可以把所有的图片都加上水印，方法很简单。<br>首先在博客根目录下新建一个watermark.py，代码如下：</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># -*- coding: utf-8 -*-</span>\n<span class=\"token keyword\">import</span> sys\n<span class=\"token keyword\">import</span> glob\n<span class=\"token keyword\">from</span> PIL <span class=\"token keyword\">import</span> Image\n<span class=\"token keyword\">from</span> PIL <span class=\"token keyword\">import</span> ImageDraw\n<span class=\"token keyword\">from</span> PIL <span class=\"token keyword\">import</span> ImageFont\n\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">watermark</span><span class=\"token punctuation\">(</span>post_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> post_name <span class=\"token operator\">==</span> <span class=\"token string\">'all'</span><span class=\"token punctuation\">:</span>\n        post_name <span class=\"token operator\">=</span> <span class=\"token string\">'*'</span>\n    dir_name <span class=\"token operator\">=</span> <span class=\"token string\">'source/_posts/'</span> <span class=\"token operator\">+</span> post_name <span class=\"token operator\">+</span> <span class=\"token string\">'/*'</span>\n    <span class=\"token keyword\">for</span> files <span class=\"token keyword\">in</span> glob<span class=\"token punctuation\">.</span>glob<span class=\"token punctuation\">(</span>dir_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        im <span class=\"token operator\">=</span> Image<span class=\"token punctuation\">.</span>open<span class=\"token punctuation\">(</span>files<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> len<span class=\"token punctuation\">(</span>im<span class=\"token punctuation\">.</span>getbands<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">:</span>\n            im <span class=\"token operator\">=</span> im<span class=\"token punctuation\">.</span>convert<span class=\"token punctuation\">(</span><span class=\"token string\">'RGB'</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>files<span class=\"token punctuation\">)</span>\n        font <span class=\"token operator\">=</span> ImageFont<span class=\"token punctuation\">.</span>truetype<span class=\"token punctuation\">(</span><span class=\"token string\">'STSONG.TTF'</span><span class=\"token punctuation\">,</span> max<span class=\"token punctuation\">(</span><span class=\"token number\">30</span><span class=\"token punctuation\">,</span> int<span class=\"token punctuation\">(</span>im<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">/</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        draw <span class=\"token operator\">=</span> ImageDraw<span class=\"token punctuation\">.</span>Draw<span class=\"token punctuation\">(</span>im<span class=\"token punctuation\">)</span>\n        draw<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>im<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> im<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                  u<span class=\"token string\">'@godweiyang'</span><span class=\"token punctuation\">,</span> fill<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> font<span class=\"token operator\">=</span>font<span class=\"token punctuation\">)</span>\n        im<span class=\"token punctuation\">.</span>save<span class=\"token punctuation\">(</span>files<span class=\"token punctuation\">)</span>\n\n\n<span class=\"token keyword\">if</span> __name__ <span class=\"token operator\">==</span> <span class=\"token string\">'__main__'</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> len<span class=\"token punctuation\">(</span>sys<span class=\"token punctuation\">.</span>argv<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n        watermark<span class=\"token punctuation\">(</span>sys<span class=\"token punctuation\">.</span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'[usage] &lt;input>'</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>字体也放根目录下，自己找字体。然后每次写完一篇文章可以运行python3 watermark.py postname添加水印，如果第一次运行要给所有文章添加水印，可以运行python3 watermark.py all</p>\n<h3 id=\"2-添加快速评论\"><a href=\"#2-添加快速评论\" class=\"headerlink\" title=\"2. 添加快速评论\"></a>2. 添加快速评论</h3><p>注册：<a href=\"https://leancloud.cn/\" target=\"_blank\" rel=\"noopener\">https://leancloud.cn/</a></p>\n<pre class=\"line-numbers language-yaml\"><code class=\"language-yaml\"><span class=\"token comment\" spellcheck=\"true\"># Valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey.</span>\n<span class=\"token key atrule\">valine</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">enable</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n  <span class=\"token key atrule\">appId</span><span class=\"token punctuation\">:</span> ***修改成你自己的appId\n  <span class=\"token key atrule\">appKey</span><span class=\"token punctuation\">:</span> ***修改成你自己的appKey\n  <span class=\"token key atrule\">notify</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n  <span class=\"token key atrule\">verify</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n  <span class=\"token key atrule\">visitor</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n  <span class=\"token key atrule\">avatar</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'wavatar'</span> <span class=\"token comment\" spellcheck=\"true\"># Gravatar style : mm/identicon/monsterid/wavatar/retro/hide</span>\n  <span class=\"token key atrule\">pageSize</span><span class=\"token punctuation\">:</span> <span class=\"token number\">10</span>\n  <span class=\"token key atrule\">placeholder</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'来都来了，不留点啥啊！'</span> <span class=\"token comment\" spellcheck=\"true\"># Comment Box placeholder</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"3-给文章添加背景音乐\"><a href=\"#3-给文章添加背景音乐\" class=\"headerlink\" title=\"3. 给文章添加背景音乐\"></a>3. 给文章添加背景音乐</h3><p>在.md的markdown文件的开头添加这段代码</p>\n<pre><code>&lt;div align=&quot;middle&quot;&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=407679465&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;</code></pre><h3 id=\"4-Front-matter-选项详解\"><a href=\"#4-Front-matter-选项详解\" class=\"headerlink\" title=\"4. Front-matter 选项详解\"></a>4. Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p>\n<table>\n<thead>\n<tr>\n<th>配置选项</th>\n<th>默认值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td><code>Markdown</code> 的文件标题</td>\n<td>文章标题，强烈建议填写此选项</td>\n</tr>\n<tr>\n<td>date</td>\n<td>文件创建时的日期时间</td>\n<td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td>\n</tr>\n<tr>\n<td>author</td>\n<td>根 <code>_config.yml</code> 中的 <code>author</code></td>\n<td>文章作者</td>\n</tr>\n<tr>\n<td>img</td>\n<td><code>featureImages</code> 中的某个值</td>\n<td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td>\n</tr>\n<tr>\n<td>top</td>\n<td><code>true</code></td>\n<td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td>\n</tr>\n<tr>\n<td>cover</td>\n<td><code>false</code></td>\n<td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td>\n</tr>\n<tr>\n<td>coverImg</td>\n<td>无</td>\n<td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td>\n</tr>\n<tr>\n<td>password</td>\n<td>无</td>\n<td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td>\n</tr>\n<tr>\n<td>toc</td>\n<td><code>true</code></td>\n<td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td>\n</tr>\n<tr>\n<td>mathjax</td>\n<td><code>false</code></td>\n<td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td>\n</tr>\n<tr>\n<td>summary</td>\n<td>无</td>\n<td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td>\n</tr>\n<tr>\n<td>categories</td>\n<td>无</td>\n<td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>无</td>\n<td>文章标签，一篇文章可以多个标签</td>\n</tr>\n<tr>\n<td>reprintPolicy</td>\n<td>cc_by</td>\n<td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>注意</strong>:</p>\n<ol>\n<li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li>\n<li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li>\n<li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href=\"http://tool.oschina.net/encrypt?type=2\" target=\"_blank\" rel=\"noopener\">开源中国在线工具</a>、<a href=\"http://encode.chahuo.com/\" target=\"_blank\" rel=\"noopener\">chahuo</a>、<a href=\"http://tool.chinaz.com/tools/hash.aspx\" target=\"_blank\" rel=\"noopener\">站长工具</a>。</li>\n<li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li>\n</ol>\n</blockquote>\n<p>以下为文章的 <code>Front-matter</code> 示例。</p>\n<pre class=\"line-numbers language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">---</span>\n<span class=\"token key atrule\">title</span><span class=\"token punctuation\">:</span> typora<span class=\"token punctuation\">-</span>vue<span class=\"token punctuation\">-</span>theme主题介绍\n<span class=\"token key atrule\">date</span><span class=\"token punctuation\">:</span> <span class=\"token datetime number\">2018-09-07 09:25:00</span>\n<span class=\"token key atrule\">author</span><span class=\"token punctuation\">:</span> 赵奇\n<span class=\"token key atrule\">img</span><span class=\"token punctuation\">:</span> /source/images/xxx.jpg\n<span class=\"token key atrule\">top</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n<span class=\"token key atrule\">cover</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n<span class=\"token key atrule\">coverImg</span><span class=\"token punctuation\">:</span> /images/1.jpg\n<span class=\"token key atrule\">password</span><span class=\"token punctuation\">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92\n<span class=\"token key atrule\">toc</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n<span class=\"token key atrule\">mathjax</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n<span class=\"token key atrule\">summary</span><span class=\"token punctuation\">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要\n<span class=\"token key atrule\">categories</span><span class=\"token punctuation\">:</span> Markdown\n<span class=\"token key atrule\">tags</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> Typora\n  <span class=\"token punctuation\">-</span> Markdown\n<span class=\"token punctuation\">---</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"搭建教程请参考\"><a href=\"#搭建教程请参考\" class=\"headerlink\" title=\"搭建教程请参考\"></a>搭建教程请参考</h1><p><a href=\"https://godweiyang.com/2018/04/13/hexo-blog/\" target=\"_blank\" rel=\"noopener\">https://godweiyang.com/2018/04/13/hexo-blog/</a></p>\n<h1 id=\"写文章、发布文章\"><a href=\"#写文章、发布文章\" class=\"headerlink\" title=\"写文章、发布文章\"></a>写文章、发布文章</h1><p>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。</p>\n<p>然后打开<code>source\\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p>\n<p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p>\n<h1 id=\"结合Typora的markdown编辑器\"><a href=\"#结合Typora的markdown编辑器\" class=\"headerlink\" title=\"结合Typora的markdown编辑器\"></a>结合Typora的markdown编辑器</h1><p>有强迫症的人适合当程序员，应为容不得半点不舒服</p>\n<p>对比了市面上的主流markdown编辑器，兼顾以下几个点的，好像只有Typora了</p>\n<ul>\n<li>即时预览，当你输入markdown关键字时自动变换预览格式</li>\n<li>截图直接粘贴生成图片存入指定目录，设置见文件-&gt;偏好设置&gt;图像&gt;路径配置</li>\n<li>简洁并支持主题自定义</li>\n<li>开源免费</li>\n</ul>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>这是我修改自<a href=\"https://github.com/godweiyang/hexo-matery-modified\" target=\"_blank\" rel=\"noopener\">hexo-theme-matery</a>的个性化hexo博客模板，主要修改了一些个性化配置，为了方便大家直接搭建使用。</p>\n<p><img src=\"../images/blog-introduce/image-20191128160144163.png\" alt=\"image-20191128160144163\"></p>\n<h1 id=\"我的博客演示\"><a href=\"#我的博客演示\" class=\"headerlink\" title=\"我的博客演示\"></a>我的博客演示</h1><p><a href=\"https://okeeper.com\">https://okeeper.com</a></p>\n<h1 id=\"快速方法\"><a href=\"#快速方法\" class=\"headerlink\" title=\"快速方法\"></a>快速方法</h1><h2 id=\"1-下载主题源码\"><a href=\"#1-下载主题源码\" class=\"headerlink\" title=\"1. 下载主题源码\"></a>1. 下载主题源码</h2><p>为了减小源码的体积，我将插件目录<code>node_modules</code>进行了压缩，大家下载完后需要解压。另外添加水印需要的字体文件我也删除了，大家可以直接从电脑自带的字体库中拷贝。</p>\n<ul>\n<li>首先运行<code>git clone git@github.com:godweiyang/hexo-matery-modified.git</code>将所有文件下载到本地。</li>\n<li>解压<code>node_modules.zip</code>，然后删除<code>node_modules.zip</code>和<code>.git</code>文件夹。</li>\n<li>还缺一个字体（为图片添加水印需要用到），去<code>C:\\Windows\\Fonts</code>下找到<code>STSong Regular</code>，复制到<code>hexo-matery-modified</code>文件夹下。</li>\n</ul>\n<h2 id=\"2-环境准备\"><a href=\"#2-环境准备\" class=\"headerlink\" title=\"2. 环境准备\"></a>2. 环境准备</h2><h3 id=\"2-1-安装Node-js\"><a href=\"#2-1-安装Node-js\" class=\"headerlink\" title=\"2.1 安装Node.js\"></a>2.1 安装Node.js</h3><p>首先下载稳定版Node.js，我这里给的是64位的。<br>安装选项全部默认，一路点击Next。</p>\n<p>最后安装好之后，按Win+R打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p>\n<p>添加国内镜像源<br>如果没有梯子的话，可以使用阿里的国内镜像进行加速。</p>\n<pre><code>npm config set registry https://registry.npm.taobao.org</code></pre><h3 id=\"2-2-安装hexo\"><a href=\"#2-2-安装hexo\" class=\"headerlink\" title=\"2.2 安装hexo\"></a>2.2 安装hexo</h3><pre><code>npm i hexo-cli -g\nhexo -v\nhexo init\n\n# 安装必要组件\nnpm install\n\n# 生成静态文件\nhexo g\n#启动服务器\nhexo s</code></pre><h2 id=\"3-修改配置-config-yml\"><a href=\"#3-修改配置-config-yml\" class=\"headerlink\" title=\"3. 修改配置_config.yml\"></a>3. 修改配置<code>_config.yml</code></h2><pre><code class=\"properties\"># 修改git配置，当执行 `hexo d` 时, 将自动提交到这个git地址\ndeploy:\n- type: git\n  repository: https://github.com/okeeper/okeeper.github.io.git\n  branch: master\n\n# 修改标题和关键字</code></pre>\n<h2 id=\"4-在github中添加你的博客项目\"><a href=\"#4-在github中添加你的博客项目\" class=\"headerlink\" title=\"4. 在github中添加你的博客项目\"></a>4. 在github中添加你的博客项目</h2><p>一般为 {你的id}.github.io, 这样后续就可以直接通过 {你的id}.github.io访问到你的blog</p>\n<h2 id=\"5-编译-amp-发布\"><a href=\"#5-编译-amp-发布\" class=\"headerlink\" title=\"5. 编译&amp;发布\"></a>5. 编译&amp;发布</h2><pre><code># 编译source目录下的文章生成public静态文件\nhexo g\n# 提交到你的blog仓库\nhexo d</code></pre><h1 id=\"个性化\"><a href=\"#个性化\" class=\"headerlink\" title=\"个性化\"></a>个性化</h1><h3 id=\"1-添加水印\"><a href=\"#1-添加水印\" class=\"headerlink\" title=\"1. 添加水印\"></a>1. 添加水印</h3><p>为了防止别人抄袭你文章，可以把所有的图片都加上水印，方法很简单。<br>首先在博客根目录下新建一个watermark.py，代码如下：</p>\n<pre><code class=\"python\"># -*- coding: utf-8 -*-\nimport sys\nimport glob\nfrom PIL import Image\nfrom PIL import ImageDraw\nfrom PIL import ImageFont\n\n\ndef watermark(post_name):\n    if post_name == &#39;all&#39;:\n        post_name = &#39;*&#39;\n    dir_name = &#39;source/_posts/&#39; + post_name + &#39;/*&#39;\n    for files in glob.glob(dir_name):\n        im = Image.open(files)\n        if len(im.getbands()) &lt; 3:\n            im = im.convert(&#39;RGB&#39;)\n            print(files)\n        font = ImageFont.truetype(&#39;STSONG.TTF&#39;, max(30, int(im.size[1] / 20)))\n        draw = ImageDraw.Draw(im)\n        draw.text((im.size[0] / 2, im.size[1] / 2),\n                  u&#39;@godweiyang&#39;, fill=(0, 0, 0), font=font)\n        im.save(files)\n\n\nif __name__ == &#39;__main__&#39;:\n    if len(sys.argv) == 2:\n        watermark(sys.argv[1])\n    else:\n        print(&#39;[usage] &lt;input&gt;&#39;)</code></pre>\n<p>字体也放根目录下，自己找字体。然后每次写完一篇文章可以运行python3 watermark.py postname添加水印，如果第一次运行要给所有文章添加水印，可以运行python3 watermark.py all</p>\n<h3 id=\"2-添加快速评论\"><a href=\"#2-添加快速评论\" class=\"headerlink\" title=\"2. 添加快速评论\"></a>2. 添加快速评论</h3><p>注册：<a href=\"https://leancloud.cn/\" target=\"_blank\" rel=\"noopener\">https://leancloud.cn/</a></p>\n<pre><code class=\"yaml\"># Valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey.\nvaline:\n  enable: true\n  appId: ***修改成你自己的appId\n  appKey: ***修改成你自己的appKey\n  notify: false\n  verify: false\n  visitor: false\n  avatar: &#39;wavatar&#39; # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide\n  pageSize: 10\n  placeholder: &#39;来都来了，不留点啥啊！&#39; # Comment Box placeholder</code></pre>\n<h3 id=\"3-给文章添加背景音乐\"><a href=\"#3-给文章添加背景音乐\" class=\"headerlink\" title=\"3. 给文章添加背景音乐\"></a>3. 给文章添加背景音乐</h3><p>在.md的markdown文件的开头添加这段代码</p>\n<pre><code>&lt;div align=&quot;middle&quot;&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=407679465&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;</code></pre><h3 id=\"4-Front-matter-选项详解\"><a href=\"#4-Front-matter-选项详解\" class=\"headerlink\" title=\"4. Front-matter 选项详解\"></a>4. Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p>\n<table>\n<thead>\n<tr>\n<th>配置选项</th>\n<th>默认值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td><code>Markdown</code> 的文件标题</td>\n<td>文章标题，强烈建议填写此选项</td>\n</tr>\n<tr>\n<td>date</td>\n<td>文件创建时的日期时间</td>\n<td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td>\n</tr>\n<tr>\n<td>author</td>\n<td>根 <code>_config.yml</code> 中的 <code>author</code></td>\n<td>文章作者</td>\n</tr>\n<tr>\n<td>img</td>\n<td><code>featureImages</code> 中的某个值</td>\n<td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td>\n</tr>\n<tr>\n<td>top</td>\n<td><code>true</code></td>\n<td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td>\n</tr>\n<tr>\n<td>cover</td>\n<td><code>false</code></td>\n<td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td>\n</tr>\n<tr>\n<td>coverImg</td>\n<td>无</td>\n<td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td>\n</tr>\n<tr>\n<td>password</td>\n<td>无</td>\n<td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td>\n</tr>\n<tr>\n<td>toc</td>\n<td><code>true</code></td>\n<td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td>\n</tr>\n<tr>\n<td>mathjax</td>\n<td><code>false</code></td>\n<td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td>\n</tr>\n<tr>\n<td>summary</td>\n<td>无</td>\n<td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td>\n</tr>\n<tr>\n<td>categories</td>\n<td>无</td>\n<td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>无</td>\n<td>文章标签，一篇文章可以多个标签</td>\n</tr>\n<tr>\n<td>reprintPolicy</td>\n<td>cc_by</td>\n<td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>注意</strong>:</p>\n<ol>\n<li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li>\n<li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li>\n<li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href=\"http://tool.oschina.net/encrypt?type=2\" target=\"_blank\" rel=\"noopener\">开源中国在线工具</a>、<a href=\"http://encode.chahuo.com/\" target=\"_blank\" rel=\"noopener\">chahuo</a>、<a href=\"http://tool.chinaz.com/tools/hash.aspx\" target=\"_blank\" rel=\"noopener\">站长工具</a>。</li>\n<li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li>\n</ol>\n</blockquote>\n<p>以下为文章的 <code>Front-matter</code> 示例。</p>\n<pre><code class=\"yaml\">---\ntitle: typora-vue-theme主题介绍\ndate: 2018-09-07 09:25:00\nauthor: 赵奇\nimg: /source/images/xxx.jpg\ntop: true\ncover: true\ncoverImg: /images/1.jpg\npassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92\ntoc: false\nmathjax: false\nsummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要\ncategories: Markdown\ntags:\n  - Typora\n  - Markdown\n---</code></pre>\n<h1 id=\"搭建教程请参考\"><a href=\"#搭建教程请参考\" class=\"headerlink\" title=\"搭建教程请参考\"></a>搭建教程请参考</h1><p><a href=\"https://godweiyang.com/2018/04/13/hexo-blog/\" target=\"_blank\" rel=\"noopener\">https://godweiyang.com/2018/04/13/hexo-blog/</a></p>\n<h1 id=\"写文章、发布文章\"><a href=\"#写文章、发布文章\" class=\"headerlink\" title=\"写文章、发布文章\"></a>写文章、发布文章</h1><p>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。</p>\n<p>然后打开<code>source\\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p>\n<p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p>\n<h1 id=\"结合Typora的markdown编辑器\"><a href=\"#结合Typora的markdown编辑器\" class=\"headerlink\" title=\"结合Typora的markdown编辑器\"></a>结合Typora的markdown编辑器</h1><p>有强迫症的人适合当程序员，应为容不得半点不舒服</p>\n<p>对比了市面上的主流markdown编辑器，兼顾以下几个点的，好像只有Typora了</p>\n<ul>\n<li>即时预览，当你输入markdown关键字时自动变换预览格式</li>\n<li>截图直接粘贴生成图片存入指定目录，设置见文件-&gt;偏好设置&gt;图像&gt;路径配置</li>\n<li>简洁并支持主题自定义</li>\n<li>开源免费</li>\n</ul>\n"},{"title":"动态壁纸接口","date":"2019-11-28T10:25:00.000Z","author":"okeeper","top":false,"toc":true,"mathjax":false,"summary":"动态壁纸接口","_content":"\n\n\n# 新浪动态壁纸接口\n\n说明：[随机](https://www.nulltm.com/tag/随机)图片[壁纸](https://www.nulltm.com/tag/壁纸)[api](https://www.nulltm.com/tag/api)，调用的是[新浪](https://www.nulltm.com/tag/新浪)api，速度不用担心，图片资源也很多\n\n电脑动漫图片：[http://api.btstu.cn/sjbz/?lx=dongman](https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=dongman)\n\n电脑美女图片：[http://api.btstu.cn/sjbz/?lx=meizi](https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=meizi)\n\n电脑随机动漫妹子：[http://api.btstu.cn/sjbz/?lx=suiji](https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=suiji)\n\n手机动漫图片：[http://api.btstu.cn/sjbz/?lx=m_dongman](https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=m_dongman)\n\n手机美女图片：[http://api.btstu.cn/sjbz/?lx=m_meizi](https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=m_meizi)\n\n手机随机动漫妹子：[http://api.btstu.cn/sjbz/?m_lx=suiji](https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?m_lx=suiji)\n\n手机电脑自动判断，电脑显示适合电脑的壁纸，手机显示适合手机的壁纸 [http://api.btstu.cn/sjbz/zsy.php](https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/zsy.php)\n\napi现在已经有几千张图了，每天都在增加，大家可以玩玩\n\n# 必应动态壁纸接口\n\n必应在国内的名气不是很大，很多人不知道。必应是美国微软的搜索引擎，类似与百度。不过，有个地方很有趣，必应的首页背景图，每日一换，从不重复。都是团队精选的世界各地的风景、人文类的美图，配有相关文字描述。还是挺有意思的，不过好像只能保存近10多日的数据，超期就无法访问了。\n\n首先，第一个接口：http://cn.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1\n\n可以获得当日的必应壁纸无水印高清图片的路径以及版权等信息。具体返回格式如下：\n\n```json\n{\n    \"images\": [{\n        \"startdate\": \"20181118\",\n        \"fullstartdate\": \"201811181600\",\n        \"enddate\": \"20181119\",\n        \"url\": \"/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838_1920x1080.jpg\",\n        \"urlbase\": \"/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838\",\n        \"copyright\": \"锡安国家公园内的维尔京河，美国犹他州 (© Justinreznick/Getty Images)\",\n        \"copyrightlink\": \"http://www.bing.com/search?q=%E9%94%A1%E5%AE%89%E5%9B%BD%E5%AE%B6%E5%85%AC%E5%9B%AD&form=hpcapt&mkt=zh-cn\",\n        \"title\": \"\",\n        \"quiz\": \"/search?q=Bing+homepage+quiz&filters=WQOskey:%22HPQuiz_20181118_NarrowsZion%22&FORM=HPQUIZ\",\n        \"wp\": true,\n        \"hsh\": \"a2d2b96a5c113e78bc7a0f8a508cbf73\",\n        \"drk\": 1,\n        \"top\": 1,\n        \"bot\": 1,\n        \"hs\": []\n    }],\n    \"tooltips\": {\n        \"loading\": \"正在加载...\",\n        \"previous\": \"上一个图像\",\n        \"next\": \"下一个图像\",\n        \"walle\": \"此图片不能下载用作壁纸。\",\n        \"walls\": \"下载今日美图。仅限用作桌面壁纸。\"\n    }\n}\n```\n\n\n在url的路径上，拼上域名即可拿到图片：\n\nhttps://cn.bing.com/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838_1920x1080.jpg（如果这个打不开，请认真重读第一段最后几句。）\n\n值得注意的是，接口里的idx=后面的数字为0是今日的壁纸数据，1 2  3  4  5...依次是昨日、前日...   数字是-1是明日的数据。\n\n```json\n{\n    \"date\": \"November 19\",\n    \"title\": \"峡谷秘境\",\n    \"attribute\": \"美国，锡安国家公园\",\n    \"para1\": \"今天是美国犹他州锡安国家公园成立99周年的日子，一直以来，它是美国访问量最大的国家公园之一。这里到处都是令人惊叹的西南风景，包括锡安峡谷。壁纸中的地方叫做纳罗斯水道，它是一条穿过峡谷十分狭窄的小径，有的地方甚至只能勉强过一个人，而且有时需要淌着水行走。虽然这个时候水有点冷，但是这里的景色，一个转弯一个惊喜。\",\n    \"para2\": \"\",\n    \"provider\": \"© Justinreznick/Getty Images\",\n    \"imageUrl\": \"http://hpimges.blob.core.chinacloudapi.cn/coverstory/watermark_narrowszion_zh-cn9686302838_1920x1080.jpg\",\n    \"primaryImageUrl\": \"http://hpimges.blob.core.chinacloudapi.cn/coverstory/watermark_narrowszion_zh-cn9686302838_1920x1080.jpg\",\n    \"Country\": \"美国\",\n    \"City\": \"锡安国家公园\",\n    \"Longitude\": \"-112.946625\",\n    \"Latitude\": \"37.306900\",\n    \"Continent\": \"北美洲\",\n    \"CityInEnglish\": \"Zion National Park\",\n    \"CountryCode\": \"US\"\n}\n```\n\n\n如果在后面加?d=20181111则是提取2018年11月11日的壁纸故事。这个时间可以从20140501-至今.\n\nhttps://cn.bing.com/cnhp/coverstory?d=20181118\n\n \n\n有了这些，你就可以搭建一个壁纸站了，每日抓取官方壁纸数据展示，个人觉得，把这些保存下来还是挺有意义的。我前几日借用这两个接口写了一个简单的壁纸站，如果你实在懒得去弄的话，可以随时访问下载哦！最后留个链接，点击这里吧！必应壁纸\n\n \n\n附：\n\n如果你的网站想要每天更换壁纸壁纸，又不想写接口。下面这几个我写的接口就适合你了！\n\nhttps://api.neweb.top/bing.php   -----必应当日壁纸\n\nhttps://api.neweb.top/bing.php?type=future   ------必应明日壁纸\n\nhttps://api.neweb.top/bing.php?type=rand   -----近7日随机壁纸\n\n图片demo：（分别是明天、今天、随机的必应壁纸）\n\n\n\n使用方法：\n\n```html\n<img src=\"https://api.neweb.top/bing.php\" alt=\"必应壁纸\">\n```","source":"_posts/2019-11-28-动态壁纸接口.md","raw":"---\ntitle: 动态壁纸接口\ndate: 2019-11-28 18:25:00\nauthor: okeeper\ntop: false\ntoc: true\nmathjax: false\nsummary: 动态壁纸接口\ncategories: 分享\ntags:\n  - 分享\n---\n\n\n\n# 新浪动态壁纸接口\n\n说明：[随机](https://www.nulltm.com/tag/随机)图片[壁纸](https://www.nulltm.com/tag/壁纸)[api](https://www.nulltm.com/tag/api)，调用的是[新浪](https://www.nulltm.com/tag/新浪)api，速度不用担心，图片资源也很多\n\n电脑动漫图片：[http://api.btstu.cn/sjbz/?lx=dongman](https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=dongman)\n\n电脑美女图片：[http://api.btstu.cn/sjbz/?lx=meizi](https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=meizi)\n\n电脑随机动漫妹子：[http://api.btstu.cn/sjbz/?lx=suiji](https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=suiji)\n\n手机动漫图片：[http://api.btstu.cn/sjbz/?lx=m_dongman](https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=m_dongman)\n\n手机美女图片：[http://api.btstu.cn/sjbz/?lx=m_meizi](https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=m_meizi)\n\n手机随机动漫妹子：[http://api.btstu.cn/sjbz/?m_lx=suiji](https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?m_lx=suiji)\n\n手机电脑自动判断，电脑显示适合电脑的壁纸，手机显示适合手机的壁纸 [http://api.btstu.cn/sjbz/zsy.php](https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/zsy.php)\n\napi现在已经有几千张图了，每天都在增加，大家可以玩玩\n\n# 必应动态壁纸接口\n\n必应在国内的名气不是很大，很多人不知道。必应是美国微软的搜索引擎，类似与百度。不过，有个地方很有趣，必应的首页背景图，每日一换，从不重复。都是团队精选的世界各地的风景、人文类的美图，配有相关文字描述。还是挺有意思的，不过好像只能保存近10多日的数据，超期就无法访问了。\n\n首先，第一个接口：http://cn.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1\n\n可以获得当日的必应壁纸无水印高清图片的路径以及版权等信息。具体返回格式如下：\n\n```json\n{\n    \"images\": [{\n        \"startdate\": \"20181118\",\n        \"fullstartdate\": \"201811181600\",\n        \"enddate\": \"20181119\",\n        \"url\": \"/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838_1920x1080.jpg\",\n        \"urlbase\": \"/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838\",\n        \"copyright\": \"锡安国家公园内的维尔京河，美国犹他州 (© Justinreznick/Getty Images)\",\n        \"copyrightlink\": \"http://www.bing.com/search?q=%E9%94%A1%E5%AE%89%E5%9B%BD%E5%AE%B6%E5%85%AC%E5%9B%AD&form=hpcapt&mkt=zh-cn\",\n        \"title\": \"\",\n        \"quiz\": \"/search?q=Bing+homepage+quiz&filters=WQOskey:%22HPQuiz_20181118_NarrowsZion%22&FORM=HPQUIZ\",\n        \"wp\": true,\n        \"hsh\": \"a2d2b96a5c113e78bc7a0f8a508cbf73\",\n        \"drk\": 1,\n        \"top\": 1,\n        \"bot\": 1,\n        \"hs\": []\n    }],\n    \"tooltips\": {\n        \"loading\": \"正在加载...\",\n        \"previous\": \"上一个图像\",\n        \"next\": \"下一个图像\",\n        \"walle\": \"此图片不能下载用作壁纸。\",\n        \"walls\": \"下载今日美图。仅限用作桌面壁纸。\"\n    }\n}\n```\n\n\n在url的路径上，拼上域名即可拿到图片：\n\nhttps://cn.bing.com/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838_1920x1080.jpg（如果这个打不开，请认真重读第一段最后几句。）\n\n值得注意的是，接口里的idx=后面的数字为0是今日的壁纸数据，1 2  3  4  5...依次是昨日、前日...   数字是-1是明日的数据。\n\n```json\n{\n    \"date\": \"November 19\",\n    \"title\": \"峡谷秘境\",\n    \"attribute\": \"美国，锡安国家公园\",\n    \"para1\": \"今天是美国犹他州锡安国家公园成立99周年的日子，一直以来，它是美国访问量最大的国家公园之一。这里到处都是令人惊叹的西南风景，包括锡安峡谷。壁纸中的地方叫做纳罗斯水道，它是一条穿过峡谷十分狭窄的小径，有的地方甚至只能勉强过一个人，而且有时需要淌着水行走。虽然这个时候水有点冷，但是这里的景色，一个转弯一个惊喜。\",\n    \"para2\": \"\",\n    \"provider\": \"© Justinreznick/Getty Images\",\n    \"imageUrl\": \"http://hpimges.blob.core.chinacloudapi.cn/coverstory/watermark_narrowszion_zh-cn9686302838_1920x1080.jpg\",\n    \"primaryImageUrl\": \"http://hpimges.blob.core.chinacloudapi.cn/coverstory/watermark_narrowszion_zh-cn9686302838_1920x1080.jpg\",\n    \"Country\": \"美国\",\n    \"City\": \"锡安国家公园\",\n    \"Longitude\": \"-112.946625\",\n    \"Latitude\": \"37.306900\",\n    \"Continent\": \"北美洲\",\n    \"CityInEnglish\": \"Zion National Park\",\n    \"CountryCode\": \"US\"\n}\n```\n\n\n如果在后面加?d=20181111则是提取2018年11月11日的壁纸故事。这个时间可以从20140501-至今.\n\nhttps://cn.bing.com/cnhp/coverstory?d=20181118\n\n \n\n有了这些，你就可以搭建一个壁纸站了，每日抓取官方壁纸数据展示，个人觉得，把这些保存下来还是挺有意义的。我前几日借用这两个接口写了一个简单的壁纸站，如果你实在懒得去弄的话，可以随时访问下载哦！最后留个链接，点击这里吧！必应壁纸\n\n \n\n附：\n\n如果你的网站想要每天更换壁纸壁纸，又不想写接口。下面这几个我写的接口就适合你了！\n\nhttps://api.neweb.top/bing.php   -----必应当日壁纸\n\nhttps://api.neweb.top/bing.php?type=future   ------必应明日壁纸\n\nhttps://api.neweb.top/bing.php?type=rand   -----近7日随机壁纸\n\n图片demo：（分别是明天、今天、随机的必应壁纸）\n\n\n\n使用方法：\n\n```html\n<img src=\"https://api.neweb.top/bing.php\" alt=\"必应壁纸\">\n```","slug":"2019-11-28-动态壁纸接口","published":1,"updated":"2021-08-16T13:27:38.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczfy0003vwm1wmijztjm","content":"<h1 id=\"新浪动态壁纸接口\"><a href=\"#新浪动态壁纸接口\" class=\"headerlink\" title=\"新浪动态壁纸接口\"></a>新浪动态壁纸接口</h1><p>说明：<a href=\"https://www.nulltm.com/tag/随机\" target=\"_blank\" rel=\"noopener\">随机</a>图片<a href=\"https://www.nulltm.com/tag/壁纸\" target=\"_blank\" rel=\"noopener\">壁纸</a><a href=\"https://www.nulltm.com/tag/api\" target=\"_blank\" rel=\"noopener\">api</a>，调用的是<a href=\"https://www.nulltm.com/tag/新浪\" target=\"_blank\" rel=\"noopener\">新浪</a>api，速度不用担心，图片资源也很多</p>\n<p>电脑动漫图片：<a href=\"https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=dongman\" target=\"_blank\" rel=\"noopener\">http://api.btstu.cn/sjbz/?lx=dongman</a></p>\n<p>电脑美女图片：<a href=\"https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=meizi\" target=\"_blank\" rel=\"noopener\">http://api.btstu.cn/sjbz/?lx=meizi</a></p>\n<p>电脑随机动漫妹子：<a href=\"https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=suiji\" target=\"_blank\" rel=\"noopener\">http://api.btstu.cn/sjbz/?lx=suiji</a></p>\n<p>手机动漫图片：<a href=\"https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=m_dongman\" target=\"_blank\" rel=\"noopener\">http://api.btstu.cn/sjbz/?lx=m_dongman</a></p>\n<p>手机美女图片：<a href=\"https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=m_meizi\" target=\"_blank\" rel=\"noopener\">http://api.btstu.cn/sjbz/?lx=m_meizi</a></p>\n<p>手机随机动漫妹子：<a href=\"https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?m_lx=suiji\" target=\"_blank\" rel=\"noopener\">http://api.btstu.cn/sjbz/?m_lx=suiji</a></p>\n<p>手机电脑自动判断，电脑显示适合电脑的壁纸，手机显示适合手机的壁纸 <a href=\"https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/zsy.php\" target=\"_blank\" rel=\"noopener\">http://api.btstu.cn/sjbz/zsy.php</a></p>\n<p>api现在已经有几千张图了，每天都在增加，大家可以玩玩</p>\n<h1 id=\"必应动态壁纸接口\"><a href=\"#必应动态壁纸接口\" class=\"headerlink\" title=\"必应动态壁纸接口\"></a>必应动态壁纸接口</h1><p>必应在国内的名气不是很大，很多人不知道。必应是美国微软的搜索引擎，类似与百度。不过，有个地方很有趣，必应的首页背景图，每日一换，从不重复。都是团队精选的世界各地的风景、人文类的美图，配有相关文字描述。还是挺有意思的，不过好像只能保存近10多日的数据，超期就无法访问了。</p>\n<p>首先，第一个接口：<a href=\"http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1\" target=\"_blank\" rel=\"noopener\">http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1</a></p>\n<p>可以获得当日的必应壁纸无水印高清图片的路径以及版权等信息。具体返回格式如下：</p>\n<pre class=\"line-numbers language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"images\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"startdate\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"20181118\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"fullstartdate\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"201811181600\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"enddate\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"20181119\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"url\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838_1920x1080.jpg\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"urlbase\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"copyright\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"锡安国家公园内的维尔京河，美国犹他州 (© Justinreznick/Getty Images)\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"copyrightlink\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"http://www.bing.com/search?q=%E9%94%A1%E5%AE%89%E5%9B%BD%E5%AE%B6%E5%85%AC%E5%9B%AD&amp;form=hpcapt&amp;mkt=zh-cn\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"title\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"quiz\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20181118_NarrowsZion%22&amp;FORM=HPQUIZ\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"wp\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"hsh\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"a2d2b96a5c113e78bc7a0f8a508cbf73\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"drk\"</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"top\"</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"bot\"</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"hs\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"tooltips\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"loading\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"正在加载...\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"previous\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"上一个图像\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"next\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"下一个图像\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"walle\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"此图片不能下载用作壁纸。\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"walls\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"下载今日美图。仅限用作桌面壁纸。\"</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在url的路径上，拼上域名即可拿到图片：</p>\n<p><a href=\"https://cn.bing.com/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838_1920x1080.jpg（如果这个打不开，请认真重读第一段最后几句。）\" target=\"_blank\" rel=\"noopener\">https://cn.bing.com/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838_1920x1080.jpg（如果这个打不开，请认真重读第一段最后几句。）</a></p>\n<p>值得注意的是，接口里的idx=后面的数字为0是今日的壁纸数据，1 2  3  4  5…依次是昨日、前日…   数字是-1是明日的数据。</p>\n<pre class=\"line-numbers language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"date\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"November 19\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"title\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"峡谷秘境\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"attribute\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"美国，锡安国家公园\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"para1\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"今天是美国犹他州锡安国家公园成立99周年的日子，一直以来，它是美国访问量最大的国家公园之一。这里到处都是令人惊叹的西南风景，包括锡安峡谷。壁纸中的地方叫做纳罗斯水道，它是一条穿过峡谷十分狭窄的小径，有的地方甚至只能勉强过一个人，而且有时需要淌着水行走。虽然这个时候水有点冷，但是这里的景色，一个转弯一个惊喜。\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"para2\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"provider\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"© Justinreznick/Getty Images\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"imageUrl\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"http://hpimges.blob.core.chinacloudapi.cn/coverstory/watermark_narrowszion_zh-cn9686302838_1920x1080.jpg\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"primaryImageUrl\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"http://hpimges.blob.core.chinacloudapi.cn/coverstory/watermark_narrowszion_zh-cn9686302838_1920x1080.jpg\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"Country\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"美国\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"City\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"锡安国家公园\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"Longitude\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"-112.946625\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"Latitude\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"37.306900\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"Continent\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"北美洲\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"CityInEnglish\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Zion National Park\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"CountryCode\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"US\"</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>如果在后面加?d=20181111则是提取2018年11月11日的壁纸故事。这个时间可以从20140501-至今.</p>\n<p><a href=\"https://cn.bing.com/cnhp/coverstory?d=20181118\" target=\"_blank\" rel=\"noopener\">https://cn.bing.com/cnhp/coverstory?d=20181118</a></p>\n<p>有了这些，你就可以搭建一个壁纸站了，每日抓取官方壁纸数据展示，个人觉得，把这些保存下来还是挺有意义的。我前几日借用这两个接口写了一个简单的壁纸站，如果你实在懒得去弄的话，可以随时访问下载哦！最后留个链接，点击这里吧！必应壁纸</p>\n<p>附：</p>\n<p>如果你的网站想要每天更换壁纸壁纸，又不想写接口。下面这几个我写的接口就适合你了！</p>\n<p><a href=\"https://api.neweb.top/bing.php\" target=\"_blank\" rel=\"noopener\">https://api.neweb.top/bing.php</a>   —–必应当日壁纸</p>\n<p><a href=\"https://api.neweb.top/bing.php?type=future\" target=\"_blank\" rel=\"noopener\">https://api.neweb.top/bing.php?type=future</a>   ——必应明日壁纸</p>\n<p><a href=\"https://api.neweb.top/bing.php?type=rand\" target=\"_blank\" rel=\"noopener\">https://api.neweb.top/bing.php?type=rand</a>   —–近7日随机壁纸</p>\n<p>图片demo：（分别是明天、今天、随机的必应壁纸）</p>\n<p>使用方法：</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>https://api.neweb.top/bing.php<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">alt</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>必应壁纸<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"新浪动态壁纸接口\"><a href=\"#新浪动态壁纸接口\" class=\"headerlink\" title=\"新浪动态壁纸接口\"></a>新浪动态壁纸接口</h1><p>说明：<a href=\"https://www.nulltm.com/tag/随机\" target=\"_blank\" rel=\"noopener\">随机</a>图片<a href=\"https://www.nulltm.com/tag/壁纸\" target=\"_blank\" rel=\"noopener\">壁纸</a><a href=\"https://www.nulltm.com/tag/api\" target=\"_blank\" rel=\"noopener\">api</a>，调用的是<a href=\"https://www.nulltm.com/tag/新浪\" target=\"_blank\" rel=\"noopener\">新浪</a>api，速度不用担心，图片资源也很多</p>\n<p>电脑动漫图片：<a href=\"https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=dongman\" target=\"_blank\" rel=\"noopener\">http://api.btstu.cn/sjbz/?lx=dongman</a></p>\n<p>电脑美女图片：<a href=\"https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=meizi\" target=\"_blank\" rel=\"noopener\">http://api.btstu.cn/sjbz/?lx=meizi</a></p>\n<p>电脑随机动漫妹子：<a href=\"https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=suiji\" target=\"_blank\" rel=\"noopener\">http://api.btstu.cn/sjbz/?lx=suiji</a></p>\n<p>手机动漫图片：<a href=\"https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=m_dongman\" target=\"_blank\" rel=\"noopener\">http://api.btstu.cn/sjbz/?lx=m_dongman</a></p>\n<p>手机美女图片：<a href=\"https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?lx=m_meizi\" target=\"_blank\" rel=\"noopener\">http://api.btstu.cn/sjbz/?lx=m_meizi</a></p>\n<p>手机随机动漫妹子：<a href=\"https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/?m_lx=suiji\" target=\"_blank\" rel=\"noopener\">http://api.btstu.cn/sjbz/?m_lx=suiji</a></p>\n<p>手机电脑自动判断，电脑显示适合电脑的壁纸，手机显示适合手机的壁纸 <a href=\"https://www.nulltm.com/go/?url=http://api.btstu.cn/sjbz/zsy.php\" target=\"_blank\" rel=\"noopener\">http://api.btstu.cn/sjbz/zsy.php</a></p>\n<p>api现在已经有几千张图了，每天都在增加，大家可以玩玩</p>\n<h1 id=\"必应动态壁纸接口\"><a href=\"#必应动态壁纸接口\" class=\"headerlink\" title=\"必应动态壁纸接口\"></a>必应动态壁纸接口</h1><p>必应在国内的名气不是很大，很多人不知道。必应是美国微软的搜索引擎，类似与百度。不过，有个地方很有趣，必应的首页背景图，每日一换，从不重复。都是团队精选的世界各地的风景、人文类的美图，配有相关文字描述。还是挺有意思的，不过好像只能保存近10多日的数据，超期就无法访问了。</p>\n<p>首先，第一个接口：<a href=\"http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1\" target=\"_blank\" rel=\"noopener\">http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1</a></p>\n<p>可以获得当日的必应壁纸无水印高清图片的路径以及版权等信息。具体返回格式如下：</p>\n<pre><code class=\"json\">{\n    &quot;images&quot;: [{\n        &quot;startdate&quot;: &quot;20181118&quot;,\n        &quot;fullstartdate&quot;: &quot;201811181600&quot;,\n        &quot;enddate&quot;: &quot;20181119&quot;,\n        &quot;url&quot;: &quot;/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838_1920x1080.jpg&quot;,\n        &quot;urlbase&quot;: &quot;/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838&quot;,\n        &quot;copyright&quot;: &quot;锡安国家公园内的维尔京河，美国犹他州 (© Justinreznick/Getty Images)&quot;,\n        &quot;copyrightlink&quot;: &quot;http://www.bing.com/search?q=%E9%94%A1%E5%AE%89%E5%9B%BD%E5%AE%B6%E5%85%AC%E5%9B%AD&amp;form=hpcapt&amp;mkt=zh-cn&quot;,\n        &quot;title&quot;: &quot;&quot;,\n        &quot;quiz&quot;: &quot;/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20181118_NarrowsZion%22&amp;FORM=HPQUIZ&quot;,\n        &quot;wp&quot;: true,\n        &quot;hsh&quot;: &quot;a2d2b96a5c113e78bc7a0f8a508cbf73&quot;,\n        &quot;drk&quot;: 1,\n        &quot;top&quot;: 1,\n        &quot;bot&quot;: 1,\n        &quot;hs&quot;: []\n    }],\n    &quot;tooltips&quot;: {\n        &quot;loading&quot;: &quot;正在加载...&quot;,\n        &quot;previous&quot;: &quot;上一个图像&quot;,\n        &quot;next&quot;: &quot;下一个图像&quot;,\n        &quot;walle&quot;: &quot;此图片不能下载用作壁纸。&quot;,\n        &quot;walls&quot;: &quot;下载今日美图。仅限用作桌面壁纸。&quot;\n    }\n}</code></pre>\n<p>在url的路径上，拼上域名即可拿到图片：</p>\n<p><a href=\"https://cn.bing.com/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838_1920x1080.jpg（如果这个打不开，请认真重读第一段最后几句。）\" target=\"_blank\" rel=\"noopener\">https://cn.bing.com/az/hprichbg/rb/NarrowsZion_ZH-CN9686302838_1920x1080.jpg（如果这个打不开，请认真重读第一段最后几句。）</a></p>\n<p>值得注意的是，接口里的idx=后面的数字为0是今日的壁纸数据，1 2  3  4  5…依次是昨日、前日…   数字是-1是明日的数据。</p>\n<pre><code class=\"json\">{\n    &quot;date&quot;: &quot;November 19&quot;,\n    &quot;title&quot;: &quot;峡谷秘境&quot;,\n    &quot;attribute&quot;: &quot;美国，锡安国家公园&quot;,\n    &quot;para1&quot;: &quot;今天是美国犹他州锡安国家公园成立99周年的日子，一直以来，它是美国访问量最大的国家公园之一。这里到处都是令人惊叹的西南风景，包括锡安峡谷。壁纸中的地方叫做纳罗斯水道，它是一条穿过峡谷十分狭窄的小径，有的地方甚至只能勉强过一个人，而且有时需要淌着水行走。虽然这个时候水有点冷，但是这里的景色，一个转弯一个惊喜。&quot;,\n    &quot;para2&quot;: &quot;&quot;,\n    &quot;provider&quot;: &quot;© Justinreznick/Getty Images&quot;,\n    &quot;imageUrl&quot;: &quot;http://hpimges.blob.core.chinacloudapi.cn/coverstory/watermark_narrowszion_zh-cn9686302838_1920x1080.jpg&quot;,\n    &quot;primaryImageUrl&quot;: &quot;http://hpimges.blob.core.chinacloudapi.cn/coverstory/watermark_narrowszion_zh-cn9686302838_1920x1080.jpg&quot;,\n    &quot;Country&quot;: &quot;美国&quot;,\n    &quot;City&quot;: &quot;锡安国家公园&quot;,\n    &quot;Longitude&quot;: &quot;-112.946625&quot;,\n    &quot;Latitude&quot;: &quot;37.306900&quot;,\n    &quot;Continent&quot;: &quot;北美洲&quot;,\n    &quot;CityInEnglish&quot;: &quot;Zion National Park&quot;,\n    &quot;CountryCode&quot;: &quot;US&quot;\n}</code></pre>\n<p>如果在后面加?d=20181111则是提取2018年11月11日的壁纸故事。这个时间可以从20140501-至今.</p>\n<p><a href=\"https://cn.bing.com/cnhp/coverstory?d=20181118\" target=\"_blank\" rel=\"noopener\">https://cn.bing.com/cnhp/coverstory?d=20181118</a></p>\n<p>有了这些，你就可以搭建一个壁纸站了，每日抓取官方壁纸数据展示，个人觉得，把这些保存下来还是挺有意义的。我前几日借用这两个接口写了一个简单的壁纸站，如果你实在懒得去弄的话，可以随时访问下载哦！最后留个链接，点击这里吧！必应壁纸</p>\n<p>附：</p>\n<p>如果你的网站想要每天更换壁纸壁纸，又不想写接口。下面这几个我写的接口就适合你了！</p>\n<p><a href=\"https://api.neweb.top/bing.php\" target=\"_blank\" rel=\"noopener\">https://api.neweb.top/bing.php</a>   —–必应当日壁纸</p>\n<p><a href=\"https://api.neweb.top/bing.php?type=future\" target=\"_blank\" rel=\"noopener\">https://api.neweb.top/bing.php?type=future</a>   ——必应明日壁纸</p>\n<p><a href=\"https://api.neweb.top/bing.php?type=rand\" target=\"_blank\" rel=\"noopener\">https://api.neweb.top/bing.php?type=rand</a>   —–近7日随机壁纸</p>\n<p>图片demo：（分别是明天、今天、随机的必应壁纸）</p>\n<p>使用方法：</p>\n<pre><code class=\"html\">&lt;img src=&quot;https://api.neweb.top/bing.php&quot; alt=&quot;必应壁纸&quot;&gt;</code></pre>\n"},{"title":"RokectMQ 和Kafka对比","date":"2019-07-13T03:25:00.000Z","author":"okeeper","top":true,"toc":true,"mathjax":false,"summary":"RokectMQ 和Kafka的优缺点对比","_content":"\n# RokectMQ 和Kafka对比\n\n| 对比项         | Kafka                                                        | RocketMQ                                                     | 总结                                                         |\n| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 部署架构       | ![img](../images/rocketmq-vs-kafka/1562836313289_5.png)      | ![img](../images/rocketmq-vs-kafka/1562836232412_3.webp)     | 1. Zookeeper对应NameServer,NameServer没有用强一直的watch来监听各个节点可靠性，而是使用心跳机制。<br/>2. RocketMQ没有用ZK做高可用负载，原因是Broker在RocketMQ中就是物理概念，一台机器就是一个broker,Broker-Master和Broker-Slave关系在部署初始化是确认，运行过程中无需负载的选主切换，当然RMQ也就不支持在Broker-Master挂掉是自主选主Slave为master,需要手动切换。 |\n| 行3架构拓扑图  | ![img](../images/rocketmq-vs-kafka/1562837115046_7-1574933554003.png) | ![img](../images/rocketmq-vs-kafka/1562837123812_9.png)      | 1.kafka的partition对应rmq的queue<br/>2.都可以为topic指定对应的分区数量<br/>3.通过topic创建命令来说明topic、partition和broker<br/>(Master/Slave)的关系<br/>kafka:<br/> *sh bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 3 --topic mytopic* <br/>roketmq:<br/> *sh /root/rocketmq/bin/mqadmin updateTopic -c defaultCluster -readQueueNums/writeQueueNums 3 -t mytopic* <br/>可以看出不一样的是kafka需要指定<br/>--replication-factor来说明这个topic一个master需要几个slave，而rmq不需要，因为这个Master/slave拓扑结构是在配置写死的<br/>4. Kafka的Master/slave是逻辑结构，可以是同一台机器，而rmq不行，必须在初始化时就在配置文件中写死，要么是不同机器，要么是同一机器的不同进程（可以是端口不一样），是对应的物理结构。kafka可实现在通过zk自动Slave升级成Master<br/>5. Rmq之所以没有用zk做主备自动切换，也是为了简化整个系统的复杂度，无需过多的关心选主和一致性的问题，同时也为了保证消息的不乱序消费，造成业务异常。 |\n| 消息存储       | ![img](../images/rocketmq-vs-kafka/1562838493614_11.jpeg)    | ![img](../images/rocketmq-vs-kafka/1562838500422_13.jpeg)    | 1.kafka和rmq都是用文件形式来持久化消息2. kafka为每个partiion单独文件存储；而rmq不是所有的topic的所有queue的数据存储在commitlog中（默认按1G大小存储，超过时新建一个文件，按文件大小偏移量命名），并每个topic的每个queue用consumerqueue小文件存储消费位点信息，可以通过消费位点到commitlog快速定位到对应的数据行。rocketmq这样做的好处是：文件顺序写，小文件随机读。优化了kafka当topic较多时的性能问题。那么rmq是怎么做到的：<br/> - producer消息先投递到commitlog,异步最终一致写入consumerqueue - 由于是一个文件，根据linux文件写入缓存页批量写的机制，写入非常迅速，因为没有多个文件的资源竞争<br/>- 随机读，因为cosumerqueue中的数据非常少，能够一次性读取很多数据，访问速度和内存相当，通过预读取机制这部分性能可以忽略不计，对于commitlog这个大文件虽然是随机读，但是整体是有序的，还是可以充分利用PageCache的性能，再加上文件内存映射技术，很好的保障了在很多topic下的读写性能。 |\n| 性能           | 单机写入TPS约在百万条/秒，消息大小10个字节                   | RocketMQ单机写入TPS单实例约7万条/秒，单机部署3个Broker，可以跑到最高12万条/秒，消息大小10个字节 | 1. Kafka的TPS跑到单机百万，主要是由于Producer端将多个小消息合并，批量发向Broker <br/> 2. RocketMQ为什么没有这么做？Producer通常使用Java语言，缓存过多消息，GC是个很严重的问题Producer调用发送消息接口，消息未发送到Broker，向业务返回成功，此时Producer宕机，会导致消息丢失，业务出错Producer通常为分布式系统，且每台机器都是多线程发送，我们认为线上的系统单个Producer每秒产生的数据量有限，不可能上万。缓存的功能完全可以由上层业务完成。 |\n| 数据可靠性     | Kafka使用异步刷盘方式，异步Replication                       | RocketMQ支持异步实时刷盘，同步刷盘，同步Replication，异步Replication | 1.RocketMQ的同步刷盘在单机可靠性上比Kafka更高，不会因为操作系统Crash，导致数据丢失。在强可靠性要求场景可用 2.另外Kafka的Replication以topic为单位，支持主机宕机，备机自动切换，但是这里有个问题，由于是异步Replication，那么切换后会有数据丢失，且会有消息乱序的风险。 |\n| 消费失败重试   | Kafka消费失败不支持自动重试                                  | RocketMQ消费失败支持定时重试，每次重试间隔时间顺延           | 1. kafka如果需要实现消息重试，需要自己实现取出消息重新发送一遍。 |\n| 消息顺序       | Kafka支持消息顺序，但是一台Broker宕机后，就会产生消息乱序    | RocketMQ支持严格的消息顺序，在顺序消息场景下，一台Broker宕机后，发送消息会失败，但是不会乱序 | 当broker的leader挂掉瞬间，旧的leader对client可见，所以可能存在多个消费者消费不同的broker情况，造成消息乱序消费。 |\n| 定时消息消费   | Kafka不支持定时消息                                          | RocketMQ支持                                                 | 开源版本RocketMQ仅支持定时Level阿里云ONS支持定时Level，以及指定的毫秒级别的延时时间 |\n| 事物消息       | 不支持                                                       | 支持但是没有超时回查机制                                     | 阿里内部版本支持完整实物消息                                 |\n| 消息回溯       | 可以按照Offset来回溯消息                                     | 支持按照时间来回溯消息，精度毫秒，例如从一天之前的某时某分某秒开始重新消费消息 | 典型业务场景如consumer做订单分析，但是由于程序逻辑或者依赖的系统发生故障等原因，导致今天消费的消息全部无效，需要重新从昨天零点开始消费，那么以时间为起点的消息重放功能对于业务非常有帮助。 |\n| 消息消费并行度 | Kafka的消费并行度依赖Topic配置的分区数，如分区数为10，那么最多10台机器来并行消费（每台机器只能开启一个线程），或者一台机器消费（10个线程并行消费）。即消费并行度和分区数一致 | 顺序消费方式并行度同Kafka完全一致<br/> 乱序方式并行度取决于Consumer的线程数，如Topic配置10个队列，10台机器消费，每台机器100个线程，那么并行度为1000。 | RoketMQ在不要求顺序消费时，并行度可以很高                    |\n| 开发语言       | Scala                                                        | Java                                                         | 分布式系统中，Java的语言生态更好                             |\n| 消息堆积能力   | 非常好，上亿级                                               | 非常好，上亿级                                               | 消息堆积能力都非常好                                         |\n| 商业支持       | LinkIn开源                                                   | Alibaba开源                                                  |                                                              |\n| 成熟度         | Kafka在日志领域比较成熟                                      | RocketMQ在阿里集团内部有大量的应用在使用，每天都产生海量的消息，并且顺利支持了多次天猫双十一海量消息考验，是数据削峰填谷的利器。 | 商业场景RocketMQ更加适合，并且更符合开发习惯                 |\n\n\n# QA\n## 为什么使用消息队列?消息队列的作用是什么?\n异步化、解耦、消除峰值\n\n## Kafka 的 Topic 和分区内部是如何存储的，有什么特点?\n新建topic时指定分区数量，并为每个分区维护消息数据存储文件，随着topic数量增加，文件数量增加，读写性能下降。\n\n## 与传统的消息系统相比，Kafka 的消费模型有什么优点?\n1. Kafka是一个分布式系统，易于向外扩展。\n2. 它同时为发布和订阅提供高吞吐量。\n3. 它支持多订阅者，当失败时能自动平衡消费者。\n4. 消息的持久化。\n\n## Kafka 如何实现分布式的数据存储与数据读取?\n日志形式存储，并生成索引文件，能够通过offset下标快速定位数据行\n\n## Kafka 为什么比 RocketMQ 支持的单机 Partition 要少?\n数据存储形式决定，kafka为每个分区都生成存储文件，当较多的Parition时，随机写冲突加大，性能下降\n\n## 为什么需要分区，也就是说主题只有一个分区，难道不行吗?\n分区是为了尽可能的减少资源竞争，增加处理并行度\n\n## 日志为什么需要分段?\n方便快速清理无用数据，提高磁盘利用率\n\n## Kafka 是依靠什么机制保持高可靠，高可用?\n利用zk实现Master/Slave主备切换\n\n## 消息队列如何保证消息幂等?\n利用消息的唯一标识，在业务系统中做好幂等，消息中间件本身无需保证幂等\n\n## 让你自己设计个消息队列，你会怎么设计，会考虑哪些方面?\n- 消息的持久化\n- 分布式可靠性\n- 消息堆积能力\n- 消息重试\n\n> 参考文章：\n> [分布式消息队列RocketMQ与Kafka架构上的巨大差异](https://cloud.tencent.com/developer/news/306092)\n> [RocketMQ与Kafka对比](https://zl378837964.iteye.com/blog/2421888)\n> [RocketMQ吐血总结](https://github.com/javahongxi/whatsmars/wiki/RocketMQ%E5%90%90%E8%A1%80%E6%80%BB%E7%BB%93)\n> [RocketMQ原理介绍最透彻的文章](https://www.cnblogs.com/xiaodf/p/5075167.html)","source":"_posts/rocketmq-vs-kafka.md","raw":"---\ntitle: RokectMQ 和Kafka对比\ndate: 2019-07-13 11:25:00\nauthor: okeeper\ntop: true\ntoc: true\nmathjax: false\nsummary: RokectMQ 和Kafka的优缺点对比\ncategories: RocketMQ\ntags:\n  - RocketMQ\n  - Kafka\n  - MQ\n---\n\n# RokectMQ 和Kafka对比\n\n| 对比项         | Kafka                                                        | RocketMQ                                                     | 总结                                                         |\n| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 部署架构       | ![img](../images/rocketmq-vs-kafka/1562836313289_5.png)      | ![img](../images/rocketmq-vs-kafka/1562836232412_3.webp)     | 1. Zookeeper对应NameServer,NameServer没有用强一直的watch来监听各个节点可靠性，而是使用心跳机制。<br/>2. RocketMQ没有用ZK做高可用负载，原因是Broker在RocketMQ中就是物理概念，一台机器就是一个broker,Broker-Master和Broker-Slave关系在部署初始化是确认，运行过程中无需负载的选主切换，当然RMQ也就不支持在Broker-Master挂掉是自主选主Slave为master,需要手动切换。 |\n| 行3架构拓扑图  | ![img](../images/rocketmq-vs-kafka/1562837115046_7-1574933554003.png) | ![img](../images/rocketmq-vs-kafka/1562837123812_9.png)      | 1.kafka的partition对应rmq的queue<br/>2.都可以为topic指定对应的分区数量<br/>3.通过topic创建命令来说明topic、partition和broker<br/>(Master/Slave)的关系<br/>kafka:<br/> *sh bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 3 --topic mytopic* <br/>roketmq:<br/> *sh /root/rocketmq/bin/mqadmin updateTopic -c defaultCluster -readQueueNums/writeQueueNums 3 -t mytopic* <br/>可以看出不一样的是kafka需要指定<br/>--replication-factor来说明这个topic一个master需要几个slave，而rmq不需要，因为这个Master/slave拓扑结构是在配置写死的<br/>4. Kafka的Master/slave是逻辑结构，可以是同一台机器，而rmq不行，必须在初始化时就在配置文件中写死，要么是不同机器，要么是同一机器的不同进程（可以是端口不一样），是对应的物理结构。kafka可实现在通过zk自动Slave升级成Master<br/>5. Rmq之所以没有用zk做主备自动切换，也是为了简化整个系统的复杂度，无需过多的关心选主和一致性的问题，同时也为了保证消息的不乱序消费，造成业务异常。 |\n| 消息存储       | ![img](../images/rocketmq-vs-kafka/1562838493614_11.jpeg)    | ![img](../images/rocketmq-vs-kafka/1562838500422_13.jpeg)    | 1.kafka和rmq都是用文件形式来持久化消息2. kafka为每个partiion单独文件存储；而rmq不是所有的topic的所有queue的数据存储在commitlog中（默认按1G大小存储，超过时新建一个文件，按文件大小偏移量命名），并每个topic的每个queue用consumerqueue小文件存储消费位点信息，可以通过消费位点到commitlog快速定位到对应的数据行。rocketmq这样做的好处是：文件顺序写，小文件随机读。优化了kafka当topic较多时的性能问题。那么rmq是怎么做到的：<br/> - producer消息先投递到commitlog,异步最终一致写入consumerqueue - 由于是一个文件，根据linux文件写入缓存页批量写的机制，写入非常迅速，因为没有多个文件的资源竞争<br/>- 随机读，因为cosumerqueue中的数据非常少，能够一次性读取很多数据，访问速度和内存相当，通过预读取机制这部分性能可以忽略不计，对于commitlog这个大文件虽然是随机读，但是整体是有序的，还是可以充分利用PageCache的性能，再加上文件内存映射技术，很好的保障了在很多topic下的读写性能。 |\n| 性能           | 单机写入TPS约在百万条/秒，消息大小10个字节                   | RocketMQ单机写入TPS单实例约7万条/秒，单机部署3个Broker，可以跑到最高12万条/秒，消息大小10个字节 | 1. Kafka的TPS跑到单机百万，主要是由于Producer端将多个小消息合并，批量发向Broker <br/> 2. RocketMQ为什么没有这么做？Producer通常使用Java语言，缓存过多消息，GC是个很严重的问题Producer调用发送消息接口，消息未发送到Broker，向业务返回成功，此时Producer宕机，会导致消息丢失，业务出错Producer通常为分布式系统，且每台机器都是多线程发送，我们认为线上的系统单个Producer每秒产生的数据量有限，不可能上万。缓存的功能完全可以由上层业务完成。 |\n| 数据可靠性     | Kafka使用异步刷盘方式，异步Replication                       | RocketMQ支持异步实时刷盘，同步刷盘，同步Replication，异步Replication | 1.RocketMQ的同步刷盘在单机可靠性上比Kafka更高，不会因为操作系统Crash，导致数据丢失。在强可靠性要求场景可用 2.另外Kafka的Replication以topic为单位，支持主机宕机，备机自动切换，但是这里有个问题，由于是异步Replication，那么切换后会有数据丢失，且会有消息乱序的风险。 |\n| 消费失败重试   | Kafka消费失败不支持自动重试                                  | RocketMQ消费失败支持定时重试，每次重试间隔时间顺延           | 1. kafka如果需要实现消息重试，需要自己实现取出消息重新发送一遍。 |\n| 消息顺序       | Kafka支持消息顺序，但是一台Broker宕机后，就会产生消息乱序    | RocketMQ支持严格的消息顺序，在顺序消息场景下，一台Broker宕机后，发送消息会失败，但是不会乱序 | 当broker的leader挂掉瞬间，旧的leader对client可见，所以可能存在多个消费者消费不同的broker情况，造成消息乱序消费。 |\n| 定时消息消费   | Kafka不支持定时消息                                          | RocketMQ支持                                                 | 开源版本RocketMQ仅支持定时Level阿里云ONS支持定时Level，以及指定的毫秒级别的延时时间 |\n| 事物消息       | 不支持                                                       | 支持但是没有超时回查机制                                     | 阿里内部版本支持完整实物消息                                 |\n| 消息回溯       | 可以按照Offset来回溯消息                                     | 支持按照时间来回溯消息，精度毫秒，例如从一天之前的某时某分某秒开始重新消费消息 | 典型业务场景如consumer做订单分析，但是由于程序逻辑或者依赖的系统发生故障等原因，导致今天消费的消息全部无效，需要重新从昨天零点开始消费，那么以时间为起点的消息重放功能对于业务非常有帮助。 |\n| 消息消费并行度 | Kafka的消费并行度依赖Topic配置的分区数，如分区数为10，那么最多10台机器来并行消费（每台机器只能开启一个线程），或者一台机器消费（10个线程并行消费）。即消费并行度和分区数一致 | 顺序消费方式并行度同Kafka完全一致<br/> 乱序方式并行度取决于Consumer的线程数，如Topic配置10个队列，10台机器消费，每台机器100个线程，那么并行度为1000。 | RoketMQ在不要求顺序消费时，并行度可以很高                    |\n| 开发语言       | Scala                                                        | Java                                                         | 分布式系统中，Java的语言生态更好                             |\n| 消息堆积能力   | 非常好，上亿级                                               | 非常好，上亿级                                               | 消息堆积能力都非常好                                         |\n| 商业支持       | LinkIn开源                                                   | Alibaba开源                                                  |                                                              |\n| 成熟度         | Kafka在日志领域比较成熟                                      | RocketMQ在阿里集团内部有大量的应用在使用，每天都产生海量的消息，并且顺利支持了多次天猫双十一海量消息考验，是数据削峰填谷的利器。 | 商业场景RocketMQ更加适合，并且更符合开发习惯                 |\n\n\n# QA\n## 为什么使用消息队列?消息队列的作用是什么?\n异步化、解耦、消除峰值\n\n## Kafka 的 Topic 和分区内部是如何存储的，有什么特点?\n新建topic时指定分区数量，并为每个分区维护消息数据存储文件，随着topic数量增加，文件数量增加，读写性能下降。\n\n## 与传统的消息系统相比，Kafka 的消费模型有什么优点?\n1. Kafka是一个分布式系统，易于向外扩展。\n2. 它同时为发布和订阅提供高吞吐量。\n3. 它支持多订阅者，当失败时能自动平衡消费者。\n4. 消息的持久化。\n\n## Kafka 如何实现分布式的数据存储与数据读取?\n日志形式存储，并生成索引文件，能够通过offset下标快速定位数据行\n\n## Kafka 为什么比 RocketMQ 支持的单机 Partition 要少?\n数据存储形式决定，kafka为每个分区都生成存储文件，当较多的Parition时，随机写冲突加大，性能下降\n\n## 为什么需要分区，也就是说主题只有一个分区，难道不行吗?\n分区是为了尽可能的减少资源竞争，增加处理并行度\n\n## 日志为什么需要分段?\n方便快速清理无用数据，提高磁盘利用率\n\n## Kafka 是依靠什么机制保持高可靠，高可用?\n利用zk实现Master/Slave主备切换\n\n## 消息队列如何保证消息幂等?\n利用消息的唯一标识，在业务系统中做好幂等，消息中间件本身无需保证幂等\n\n## 让你自己设计个消息队列，你会怎么设计，会考虑哪些方面?\n- 消息的持久化\n- 分布式可靠性\n- 消息堆积能力\n- 消息重试\n\n> 参考文章：\n> [分布式消息队列RocketMQ与Kafka架构上的巨大差异](https://cloud.tencent.com/developer/news/306092)\n> [RocketMQ与Kafka对比](https://zl378837964.iteye.com/blog/2421888)\n> [RocketMQ吐血总结](https://github.com/javahongxi/whatsmars/wiki/RocketMQ%E5%90%90%E8%A1%80%E6%80%BB%E7%BB%93)\n> [RocketMQ原理介绍最透彻的文章](https://www.cnblogs.com/xiaodf/p/5075167.html)","slug":"rocketmq-vs-kafka","published":1,"updated":"2021-08-16T13:27:38.079Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczg20007vwm1ldxxhdbe","content":"<h1 id=\"RokectMQ-和Kafka对比\"><a href=\"#RokectMQ-和Kafka对比\" class=\"headerlink\" title=\"RokectMQ 和Kafka对比\"></a>RokectMQ 和Kafka对比</h1><table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>Kafka</th>\n<th>RocketMQ</th>\n<th>总结</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>部署架构</td>\n<td><img src=\"../images/rocketmq-vs-kafka/1562836313289_5.png\" alt=\"img\"></td>\n<td><img src=\"../images/rocketmq-vs-kafka/1562836232412_3.webp\" alt=\"img\"></td>\n<td>1. Zookeeper对应NameServer,NameServer没有用强一直的watch来监听各个节点可靠性，而是使用心跳机制。<br>2. RocketMQ没有用ZK做高可用负载，原因是Broker在RocketMQ中就是物理概念，一台机器就是一个broker,Broker-Master和Broker-Slave关系在部署初始化是确认，运行过程中无需负载的选主切换，当然RMQ也就不支持在Broker-Master挂掉是自主选主Slave为master,需要手动切换。</td>\n</tr>\n<tr>\n<td>行3架构拓扑图</td>\n<td><img src=\"../images/rocketmq-vs-kafka/1562837115046_7-1574933554003.png\" alt=\"img\"></td>\n<td><img src=\"../images/rocketmq-vs-kafka/1562837123812_9.png\" alt=\"img\"></td>\n<td>1.kafka的partition对应rmq的queue<br>2.都可以为topic指定对应的分区数量<br>3.通过topic创建命令来说明topic、partition和broker<br>(Master/Slave)的关系<br>kafka:<br> <em>sh bin/kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 3 –partitions 3 –topic mytopic</em> <br>roketmq:<br> <em>sh /root/rocketmq/bin/mqadmin updateTopic -c defaultCluster -readQueueNums/writeQueueNums 3 -t mytopic</em> <br>可以看出不一样的是kafka需要指定<br>–replication-factor来说明这个topic一个master需要几个slave，而rmq不需要，因为这个Master/slave拓扑结构是在配置写死的<br>4. Kafka的Master/slave是逻辑结构，可以是同一台机器，而rmq不行，必须在初始化时就在配置文件中写死，要么是不同机器，要么是同一机器的不同进程（可以是端口不一样），是对应的物理结构。kafka可实现在通过zk自动Slave升级成Master<br>5. Rmq之所以没有用zk做主备自动切换，也是为了简化整个系统的复杂度，无需过多的关心选主和一致性的问题，同时也为了保证消息的不乱序消费，造成业务异常。</td>\n</tr>\n<tr>\n<td>消息存储</td>\n<td><img src=\"../images/rocketmq-vs-kafka/1562838493614_11.jpeg\" alt=\"img\"></td>\n<td><img src=\"../images/rocketmq-vs-kafka/1562838500422_13.jpeg\" alt=\"img\"></td>\n<td>1.kafka和rmq都是用文件形式来持久化消息2. kafka为每个partiion单独文件存储；而rmq不是所有的topic的所有queue的数据存储在commitlog中（默认按1G大小存储，超过时新建一个文件，按文件大小偏移量命名），并每个topic的每个queue用consumerqueue小文件存储消费位点信息，可以通过消费位点到commitlog快速定位到对应的数据行。rocketmq这样做的好处是：文件顺序写，小文件随机读。优化了kafka当topic较多时的性能问题。那么rmq是怎么做到的：<br> - producer消息先投递到commitlog,异步最终一致写入consumerqueue - 由于是一个文件，根据linux文件写入缓存页批量写的机制，写入非常迅速，因为没有多个文件的资源竞争<br>- 随机读，因为cosumerqueue中的数据非常少，能够一次性读取很多数据，访问速度和内存相当，通过预读取机制这部分性能可以忽略不计，对于commitlog这个大文件虽然是随机读，但是整体是有序的，还是可以充分利用PageCache的性能，再加上文件内存映射技术，很好的保障了在很多topic下的读写性能。</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>单机写入TPS约在百万条/秒，消息大小10个字节</td>\n<td>RocketMQ单机写入TPS单实例约7万条/秒，单机部署3个Broker，可以跑到最高12万条/秒，消息大小10个字节</td>\n<td>1. Kafka的TPS跑到单机百万，主要是由于Producer端将多个小消息合并，批量发向Broker <br> 2. RocketMQ为什么没有这么做？Producer通常使用Java语言，缓存过多消息，GC是个很严重的问题Producer调用发送消息接口，消息未发送到Broker，向业务返回成功，此时Producer宕机，会导致消息丢失，业务出错Producer通常为分布式系统，且每台机器都是多线程发送，我们认为线上的系统单个Producer每秒产生的数据量有限，不可能上万。缓存的功能完全可以由上层业务完成。</td>\n</tr>\n<tr>\n<td>数据可靠性</td>\n<td>Kafka使用异步刷盘方式，异步Replication</td>\n<td>RocketMQ支持异步实时刷盘，同步刷盘，同步Replication，异步Replication</td>\n<td>1.RocketMQ的同步刷盘在单机可靠性上比Kafka更高，不会因为操作系统Crash，导致数据丢失。在强可靠性要求场景可用 2.另外Kafka的Replication以topic为单位，支持主机宕机，备机自动切换，但是这里有个问题，由于是异步Replication，那么切换后会有数据丢失，且会有消息乱序的风险。</td>\n</tr>\n<tr>\n<td>消费失败重试</td>\n<td>Kafka消费失败不支持自动重试</td>\n<td>RocketMQ消费失败支持定时重试，每次重试间隔时间顺延</td>\n<td>1. kafka如果需要实现消息重试，需要自己实现取出消息重新发送一遍。</td>\n</tr>\n<tr>\n<td>消息顺序</td>\n<td>Kafka支持消息顺序，但是一台Broker宕机后，就会产生消息乱序</td>\n<td>RocketMQ支持严格的消息顺序，在顺序消息场景下，一台Broker宕机后，发送消息会失败，但是不会乱序</td>\n<td>当broker的leader挂掉瞬间，旧的leader对client可见，所以可能存在多个消费者消费不同的broker情况，造成消息乱序消费。</td>\n</tr>\n<tr>\n<td>定时消息消费</td>\n<td>Kafka不支持定时消息</td>\n<td>RocketMQ支持</td>\n<td>开源版本RocketMQ仅支持定时Level阿里云ONS支持定时Level，以及指定的毫秒级别的延时时间</td>\n</tr>\n<tr>\n<td>事物消息</td>\n<td>不支持</td>\n<td>支持但是没有超时回查机制</td>\n<td>阿里内部版本支持完整实物消息</td>\n</tr>\n<tr>\n<td>消息回溯</td>\n<td>可以按照Offset来回溯消息</td>\n<td>支持按照时间来回溯消息，精度毫秒，例如从一天之前的某时某分某秒开始重新消费消息</td>\n<td>典型业务场景如consumer做订单分析，但是由于程序逻辑或者依赖的系统发生故障等原因，导致今天消费的消息全部无效，需要重新从昨天零点开始消费，那么以时间为起点的消息重放功能对于业务非常有帮助。</td>\n</tr>\n<tr>\n<td>消息消费并行度</td>\n<td>Kafka的消费并行度依赖Topic配置的分区数，如分区数为10，那么最多10台机器来并行消费（每台机器只能开启一个线程），或者一台机器消费（10个线程并行消费）。即消费并行度和分区数一致</td>\n<td>顺序消费方式并行度同Kafka完全一致<br> 乱序方式并行度取决于Consumer的线程数，如Topic配置10个队列，10台机器消费，每台机器100个线程，那么并行度为1000。</td>\n<td>RoketMQ在不要求顺序消费时，并行度可以很高</td>\n</tr>\n<tr>\n<td>开发语言</td>\n<td>Scala</td>\n<td>Java</td>\n<td>分布式系统中，Java的语言生态更好</td>\n</tr>\n<tr>\n<td>消息堆积能力</td>\n<td>非常好，上亿级</td>\n<td>非常好，上亿级</td>\n<td>消息堆积能力都非常好</td>\n</tr>\n<tr>\n<td>商业支持</td>\n<td>LinkIn开源</td>\n<td>Alibaba开源</td>\n<td></td>\n</tr>\n<tr>\n<td>成熟度</td>\n<td>Kafka在日志领域比较成熟</td>\n<td>RocketMQ在阿里集团内部有大量的应用在使用，每天都产生海量的消息，并且顺利支持了多次天猫双十一海量消息考验，是数据削峰填谷的利器。</td>\n<td>商业场景RocketMQ更加适合，并且更符合开发习惯</td>\n</tr>\n</tbody></table>\n<h1 id=\"QA\"><a href=\"#QA\" class=\"headerlink\" title=\"QA\"></a>QA</h1><h2 id=\"为什么使用消息队列-消息队列的作用是什么\"><a href=\"#为什么使用消息队列-消息队列的作用是什么\" class=\"headerlink\" title=\"为什么使用消息队列?消息队列的作用是什么?\"></a>为什么使用消息队列?消息队列的作用是什么?</h2><p>异步化、解耦、消除峰值</p>\n<h2 id=\"Kafka-的-Topic-和分区内部是如何存储的，有什么特点\"><a href=\"#Kafka-的-Topic-和分区内部是如何存储的，有什么特点\" class=\"headerlink\" title=\"Kafka 的 Topic 和分区内部是如何存储的，有什么特点?\"></a>Kafka 的 Topic 和分区内部是如何存储的，有什么特点?</h2><p>新建topic时指定分区数量，并为每个分区维护消息数据存储文件，随着topic数量增加，文件数量增加，读写性能下降。</p>\n<h2 id=\"与传统的消息系统相比，Kafka-的消费模型有什么优点\"><a href=\"#与传统的消息系统相比，Kafka-的消费模型有什么优点\" class=\"headerlink\" title=\"与传统的消息系统相比，Kafka 的消费模型有什么优点?\"></a>与传统的消息系统相比，Kafka 的消费模型有什么优点?</h2><ol>\n<li>Kafka是一个分布式系统，易于向外扩展。</li>\n<li>它同时为发布和订阅提供高吞吐量。</li>\n<li>它支持多订阅者，当失败时能自动平衡消费者。</li>\n<li>消息的持久化。</li>\n</ol>\n<h2 id=\"Kafka-如何实现分布式的数据存储与数据读取\"><a href=\"#Kafka-如何实现分布式的数据存储与数据读取\" class=\"headerlink\" title=\"Kafka 如何实现分布式的数据存储与数据读取?\"></a>Kafka 如何实现分布式的数据存储与数据读取?</h2><p>日志形式存储，并生成索引文件，能够通过offset下标快速定位数据行</p>\n<h2 id=\"Kafka-为什么比-RocketMQ-支持的单机-Partition-要少\"><a href=\"#Kafka-为什么比-RocketMQ-支持的单机-Partition-要少\" class=\"headerlink\" title=\"Kafka 为什么比 RocketMQ 支持的单机 Partition 要少?\"></a>Kafka 为什么比 RocketMQ 支持的单机 Partition 要少?</h2><p>数据存储形式决定，kafka为每个分区都生成存储文件，当较多的Parition时，随机写冲突加大，性能下降</p>\n<h2 id=\"为什么需要分区，也就是说主题只有一个分区，难道不行吗\"><a href=\"#为什么需要分区，也就是说主题只有一个分区，难道不行吗\" class=\"headerlink\" title=\"为什么需要分区，也就是说主题只有一个分区，难道不行吗?\"></a>为什么需要分区，也就是说主题只有一个分区，难道不行吗?</h2><p>分区是为了尽可能的减少资源竞争，增加处理并行度</p>\n<h2 id=\"日志为什么需要分段\"><a href=\"#日志为什么需要分段\" class=\"headerlink\" title=\"日志为什么需要分段?\"></a>日志为什么需要分段?</h2><p>方便快速清理无用数据，提高磁盘利用率</p>\n<h2 id=\"Kafka-是依靠什么机制保持高可靠，高可用\"><a href=\"#Kafka-是依靠什么机制保持高可靠，高可用\" class=\"headerlink\" title=\"Kafka 是依靠什么机制保持高可靠，高可用?\"></a>Kafka 是依靠什么机制保持高可靠，高可用?</h2><p>利用zk实现Master/Slave主备切换</p>\n<h2 id=\"消息队列如何保证消息幂等\"><a href=\"#消息队列如何保证消息幂等\" class=\"headerlink\" title=\"消息队列如何保证消息幂等?\"></a>消息队列如何保证消息幂等?</h2><p>利用消息的唯一标识，在业务系统中做好幂等，消息中间件本身无需保证幂等</p>\n<h2 id=\"让你自己设计个消息队列，你会怎么设计，会考虑哪些方面\"><a href=\"#让你自己设计个消息队列，你会怎么设计，会考虑哪些方面\" class=\"headerlink\" title=\"让你自己设计个消息队列，你会怎么设计，会考虑哪些方面?\"></a>让你自己设计个消息队列，你会怎么设计，会考虑哪些方面?</h2><ul>\n<li>消息的持久化</li>\n<li>分布式可靠性</li>\n<li>消息堆积能力</li>\n<li>消息重试</li>\n</ul>\n<blockquote>\n<p>参考文章：<br><a href=\"https://cloud.tencent.com/developer/news/306092\" target=\"_blank\" rel=\"noopener\">分布式消息队列RocketMQ与Kafka架构上的巨大差异</a><br><a href=\"https://zl378837964.iteye.com/blog/2421888\" target=\"_blank\" rel=\"noopener\">RocketMQ与Kafka对比</a><br><a href=\"https://github.com/javahongxi/whatsmars/wiki/RocketMQ%E5%90%90%E8%A1%80%E6%80%BB%E7%BB%93\" target=\"_blank\" rel=\"noopener\">RocketMQ吐血总结</a><br><a href=\"https://www.cnblogs.com/xiaodf/p/5075167.html\" target=\"_blank\" rel=\"noopener\">RocketMQ原理介绍最透彻的文章</a></p>\n</blockquote>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"RokectMQ-和Kafka对比\"><a href=\"#RokectMQ-和Kafka对比\" class=\"headerlink\" title=\"RokectMQ 和Kafka对比\"></a>RokectMQ 和Kafka对比</h1><table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>Kafka</th>\n<th>RocketMQ</th>\n<th>总结</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>部署架构</td>\n<td><img src=\"../images/rocketmq-vs-kafka/1562836313289_5.png\" alt=\"img\"></td>\n<td><img src=\"../images/rocketmq-vs-kafka/1562836232412_3.webp\" alt=\"img\"></td>\n<td>1. Zookeeper对应NameServer,NameServer没有用强一直的watch来监听各个节点可靠性，而是使用心跳机制。<br>2. RocketMQ没有用ZK做高可用负载，原因是Broker在RocketMQ中就是物理概念，一台机器就是一个broker,Broker-Master和Broker-Slave关系在部署初始化是确认，运行过程中无需负载的选主切换，当然RMQ也就不支持在Broker-Master挂掉是自主选主Slave为master,需要手动切换。</td>\n</tr>\n<tr>\n<td>行3架构拓扑图</td>\n<td><img src=\"../images/rocketmq-vs-kafka/1562837115046_7-1574933554003.png\" alt=\"img\"></td>\n<td><img src=\"../images/rocketmq-vs-kafka/1562837123812_9.png\" alt=\"img\"></td>\n<td>1.kafka的partition对应rmq的queue<br>2.都可以为topic指定对应的分区数量<br>3.通过topic创建命令来说明topic、partition和broker<br>(Master/Slave)的关系<br>kafka:<br> <em>sh bin/kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 3 –partitions 3 –topic mytopic</em> <br>roketmq:<br> <em>sh /root/rocketmq/bin/mqadmin updateTopic -c defaultCluster -readQueueNums/writeQueueNums 3 -t mytopic</em> <br>可以看出不一样的是kafka需要指定<br>–replication-factor来说明这个topic一个master需要几个slave，而rmq不需要，因为这个Master/slave拓扑结构是在配置写死的<br>4. Kafka的Master/slave是逻辑结构，可以是同一台机器，而rmq不行，必须在初始化时就在配置文件中写死，要么是不同机器，要么是同一机器的不同进程（可以是端口不一样），是对应的物理结构。kafka可实现在通过zk自动Slave升级成Master<br>5. Rmq之所以没有用zk做主备自动切换，也是为了简化整个系统的复杂度，无需过多的关心选主和一致性的问题，同时也为了保证消息的不乱序消费，造成业务异常。</td>\n</tr>\n<tr>\n<td>消息存储</td>\n<td><img src=\"../images/rocketmq-vs-kafka/1562838493614_11.jpeg\" alt=\"img\"></td>\n<td><img src=\"../images/rocketmq-vs-kafka/1562838500422_13.jpeg\" alt=\"img\"></td>\n<td>1.kafka和rmq都是用文件形式来持久化消息2. kafka为每个partiion单独文件存储；而rmq不是所有的topic的所有queue的数据存储在commitlog中（默认按1G大小存储，超过时新建一个文件，按文件大小偏移量命名），并每个topic的每个queue用consumerqueue小文件存储消费位点信息，可以通过消费位点到commitlog快速定位到对应的数据行。rocketmq这样做的好处是：文件顺序写，小文件随机读。优化了kafka当topic较多时的性能问题。那么rmq是怎么做到的：<br> - producer消息先投递到commitlog,异步最终一致写入consumerqueue - 由于是一个文件，根据linux文件写入缓存页批量写的机制，写入非常迅速，因为没有多个文件的资源竞争<br>- 随机读，因为cosumerqueue中的数据非常少，能够一次性读取很多数据，访问速度和内存相当，通过预读取机制这部分性能可以忽略不计，对于commitlog这个大文件虽然是随机读，但是整体是有序的，还是可以充分利用PageCache的性能，再加上文件内存映射技术，很好的保障了在很多topic下的读写性能。</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>单机写入TPS约在百万条/秒，消息大小10个字节</td>\n<td>RocketMQ单机写入TPS单实例约7万条/秒，单机部署3个Broker，可以跑到最高12万条/秒，消息大小10个字节</td>\n<td>1. Kafka的TPS跑到单机百万，主要是由于Producer端将多个小消息合并，批量发向Broker <br> 2. RocketMQ为什么没有这么做？Producer通常使用Java语言，缓存过多消息，GC是个很严重的问题Producer调用发送消息接口，消息未发送到Broker，向业务返回成功，此时Producer宕机，会导致消息丢失，业务出错Producer通常为分布式系统，且每台机器都是多线程发送，我们认为线上的系统单个Producer每秒产生的数据量有限，不可能上万。缓存的功能完全可以由上层业务完成。</td>\n</tr>\n<tr>\n<td>数据可靠性</td>\n<td>Kafka使用异步刷盘方式，异步Replication</td>\n<td>RocketMQ支持异步实时刷盘，同步刷盘，同步Replication，异步Replication</td>\n<td>1.RocketMQ的同步刷盘在单机可靠性上比Kafka更高，不会因为操作系统Crash，导致数据丢失。在强可靠性要求场景可用 2.另外Kafka的Replication以topic为单位，支持主机宕机，备机自动切换，但是这里有个问题，由于是异步Replication，那么切换后会有数据丢失，且会有消息乱序的风险。</td>\n</tr>\n<tr>\n<td>消费失败重试</td>\n<td>Kafka消费失败不支持自动重试</td>\n<td>RocketMQ消费失败支持定时重试，每次重试间隔时间顺延</td>\n<td>1. kafka如果需要实现消息重试，需要自己实现取出消息重新发送一遍。</td>\n</tr>\n<tr>\n<td>消息顺序</td>\n<td>Kafka支持消息顺序，但是一台Broker宕机后，就会产生消息乱序</td>\n<td>RocketMQ支持严格的消息顺序，在顺序消息场景下，一台Broker宕机后，发送消息会失败，但是不会乱序</td>\n<td>当broker的leader挂掉瞬间，旧的leader对client可见，所以可能存在多个消费者消费不同的broker情况，造成消息乱序消费。</td>\n</tr>\n<tr>\n<td>定时消息消费</td>\n<td>Kafka不支持定时消息</td>\n<td>RocketMQ支持</td>\n<td>开源版本RocketMQ仅支持定时Level阿里云ONS支持定时Level，以及指定的毫秒级别的延时时间</td>\n</tr>\n<tr>\n<td>事物消息</td>\n<td>不支持</td>\n<td>支持但是没有超时回查机制</td>\n<td>阿里内部版本支持完整实物消息</td>\n</tr>\n<tr>\n<td>消息回溯</td>\n<td>可以按照Offset来回溯消息</td>\n<td>支持按照时间来回溯消息，精度毫秒，例如从一天之前的某时某分某秒开始重新消费消息</td>\n<td>典型业务场景如consumer做订单分析，但是由于程序逻辑或者依赖的系统发生故障等原因，导致今天消费的消息全部无效，需要重新从昨天零点开始消费，那么以时间为起点的消息重放功能对于业务非常有帮助。</td>\n</tr>\n<tr>\n<td>消息消费并行度</td>\n<td>Kafka的消费并行度依赖Topic配置的分区数，如分区数为10，那么最多10台机器来并行消费（每台机器只能开启一个线程），或者一台机器消费（10个线程并行消费）。即消费并行度和分区数一致</td>\n<td>顺序消费方式并行度同Kafka完全一致<br> 乱序方式并行度取决于Consumer的线程数，如Topic配置10个队列，10台机器消费，每台机器100个线程，那么并行度为1000。</td>\n<td>RoketMQ在不要求顺序消费时，并行度可以很高</td>\n</tr>\n<tr>\n<td>开发语言</td>\n<td>Scala</td>\n<td>Java</td>\n<td>分布式系统中，Java的语言生态更好</td>\n</tr>\n<tr>\n<td>消息堆积能力</td>\n<td>非常好，上亿级</td>\n<td>非常好，上亿级</td>\n<td>消息堆积能力都非常好</td>\n</tr>\n<tr>\n<td>商业支持</td>\n<td>LinkIn开源</td>\n<td>Alibaba开源</td>\n<td></td>\n</tr>\n<tr>\n<td>成熟度</td>\n<td>Kafka在日志领域比较成熟</td>\n<td>RocketMQ在阿里集团内部有大量的应用在使用，每天都产生海量的消息，并且顺利支持了多次天猫双十一海量消息考验，是数据削峰填谷的利器。</td>\n<td>商业场景RocketMQ更加适合，并且更符合开发习惯</td>\n</tr>\n</tbody></table>\n<h1 id=\"QA\"><a href=\"#QA\" class=\"headerlink\" title=\"QA\"></a>QA</h1><h2 id=\"为什么使用消息队列-消息队列的作用是什么\"><a href=\"#为什么使用消息队列-消息队列的作用是什么\" class=\"headerlink\" title=\"为什么使用消息队列?消息队列的作用是什么?\"></a>为什么使用消息队列?消息队列的作用是什么?</h2><p>异步化、解耦、消除峰值</p>\n<h2 id=\"Kafka-的-Topic-和分区内部是如何存储的，有什么特点\"><a href=\"#Kafka-的-Topic-和分区内部是如何存储的，有什么特点\" class=\"headerlink\" title=\"Kafka 的 Topic 和分区内部是如何存储的，有什么特点?\"></a>Kafka 的 Topic 和分区内部是如何存储的，有什么特点?</h2><p>新建topic时指定分区数量，并为每个分区维护消息数据存储文件，随着topic数量增加，文件数量增加，读写性能下降。</p>\n<h2 id=\"与传统的消息系统相比，Kafka-的消费模型有什么优点\"><a href=\"#与传统的消息系统相比，Kafka-的消费模型有什么优点\" class=\"headerlink\" title=\"与传统的消息系统相比，Kafka 的消费模型有什么优点?\"></a>与传统的消息系统相比，Kafka 的消费模型有什么优点?</h2><ol>\n<li>Kafka是一个分布式系统，易于向外扩展。</li>\n<li>它同时为发布和订阅提供高吞吐量。</li>\n<li>它支持多订阅者，当失败时能自动平衡消费者。</li>\n<li>消息的持久化。</li>\n</ol>\n<h2 id=\"Kafka-如何实现分布式的数据存储与数据读取\"><a href=\"#Kafka-如何实现分布式的数据存储与数据读取\" class=\"headerlink\" title=\"Kafka 如何实现分布式的数据存储与数据读取?\"></a>Kafka 如何实现分布式的数据存储与数据读取?</h2><p>日志形式存储，并生成索引文件，能够通过offset下标快速定位数据行</p>\n<h2 id=\"Kafka-为什么比-RocketMQ-支持的单机-Partition-要少\"><a href=\"#Kafka-为什么比-RocketMQ-支持的单机-Partition-要少\" class=\"headerlink\" title=\"Kafka 为什么比 RocketMQ 支持的单机 Partition 要少?\"></a>Kafka 为什么比 RocketMQ 支持的单机 Partition 要少?</h2><p>数据存储形式决定，kafka为每个分区都生成存储文件，当较多的Parition时，随机写冲突加大，性能下降</p>\n<h2 id=\"为什么需要分区，也就是说主题只有一个分区，难道不行吗\"><a href=\"#为什么需要分区，也就是说主题只有一个分区，难道不行吗\" class=\"headerlink\" title=\"为什么需要分区，也就是说主题只有一个分区，难道不行吗?\"></a>为什么需要分区，也就是说主题只有一个分区，难道不行吗?</h2><p>分区是为了尽可能的减少资源竞争，增加处理并行度</p>\n<h2 id=\"日志为什么需要分段\"><a href=\"#日志为什么需要分段\" class=\"headerlink\" title=\"日志为什么需要分段?\"></a>日志为什么需要分段?</h2><p>方便快速清理无用数据，提高磁盘利用率</p>\n<h2 id=\"Kafka-是依靠什么机制保持高可靠，高可用\"><a href=\"#Kafka-是依靠什么机制保持高可靠，高可用\" class=\"headerlink\" title=\"Kafka 是依靠什么机制保持高可靠，高可用?\"></a>Kafka 是依靠什么机制保持高可靠，高可用?</h2><p>利用zk实现Master/Slave主备切换</p>\n<h2 id=\"消息队列如何保证消息幂等\"><a href=\"#消息队列如何保证消息幂等\" class=\"headerlink\" title=\"消息队列如何保证消息幂等?\"></a>消息队列如何保证消息幂等?</h2><p>利用消息的唯一标识，在业务系统中做好幂等，消息中间件本身无需保证幂等</p>\n<h2 id=\"让你自己设计个消息队列，你会怎么设计，会考虑哪些方面\"><a href=\"#让你自己设计个消息队列，你会怎么设计，会考虑哪些方面\" class=\"headerlink\" title=\"让你自己设计个消息队列，你会怎么设计，会考虑哪些方面?\"></a>让你自己设计个消息队列，你会怎么设计，会考虑哪些方面?</h2><ul>\n<li>消息的持久化</li>\n<li>分布式可靠性</li>\n<li>消息堆积能力</li>\n<li>消息重试</li>\n</ul>\n<blockquote>\n<p>参考文章：<br><a href=\"https://cloud.tencent.com/developer/news/306092\" target=\"_blank\" rel=\"noopener\">分布式消息队列RocketMQ与Kafka架构上的巨大差异</a><br><a href=\"https://zl378837964.iteye.com/blog/2421888\" target=\"_blank\" rel=\"noopener\">RocketMQ与Kafka对比</a><br><a href=\"https://github.com/javahongxi/whatsmars/wiki/RocketMQ%E5%90%90%E8%A1%80%E6%80%BB%E7%BB%93\" target=\"_blank\" rel=\"noopener\">RocketMQ吐血总结</a><br><a href=\"https://www.cnblogs.com/xiaodf/p/5075167.html\" target=\"_blank\" rel=\"noopener\">RocketMQ原理介绍最透彻的文章</a></p>\n</blockquote>\n"},{"title":"系统架构师——软件开发方法","date":"2020-04-30T03:25:00.000Z","author":"okeeper","top":true,"toc":true,"summary":"软件开发方法是软件开发的方法学，旨在提供软件的质量，降低开发成本","_content":"\n> 前言：软件开发方法是软件开发的方法学，旨在提供软件的质量，降低开发成本\n\n# 1 软件生命周期\n\n 1. 可行性研究和规划：通过可行性分析确认原件的必要性，价值点，初步确认软件的目标、范围、风险和开发成本等内容。\n 2. 需求分析：需求分析是开发过程的重要阶段，初步确认软件开发的目标和范围，之后则要对软件的需求进行细致分析，确认最终要做成什么样子。这个过程极其重要，如果这个阶段出现分析错误和偏差将导致后续开发过程偏离真实需求越远，修正的成本越大。\n 3. 概要设计：是程序员开发过程中的蓝图，包括确认系统架构、各个子系统依赖关系、数据库模型、编码规范、接口规约等内容\n 4. 详细设计：详细设计师开发之前的最后设计，是在概要设计的基础上进行进行细化，如类设计。详细设计不是必要过程，在规模较小，功能结构简单的系统中可以省略。\n 5. 实现：针对设计的单元模块进行开发，如一个过程、方法、函数，包括实现单元模块的单元测试\n 6. 集成测试：对单元模块进行组装联调测试\n 7. 确认测试：系统开发完后，需要验证是否和需求预期一致\n 8. 软件使用和维护：软件投入试运行，并不断对过程中出现的问题进行维护修正，软件维护郭晨会贯穿整个软件的使用郭晨直至软件自然消亡。\n\n\n# 2 软件开发模型\n计算机刚刚诞生的年代，是一种只有天才才能掌握的巩固，人们对软件知识的认知仅仅停留在程序层面。随着技术发展，软件复杂度的提高，意识到必须遵循一定的开发方法才能取得成功，于是出现了模式化的开发方法称为开发模型。\n\n## 2.1 瀑布模型\n特点：\n1. 软件过程要经过需求分析、总体设计、详细设计、编码、调试、集成测试和系统测试阶段，开发阶段划分明确\n2. 再每一个阶段结算后都有不定的文档或者程序流入下一个阶段\n3. 每个阶段在发现问题时可以反馈给上一个阶段进行修正\n适用场景：需求明确、稳定时\n\n### 2.1.1 瀑布V模型\n同标准瀑布模型一样，保持了瀑布模型的阶段式文档驱动的特点，但是更强调软件产品的验证工作，即需求分析的记过将作为系统测试的标准，能够在设计初期得到验证，以此类推，总体设计对应了集成测试，详细设计对应了单元测试。\n\n### 2.1.2 瀑布模型的缺点\n1. 需求分析是一切活动的基础，如果需求分析出现偏差，将导致后续活动放大这个偏差。但事实是，由于用户、开发者立场、经验不同、知识领域不同，对同一事物的表述不同造成的理解偏差难于避免，导致后期维护工作繁重\n2. 难于适应需求变化，一旦需求变更要重头再来\n3. 从需求提出到最后看到产品是一个相当长的过程，不能及时给用户反馈，并验证是否是能够满足客户需求的软件。\n4. 瀑布模型是面向文档的开发模型，过程中将产生大量文档，大部分对客户没有意义，但却工作量繁重\n\n## 2.2 演化模型\n演化模型是在瀑布模型难以一次性完全理解用户需求的基础上，对整个过程进行若干次的“瀑布模型”迭代，做到不断渐进、不断深入的过程\n\n## 2.3 螺旋模型\n螺旋模型是在瀑布模型和演化模型结合的基础上，还强调其他模型忽略的风险分析。\n特点：\n1. 螺旋模型对每一期都包含需求定义、风险分析、工程实现、和评审4个阶段，对整个过程进行螺旋式迭代\n2. 支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供方便，降低软件开发风险\n\n缺点：\n1. 螺旋模型的风险评估需要具有丰富风险评估经验和专业知识的人，否则将造成重大损失\n2. 过多的迭代次数会增加开发成本，延迟提交时间\n\n## 2.4 增量模型\n演化模型是另外一种增量模型的形式。在系统架构成熟、风险较低时，可采用增量方式进行系统开发，可提前进行基础测试和系统测试，缩短出事版本的发布周期，提高用户对系统的可见度。\n特点：\n1. 增量模型，做好系统的分析和设计，对系统划分为若干不同的版本，每一个版本都是完成可用的系统，后一个版本是前一个版本的基础进行开发，扩展前一个版本的功能，同时保证每个版本增量均匀。\n2. 原型法，每一次发布都经历完成的生命周期，当用户需求很多不明确或者技术架构中很多不可知因素时，可采用原型增量法。在初始版本的原型并不考虑需求的合理性和系统稳定性，只为精准获取用户需求，一般会在后面的开发中抛弃这个原型进行完成的系统实现。\n\n## 2.5 构件组装模型\n\n将系统划分为一组构件的集合，明确构件之间的关系。每个构件可以独立开发、自包容，可以是自己开发设计，也可以是第三方购买整合。最后进行构件组装的一个开发模型。\n构件组装优点：\n1. 构件自包容让系统扩展变得更加容易\n2. 良好的构件更容易重用，降低开发成本\n3. 构件力度较整个系统更小，更容易开发设计及安排工作更加灵活\n\n缺点：\n1. 对构件设计需要经验丰富的架构设计师，设计不良的构件难以实现他的优点\n2. 考虑重用度是，往往会对其他方面设计做出让步，比如性能\n3. 构件组装应用是，要求程序员熟悉掌握构件，增加了开发人员的学习成本\n4. 第三方构件质量难以把控，将影响软件的质量。\n\n# 3 统一过程模型\n统一过程（Unified Process, UP）是一种优秀的软件开发模型，可以有效地降低软件开发过程中的风险。这个开发模型的特点是每一个阶段的工作都不是绝对的，都是相互交叠配的的，但是每一个阶段都有侧重点。\n\n![](leanote://file/getImage?fileId=5eaa43af605ce63a32000003)\n\n整个过程大致分为\n1. 初始阶段，刚刚接入系统开发工作，侧重工作是明确系统目的，业务建模和需求工作\n2. 细化阶段，抽象软件逻辑模型，设计架构，侧重是分析设计工作\n3. 构件阶段，完成系统的构件，使之成为一个完整的实体，并进行测试和部署\n4. 交付阶段，软件系统需求已经完成，重点工作是对软件进行重构、修改、测试和部署\n\n整个工作内容整体包括：业务建模、需求、分析设计、实施、测试、部署、配置与变更管理、项目管理、环境。\n\n其中“环境”是相对于其他工作难以理解的。环境工作很重要，也称之为环境管理。在软件开发过程中，需要为各种工作准备相应的工作环境，在工作环境中包含必须的工具、活动指南、活动流程规范、工作产品模板、基本的开发设施等。环境管理应该在工作流中得到应有的重视，每个开发团队都有自己的特点和活动准则规范，这种准则和规范是团队协作的基础，万万不能少，否则开发活动就会使放养式的管理。\n\n** UP的生命周期**\n分为4个里程碑\n1. 目标里程碑。明确系统的目标和范围时达到这个里程\n2. 架构里程碑。当开发者确定稳定系统的架构时达到这个里程\n3. 能力里程碑。当系统已经足够稳定和成熟并完成了Alpha测试之后达到这个里程碑\n4. 发布里程碑。当完成系统的测试、完成系统的发布和用户培训工作之后达到这个里程碑\n\nUP的特点：\n1. UP是一个迭代的二维开发模型，每个生命后期都可以进行需求、设计、开发等\n2. 采用不同的迭代方式的UP可以演变为演化模型或增量模型\n3. UP的迭代特点使得更容易控制开发风险\n4. Up是迭代开发模型，但不属于敏捷开发模型。一般未经过裁剪的Up是一个重载过程\n5. 实际应用可根据具体问题进行UP的裁剪，从而使用各种规模的软件和开发团队\n\n架构师在UP活动中的作用\n架构师除了需要建立系统的架构模型外，在UP活动中承担非常重要的角色，例如：\n1. 同需求人员和项目管理人员密切协作\n2. 细化软件架构\n3. 保持整个架构的概念完整性，具体地说就是定义设计方法、设计指南、编码规范、平舌工作\n**因此有人称UP是一个已加购书为中心的开发模型。**\n\n# 4 敏捷开发方法\n2001年，17位“无政府主义者”共同发表了《敏捷软件开发宣言》：\n> 1. 尽早地、持续地向客户交付有价值的软件对开发人员来说是最重要的。\n2. 拥抱变化，即使在开发的后期。敏捷过程能够驾驭变化，保持客户的竞争力。\n3. 经常交付可工作的软件，从几周到几个月，时间范围越小越好。\n4. 在整个项目中，业务人员和开发者紧密合作。\n5. 围绕士气高昂的团队进行开发，为团队成员提供适宜的环境，满足他们的需要，并给予\n足够的信任。\n6. 在团队中，最有效率的、也是效果最好的沟通方式是面对面地交流。\n7. 可以工作的软件是进度首要的度量方式。\n8. 可持续地开发。投资人、开发团队和用户应该保持固定的节奏。\n9. 不断追求优秀的技术和良好的设计有助于提高敏捷性。\n10. 要简单，尽可能减少工作量。减少工作量的艺术是非常重要的。\n11. 最好的架构、需求和设计都来自于一个自我组织的团队。\n12. 团队要定期地总结如何能够更有效率，然后相应地自我调整\n\n这份宣言就是敏捷开发方法的灯塔\n\n## 4.1 敏捷开发方法实践之极限编程（eXtreme Programming）\n极限编程（XP）是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方法。特点如下：\n1. 在更短的周期内，更早地提供具体、持续的反馈信息。\n2. 迭代地进行计划编制。在最开始迅速形成总体计划，然后开发过程中不断迭代发展它\n3. 依赖自动化测试程序来监控开发进度，尽早地铺货缺陷\n4. 依赖口头交流、测试和源程序进行沟通\n5. 倡导持续的、演化式的设计\n6. 依赖于开发团队内部的紧密协作\n7. 尽可能达到程序员的短期利益和长期利益的平衡。即关注短期程序员的自主设计和参与感，同时帮助程序员长期的成长\n\n四大价值观：沟通、简单、反馈、勇气\n1. 沟通。通常，程序员相对内向，不善言谈，项目中的许多问题都发生在缺乏良好的沟通上。而传统的开发方法中并不太在意这种口头的沟通，而是希望通过完善的流程和面面俱到的文档、报表、计划来代替，这同时就引入了效率不高的问题，往往一个小问题通过漫长的流程下来被放大。而XP方法认为，如果小组内成员无法做到持续的、无间断的交流，协作就无从谈起，XP鼓励大家进行口头的面对面交流快速解决问题，提高效率。\n2. 简单。XP方法的工作中秉承“够用即好”，实现尽可能简单化，不要过度设计。这一点看上去容易，但要做到其实很淡，因为在传统的开发过程中需要开发人员对未来做一些预先的规划，以便后续做扩展预留空间，这是一个平衡的过程，并不是一点都不考虑未来的可扩展性，所以比较难做到\n3. 反馈。传统的开发过程中缺乏对客户必要的反馈，整个开发过程像一个“黑盒子”，过程漫长，完全看不到效果和进度。容易造成最终偏离用户需求的系统软件。XP注重反馈的作用，通过持续的、明确的反馈来暴露软件当前的状态和问题，尽早地纠正一些可以避免的错误。\n4. 勇气。在XP方法中，要有勇气面对每时每刻的变化带来的挑战。由于提倡良好的沟通，会有更多的需求调整；由于提倡系统保持简单，需求变更导致的重构；由于提倡尽早反馈，更多地发现问题并纠正。而面对这些带来的挑战，我们更需要为之提高勇气。因为相比于沟通、简单和反馈带来的挑战，更多的我们是得到了良好的信息同步，尽早地发现了问题，更清晰地理解了用户需求，以及更简单地实现了系统软件。\n\nXP的四大价值观之下，隐藏着一种更深刻的东西，那就是尊重，对人的尊重。因为这一切都是建立在团队成员之间的相互关系、相互理解的基础之上。\n\n### 4.1.1 极限编程的十二个最佳实践\n\n 1. 计划游戏。主要思想是先快速制定一份概要计划，然后随着项目细节的不断清醒，在逐步完善这份计划。“客户负责业务决策，开发负责计算决策”，也就是说系统的范围、下一次迭代发布的时间、用户股市的优先级应有客户决定，而每个用户故事所需的而开发时间、技术成本、如何组件团队、以及开发顺序应有开发团队决定。\n    > 计划游戏开始，客户和开发同坐一屋子，每个人准备一支笔、一些用于记录用户需求的纸片，再准备一个白板就可以开始了。\n    > 1. 客户编写需求故事：由客户谈论系统应该完成什么功能，然后用自然语言词汇写在卡片上\n    > 2. 开发人员进行评估：有客户按优先级将故事需求标注为必须有、希望有、如果有三类，然后又开发人进行估算，优先级由高到低。如果估算的时候感到故事需求太大，不容易估算或者超过2人/周，那么应该进行分解在进行评估\n    > 3. 确定迭代周期：根据用户期望的需求优先级、期望发布的时间结合开发现有资源与用户协商，筛检出能够实现的需求，形成初步的需求计划。\n\n 2. 小型发布。XP方法秉承“持续集成，小步快走”的哲学思维，也就是说每次发布的版本尽可能肖，当然前提是每个版本都有发布的商业价值，值得发布。\n 3. 隐喻。相对而言，隐喻这个令人费解，什么时隐喻呢，字面意思是用来暗示字面意义不相似的事物之间相似的东西。对应到开发过程中就是，需要寻求共识，对系统理解、目标价值以等；还有就是发明共享词汇，通过规范项目中常用通用的业务专有名词，减少不必要的沟通；描述体系结构；并不是每一种情况都能找到合适的隐喻，没必要强求，而是顺其自然。\n 4. 简单设计。强调简单的价值观，引出简单性假设原则。这里说的简单设计并不是忽略设计而是设计不应该一次完成，因为随着业务的变化，可能当时设想的可预知的未来根本就是不存在的，留有适当的扩展设计并满足现有需求的简单设计原则。\n 5. 测试先行。是指注重测试用例程序的编写，不能因为没有时间，工作紧张为由忽略测试工作，这样就会由于没有良好的测试用例而化大把的时间在后续的联调维护阶段，实际上这个整体上市大大降低产能、效率埂底下的做法。\n 6. 重构。重构是一种对待吗进行重写而不影响功能实现的的技术，XP要求在开发人员“问到代码的坏味道”时，就有重构代码的勇气。重构的目的是让代码降低因变化引起的风险、使得代码更加易于维护和阅读。\n 7. 结对编程。一开始虽然会牺牲一些速度，但慢慢的，开发速度会逐步加快，究其原因是结对编程大大降低了沟通成本，提高了工作的质量，具体表现在：\n    1. 所有的设计决策确保不是一个人做出来的\n    2. 系统的任何部分至少有2个人以上熟悉\n    3. 不能能同时2个人都忽略测试项\n    4. 阶段的动态性，是一个去也知识管理的好途径\n    5. 代码总是能够保证评审通过\n    6. XP方法集成的吉他最佳实践能够是的结对编程更加容易进行\n    7. 编码标准能够消除一些无谓的分歧\n    8. 隐喻可以帮助结对伙伴更好沟通\n    9. 简单设计能够是的伙伴更了解他们所从事的工作\n    \n    结对编程技术被誉为XP保持工作质量、强调人文主义的一个典型实践，能够是的开发团队之间的协作更加流畅、知识交流更加频繁、团队更加稳定。\n\n\n 8. 集体代码所有制。有XP方法鼓励团队进行结对编程，而且编程组是动态搭配的，每个人会遇到不同的代码，代码所有制就不是局限于某一个人，而是集体所有制，团队中的每个人都有进行修改的权利，每个人都拥有全部代码，也都需要对全部代码负责。同时XP强调代码是谁该坏的就应该有谁来修复。\n 9. 持续集成。持续集成是最佳实践的基本支撑条件。\n 10. 每周工作40小时。这是一个让开发者开心、管理者反对的一个最佳实践。加班早已成为开发人员的家常便饭，也是管理者最常用的一种策略。而XP方法认为，加班会扼杀团队的积极性，最终导致项目失败，这也体现了XP方法是关注人的因素比关注过程的因素更多一些。这里说的40小时不是绝对的额，是指根据团队公司合理的工作时长。提倡追求有效的、高效的工作时间，而不是绝对的时长。\n 11. 现场客户。为了保证开发出来的结果与客户的预想接近，XP方法认为最重要的是将客户请到现场，保持和客户的现场沟通，并让客户参与到开发决策中来。\n 12. 编码标准。拥有编码标准可以避免团队无关细节的争论。不过这个标准不是越细越好，而是要能够确保代码清晰，便于交流的一个指导方针。\n\nXP方法最大价值在于项目中融会贯通地运用这12个最佳实践，而非单独使用。当然可以使用其中一些实践，单并不意味这就应用了XP方法。\n\n## 4.2 特征驱动开发方法\nFDD也是一个迭代的开发模型。FDD每一步都强调质量，不断地交付可运行的软件，并以很小的开发提供准确的项目进度报告和状态信息。同敏捷开发一样，FDD弱化了过程在软件开发的地位。\n### 4.2.1 FDD的角色定义\nFDD认为，有效的软件开发不可或缺的三个要素是：人、过程和技术。软件开发不能没有过程，也不能没有技术，但最重要的还是人。定义了6中关键角色：\n1. 项目经理。项目开发的组织者，是团队的保护屏障，提供一个适宜的开发环境。\n2. 首席架构设计师。负责系统的架构设计\n3. 开发经理。负责团队日常的开发工作的安排，解决开发过程中的技术问题和资源冲突\n4. 主程序员。主程序员将带领小组完成特征的详细设计和构件工作，一般要求主程序员具有一定的工作经验，并能够带动小组工作。\n5. 程序员。若干个程序员在主程序员带领下完成小组的开发，按照特征开发疾患完成开发\n6. 领域专家。领域专家是指对业务精通的人，一般有客户、系统分析师担当。\n\n### 4.2.2 FDD的最佳实践\nFDD最佳实践包括：领域对象建模、根据特征进行开发、类的个体所有、组成特征小组、审查、定期构造、配置管理、结果的可见性\n其中最有特色的是个体所有，激活所有的而开发模型都是代码共有。但在FDD中，将类分配给特定的任何小组，分配给A小组的代码只能由A来维护，除A外的角色都不能修改它，只能使用它。\n优点是：\n1. 这个类的支配感会促使开发人员产生自豪感，从而更出色地完成任务。不过FDD也提到了类q\n2. 审查也是FDD中很具特设的一项实践。不少人认为审查是非常严格的软件过程特有的，然而FDD中明确将审查作为一项最佳实践。审查是一种很有效的发现缺陷的手段，但经常被忽视，国内的软件组织中很少有严格的审查制度保障软件质量。在开发阶段的代码审查机制能够很好的避免潜在的问题。\n\n缺点：\n1. 项目依赖关系增强，形成代码黑盒，除了负责人没人能修改。\n\n\n## 4.3 Scrum\nScrum是一个用于开发和维护复杂产品框架，是一个增量的、迭代的开发过程。由若干个迭代周期组成，一个短的迭代周期成为Sprint,每个Sprint的建议周期在2到4周。在Scrum中，使用产品的Backlog来管理产品的需求，产品Backlog是一个按商业价值拍下的需求列表。\nScrum团队重产品的Backlog中挑选优先级最高的需求进行开发。\n挑选的需求在sprint的计划会议上进行讨论、分析和估算得到相应的任务列表，称之为Sprint backlog.\n\n### 4.3.1 Scrum的5个活动\n![](leanote://file/getImage?fileId=5ea94009605ce63a32000000)\n1. 产品待办事项的梳理——Prodct Backlog. 产品待办事项通常会很多，也很宽泛，而且想法会变来变去、优先级也会变化，所以产品待办事项列表的梳理是一个贯穿整个Scrum项目的活动。梳理包括：整理需求、优先级排序、事项分解、归并以及商业价值分析等。待办事项的梳理最好是所有团队成员参与，因为有可能需要其他技术或者团队的参与，而不是单单产品经理。\n2. Sprint计划会议。每个Sprint工作周期以Sprint计划会议作为开始，让团队共同选择和理解即将到来的Sprint工作事项. Sprint计划会议的成功十分依赖产品待办事项列表的质量。Sprint计划会议工作内容有两部分：\n    1. 需要完成那些工作：产品负责人介绍排好序的代办事项，让整个Scrum团队共同理解这些工作。而产品待办事项的数目完全有开发团队决定，开发团队要考虑当天产品的增量状态，团队过去的工作情况，当前生产力等，产品负责人不能强加更多的工作量。\n    2. 如何完成工作：开发团队根据当前的“完成的定义”一起决定如何实现一个产品增量，进行任务分解，前几天的工作分解成小单元，每个单元不超过一天，之后的任务可以稍微大一些，以后再对它进行分解。总之产品和开发团队一起考虑斌讨论产品待办事项，确保每个人对事项的理解一致，最终产出待办事项列表就是“Sprint 待办事项列表”，称之为Sprint Backlog\n\n3. 每日Scrum会议。开发团队自组织，通过每日Scrum会议来确认他们任然可以实现Sprint的目标，每个人说下三点内容：上一个工作日完成了什么、当前工作日计划完成什么、有什么阻碍或风险。一般不超过15分钟。\n4. Sprint评审会议。一个Sprint周期结束时，Scrum团队和相关人员一起评审Sprint的产出，Sprint评审会议向每个人展示当前的产品增量情况，帮助大家了解我们目前的进度到哪里，讨论他们在Sprint过程中看到了什么、有什么想法，并一起探讨下一步如何更好的推进。\n5. Sprint回顾会议。每个Sprint周期结束之后，Scrum团队开回顾会议，目的是回顾一下团队在流程人际关系及工作方面做得如何，识别出团队中做得好的与不好的，并找潜在可以改进的事项，为将来的Sprint提供改进的计划\n\n### 4.3.2 Scrum的5大价值观\n1. 承若——愿意对目标负责\n2. 专注——把你的心思和能力都用到你承诺的工作上去\n3. 开放——Scrum把项目中的一切开放给每个人看，做到信息透明\n4. 尊重——每个人都有他独特的背景和经验，尊重每个人的特点\n5. 勇气——有勇气做出承诺，履行程度，接受别人的尊重\n   \n## 4.4 水晶方法\n水晶方法有七大体系特征：\n1. 经常交付。没过一段时间或者几个月向用户交付可测试运行的代码，让用户有机会发现原来需求是否是他真正想要的，有机会将结果反馈到开发中。\n2. 反思改进。开发过程中难免会遇到一些技术难题、各种烦心事，会影响项目进度，所以我们应该经常在迭代中及时地进行反思和改进，从慌乱的日常开发中，抽一点时间来思考更为行之有效的方法。\n3. 渗透式交流。渗透式交流就是信息交流在团队成员中形成背景听觉，使得成员就像通过渗透一样获取相关信息。团队通过在一个共同的工作空间内，若其中一个成员提出问题，其他成员可以选择关注或不关注，也可以随时加入到讨论中来，选择性地获取相关交流的信息。\n4. 个人安全。当你勇敢指出了困扰你的问题时，你可以不用担心受到报复，应该有保护机制，鼓励大家发现和改正自身的缺点，而不是知而不言，这样就会对团队造成损害，不利于整个团队的协作和稳定。\n5. 焦点。也叫聚焦，明确知道要做什么，然后再安排时间，确保团队成员都清楚地了解他们自己最重要的任务是什么，确保他们能够充分利用时间去完成这些任务。\n6. 与专家用户简历方便的联系。与专家用户简历方便的联系能够给团队提供很好的帮助，例如对业务的专业理解，成品的质量和快速罚款，设计理念和需求背景，用户最新的需求等。\n7. 自动化测试。自动化测试是在开发在修改代码之后能够进行自动化测试，以便发现一些bug，让开发能够及时地进行修复，节省了整体的开发时间，提高效率。\n\n## 4.5 其他敏捷方法——开放式源码\n开放式源码——是指以开放源码的方式运作，特别的就是开发人员可能地域分布很广，这和其他的敏捷方法不同，开放源码的一个好处就是排错的高度并行性，任何人都可以发现错误并修改代码提交给维护者。这里面体现的价值观就是猜测、合作和学习。\n\n# 5 软件重用\n\n软件产品和其他的产品不同，是抽象的，一旦产生就可以无限地复制，因此重复利用软件产品意义重大，可以节约大量的人力物力。软件重用包括：软件产品、源代码、文档、设计思想甚至领域知识。\n常见的重用形式：\n1. 源代码重用。这是简单最常见的重用形式，由于软件系统的复杂性，很难大规模地重用已有代码\n2. 架构重用。这个重用也很常见，随着软件架构风格和设计模式的推广和应用，架构重用已经对软件开发产生了重大影响\n3. 应用框架的重用。随着技术的发展，应用框架的重用变得越来越普遍，如AOP、EJB、Spring等应用框架技术\n4. 商业建模的重用。虽然软件领域各有不同，但是人们可以总结出常用的领域建模的方法，重用这些领域建模可以降低不确定性因素风险。\n5. 文档及过程的重用。有效地重用已有的文档有助于提高开发的效率\n6. 构件的重用。如第三方的组件，中间件等\n7. 软件服务的重用。随着web服务的提出，人们越来越关注服务的重用。例如SOA架构就是一个服务重用的实践，让一类功能收归到一个服务做不同业务软件的重用服务。\n\n# 6 基于架构的软件设计\n基于架构的软件设计（Architecture-Based Software Design,ABSD）是一种架构驱动的设计方法，这种方法有3个基础：\n1. 功能分解。在功能分解中，ABSD方法使用已有的基于模块内聚和耦合技术\n2. 通过选择架构风格来实现质量和业务需求\n3. 软件模板的使用。软件模板利用了一些软件系统的结构。\n\nABSB模型是吧整个过程划分为：架构需求、设计、文档化、复审、实现和演化\n\n## 6.1 ABSB方法与生命周期\n![](leanote://file/getImage?fileId=5ea97d8a605ce63a32000001)\n\n## 6.2 基于架构的软件开发模型\n基于架构的软件开发模型（Architecture-Based Software Design Model，ABSDM）把整个基于架构的软件过程划分为架构需求、架构设计、架构文档化、架构复审、架构实现和架构演化6个子过程：\n![](leanote://file/getImage?fileId=5eaa3c4f605ce63a32000002)\n\n1. 机构需求。是指用户对目标软件在系统功能、行为、性能、设计约束方面的期望。通过用户的需求，架构师根据技术环境和架构师经验标注出所需要的构件，最后进行需求的评审。必要时“需求获取——标识构件——需求评审”之间进行迭代。\n2. 架构设计。根据架构需求提出架构的模型、映射构件、分析构件相互作用、产生架构、设计评审\n3. 架构文档化。绝大多数架构都是抽象的，有一些概念的构件组成。为了开发人员更好地理解和实现架构，必须把架构进行文档化描述\n3. 架构复审。架构设计完成之后要安排一次由外部人员（用户和领域专家）参与的复审，其目的是识别潜在的风险，及早发现架构设计中的缺陷和错误，包括架构能否满足需求、质量需求是否得到体现、是否清晰、构件是否划分合理、文档标识是否明确、以及构架设计是否满足功能和性能要求等等\n4. 架构实现。开发人员根据复审后的架构文档，分析和实现其中的构件，然后组装测试的一个过程。\n5. 架构演化。在架构开发中，用户的需求可能变动，在开发完成正常运行后，也可能发生需求变化。那么就要相应地调整架构以适应新的软件需求。主要过程包括这7个步骤：需求变动归类、架构演化计划、构件变动、更新构件的相互作用关系、构件组装和测试、技术评审、技术评审，最后得出演化后的架构设计。\n\n# 7 形式化方法\n形式化方法是指采用严格的数据方法对软件的描述、开发和验证的过程进行严格规约的一种方法，通过这种方式可以需求和定义人员与开发人员的理解偏差，避免模糊性和二义性。通过形式化描述进行需求分析的质量大大提高，很多自然语言描述无法避免的缺陷在需求分析阶段就会被发现并等到解决，从而降低了后期的开发和维护的成本。形式化描述可以通过计算计算进行自动处理（一些专业软件），进行一致性检查和证明。\n一般一些安全要求较高的，如地铁、高铁、航空、核电等软件会考虑使用这种开发方法来保证系统的安全和可靠性。\n\n","source":"_posts/软件开发方法.md","raw":"---\ntitle: 系统架构师——软件开发方法\ndate: 2020-4-30 11:25:00\nauthor: okeeper\ntop: true\ntoc: true\nsummary: 软件开发方法是软件开发的方法学，旨在提供软件的质量，降低开发成本\ncategories: 架构\ntags:\n  - 架构\n---\n\n> 前言：软件开发方法是软件开发的方法学，旨在提供软件的质量，降低开发成本\n\n# 1 软件生命周期\n\n 1. 可行性研究和规划：通过可行性分析确认原件的必要性，价值点，初步确认软件的目标、范围、风险和开发成本等内容。\n 2. 需求分析：需求分析是开发过程的重要阶段，初步确认软件开发的目标和范围，之后则要对软件的需求进行细致分析，确认最终要做成什么样子。这个过程极其重要，如果这个阶段出现分析错误和偏差将导致后续开发过程偏离真实需求越远，修正的成本越大。\n 3. 概要设计：是程序员开发过程中的蓝图，包括确认系统架构、各个子系统依赖关系、数据库模型、编码规范、接口规约等内容\n 4. 详细设计：详细设计师开发之前的最后设计，是在概要设计的基础上进行进行细化，如类设计。详细设计不是必要过程，在规模较小，功能结构简单的系统中可以省略。\n 5. 实现：针对设计的单元模块进行开发，如一个过程、方法、函数，包括实现单元模块的单元测试\n 6. 集成测试：对单元模块进行组装联调测试\n 7. 确认测试：系统开发完后，需要验证是否和需求预期一致\n 8. 软件使用和维护：软件投入试运行，并不断对过程中出现的问题进行维护修正，软件维护郭晨会贯穿整个软件的使用郭晨直至软件自然消亡。\n\n\n# 2 软件开发模型\n计算机刚刚诞生的年代，是一种只有天才才能掌握的巩固，人们对软件知识的认知仅仅停留在程序层面。随着技术发展，软件复杂度的提高，意识到必须遵循一定的开发方法才能取得成功，于是出现了模式化的开发方法称为开发模型。\n\n## 2.1 瀑布模型\n特点：\n1. 软件过程要经过需求分析、总体设计、详细设计、编码、调试、集成测试和系统测试阶段，开发阶段划分明确\n2. 再每一个阶段结算后都有不定的文档或者程序流入下一个阶段\n3. 每个阶段在发现问题时可以反馈给上一个阶段进行修正\n适用场景：需求明确、稳定时\n\n### 2.1.1 瀑布V模型\n同标准瀑布模型一样，保持了瀑布模型的阶段式文档驱动的特点，但是更强调软件产品的验证工作，即需求分析的记过将作为系统测试的标准，能够在设计初期得到验证，以此类推，总体设计对应了集成测试，详细设计对应了单元测试。\n\n### 2.1.2 瀑布模型的缺点\n1. 需求分析是一切活动的基础，如果需求分析出现偏差，将导致后续活动放大这个偏差。但事实是，由于用户、开发者立场、经验不同、知识领域不同，对同一事物的表述不同造成的理解偏差难于避免，导致后期维护工作繁重\n2. 难于适应需求变化，一旦需求变更要重头再来\n3. 从需求提出到最后看到产品是一个相当长的过程，不能及时给用户反馈，并验证是否是能够满足客户需求的软件。\n4. 瀑布模型是面向文档的开发模型，过程中将产生大量文档，大部分对客户没有意义，但却工作量繁重\n\n## 2.2 演化模型\n演化模型是在瀑布模型难以一次性完全理解用户需求的基础上，对整个过程进行若干次的“瀑布模型”迭代，做到不断渐进、不断深入的过程\n\n## 2.3 螺旋模型\n螺旋模型是在瀑布模型和演化模型结合的基础上，还强调其他模型忽略的风险分析。\n特点：\n1. 螺旋模型对每一期都包含需求定义、风险分析、工程实现、和评审4个阶段，对整个过程进行螺旋式迭代\n2. 支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供方便，降低软件开发风险\n\n缺点：\n1. 螺旋模型的风险评估需要具有丰富风险评估经验和专业知识的人，否则将造成重大损失\n2. 过多的迭代次数会增加开发成本，延迟提交时间\n\n## 2.4 增量模型\n演化模型是另外一种增量模型的形式。在系统架构成熟、风险较低时，可采用增量方式进行系统开发，可提前进行基础测试和系统测试，缩短出事版本的发布周期，提高用户对系统的可见度。\n特点：\n1. 增量模型，做好系统的分析和设计，对系统划分为若干不同的版本，每一个版本都是完成可用的系统，后一个版本是前一个版本的基础进行开发，扩展前一个版本的功能，同时保证每个版本增量均匀。\n2. 原型法，每一次发布都经历完成的生命周期，当用户需求很多不明确或者技术架构中很多不可知因素时，可采用原型增量法。在初始版本的原型并不考虑需求的合理性和系统稳定性，只为精准获取用户需求，一般会在后面的开发中抛弃这个原型进行完成的系统实现。\n\n## 2.5 构件组装模型\n\n将系统划分为一组构件的集合，明确构件之间的关系。每个构件可以独立开发、自包容，可以是自己开发设计，也可以是第三方购买整合。最后进行构件组装的一个开发模型。\n构件组装优点：\n1. 构件自包容让系统扩展变得更加容易\n2. 良好的构件更容易重用，降低开发成本\n3. 构件力度较整个系统更小，更容易开发设计及安排工作更加灵活\n\n缺点：\n1. 对构件设计需要经验丰富的架构设计师，设计不良的构件难以实现他的优点\n2. 考虑重用度是，往往会对其他方面设计做出让步，比如性能\n3. 构件组装应用是，要求程序员熟悉掌握构件，增加了开发人员的学习成本\n4. 第三方构件质量难以把控，将影响软件的质量。\n\n# 3 统一过程模型\n统一过程（Unified Process, UP）是一种优秀的软件开发模型，可以有效地降低软件开发过程中的风险。这个开发模型的特点是每一个阶段的工作都不是绝对的，都是相互交叠配的的，但是每一个阶段都有侧重点。\n\n![](leanote://file/getImage?fileId=5eaa43af605ce63a32000003)\n\n整个过程大致分为\n1. 初始阶段，刚刚接入系统开发工作，侧重工作是明确系统目的，业务建模和需求工作\n2. 细化阶段，抽象软件逻辑模型，设计架构，侧重是分析设计工作\n3. 构件阶段，完成系统的构件，使之成为一个完整的实体，并进行测试和部署\n4. 交付阶段，软件系统需求已经完成，重点工作是对软件进行重构、修改、测试和部署\n\n整个工作内容整体包括：业务建模、需求、分析设计、实施、测试、部署、配置与变更管理、项目管理、环境。\n\n其中“环境”是相对于其他工作难以理解的。环境工作很重要，也称之为环境管理。在软件开发过程中，需要为各种工作准备相应的工作环境，在工作环境中包含必须的工具、活动指南、活动流程规范、工作产品模板、基本的开发设施等。环境管理应该在工作流中得到应有的重视，每个开发团队都有自己的特点和活动准则规范，这种准则和规范是团队协作的基础，万万不能少，否则开发活动就会使放养式的管理。\n\n** UP的生命周期**\n分为4个里程碑\n1. 目标里程碑。明确系统的目标和范围时达到这个里程\n2. 架构里程碑。当开发者确定稳定系统的架构时达到这个里程\n3. 能力里程碑。当系统已经足够稳定和成熟并完成了Alpha测试之后达到这个里程碑\n4. 发布里程碑。当完成系统的测试、完成系统的发布和用户培训工作之后达到这个里程碑\n\nUP的特点：\n1. UP是一个迭代的二维开发模型，每个生命后期都可以进行需求、设计、开发等\n2. 采用不同的迭代方式的UP可以演变为演化模型或增量模型\n3. UP的迭代特点使得更容易控制开发风险\n4. Up是迭代开发模型，但不属于敏捷开发模型。一般未经过裁剪的Up是一个重载过程\n5. 实际应用可根据具体问题进行UP的裁剪，从而使用各种规模的软件和开发团队\n\n架构师在UP活动中的作用\n架构师除了需要建立系统的架构模型外，在UP活动中承担非常重要的角色，例如：\n1. 同需求人员和项目管理人员密切协作\n2. 细化软件架构\n3. 保持整个架构的概念完整性，具体地说就是定义设计方法、设计指南、编码规范、平舌工作\n**因此有人称UP是一个已加购书为中心的开发模型。**\n\n# 4 敏捷开发方法\n2001年，17位“无政府主义者”共同发表了《敏捷软件开发宣言》：\n> 1. 尽早地、持续地向客户交付有价值的软件对开发人员来说是最重要的。\n2. 拥抱变化，即使在开发的后期。敏捷过程能够驾驭变化，保持客户的竞争力。\n3. 经常交付可工作的软件，从几周到几个月，时间范围越小越好。\n4. 在整个项目中，业务人员和开发者紧密合作。\n5. 围绕士气高昂的团队进行开发，为团队成员提供适宜的环境，满足他们的需要，并给予\n足够的信任。\n6. 在团队中，最有效率的、也是效果最好的沟通方式是面对面地交流。\n7. 可以工作的软件是进度首要的度量方式。\n8. 可持续地开发。投资人、开发团队和用户应该保持固定的节奏。\n9. 不断追求优秀的技术和良好的设计有助于提高敏捷性。\n10. 要简单，尽可能减少工作量。减少工作量的艺术是非常重要的。\n11. 最好的架构、需求和设计都来自于一个自我组织的团队。\n12. 团队要定期地总结如何能够更有效率，然后相应地自我调整\n\n这份宣言就是敏捷开发方法的灯塔\n\n## 4.1 敏捷开发方法实践之极限编程（eXtreme Programming）\n极限编程（XP）是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方法。特点如下：\n1. 在更短的周期内，更早地提供具体、持续的反馈信息。\n2. 迭代地进行计划编制。在最开始迅速形成总体计划，然后开发过程中不断迭代发展它\n3. 依赖自动化测试程序来监控开发进度，尽早地铺货缺陷\n4. 依赖口头交流、测试和源程序进行沟通\n5. 倡导持续的、演化式的设计\n6. 依赖于开发团队内部的紧密协作\n7. 尽可能达到程序员的短期利益和长期利益的平衡。即关注短期程序员的自主设计和参与感，同时帮助程序员长期的成长\n\n四大价值观：沟通、简单、反馈、勇气\n1. 沟通。通常，程序员相对内向，不善言谈，项目中的许多问题都发生在缺乏良好的沟通上。而传统的开发方法中并不太在意这种口头的沟通，而是希望通过完善的流程和面面俱到的文档、报表、计划来代替，这同时就引入了效率不高的问题，往往一个小问题通过漫长的流程下来被放大。而XP方法认为，如果小组内成员无法做到持续的、无间断的交流，协作就无从谈起，XP鼓励大家进行口头的面对面交流快速解决问题，提高效率。\n2. 简单。XP方法的工作中秉承“够用即好”，实现尽可能简单化，不要过度设计。这一点看上去容易，但要做到其实很淡，因为在传统的开发过程中需要开发人员对未来做一些预先的规划，以便后续做扩展预留空间，这是一个平衡的过程，并不是一点都不考虑未来的可扩展性，所以比较难做到\n3. 反馈。传统的开发过程中缺乏对客户必要的反馈，整个开发过程像一个“黑盒子”，过程漫长，完全看不到效果和进度。容易造成最终偏离用户需求的系统软件。XP注重反馈的作用，通过持续的、明确的反馈来暴露软件当前的状态和问题，尽早地纠正一些可以避免的错误。\n4. 勇气。在XP方法中，要有勇气面对每时每刻的变化带来的挑战。由于提倡良好的沟通，会有更多的需求调整；由于提倡系统保持简单，需求变更导致的重构；由于提倡尽早反馈，更多地发现问题并纠正。而面对这些带来的挑战，我们更需要为之提高勇气。因为相比于沟通、简单和反馈带来的挑战，更多的我们是得到了良好的信息同步，尽早地发现了问题，更清晰地理解了用户需求，以及更简单地实现了系统软件。\n\nXP的四大价值观之下，隐藏着一种更深刻的东西，那就是尊重，对人的尊重。因为这一切都是建立在团队成员之间的相互关系、相互理解的基础之上。\n\n### 4.1.1 极限编程的十二个最佳实践\n\n 1. 计划游戏。主要思想是先快速制定一份概要计划，然后随着项目细节的不断清醒，在逐步完善这份计划。“客户负责业务决策，开发负责计算决策”，也就是说系统的范围、下一次迭代发布的时间、用户股市的优先级应有客户决定，而每个用户故事所需的而开发时间、技术成本、如何组件团队、以及开发顺序应有开发团队决定。\n    > 计划游戏开始，客户和开发同坐一屋子，每个人准备一支笔、一些用于记录用户需求的纸片，再准备一个白板就可以开始了。\n    > 1. 客户编写需求故事：由客户谈论系统应该完成什么功能，然后用自然语言词汇写在卡片上\n    > 2. 开发人员进行评估：有客户按优先级将故事需求标注为必须有、希望有、如果有三类，然后又开发人进行估算，优先级由高到低。如果估算的时候感到故事需求太大，不容易估算或者超过2人/周，那么应该进行分解在进行评估\n    > 3. 确定迭代周期：根据用户期望的需求优先级、期望发布的时间结合开发现有资源与用户协商，筛检出能够实现的需求，形成初步的需求计划。\n\n 2. 小型发布。XP方法秉承“持续集成，小步快走”的哲学思维，也就是说每次发布的版本尽可能肖，当然前提是每个版本都有发布的商业价值，值得发布。\n 3. 隐喻。相对而言，隐喻这个令人费解，什么时隐喻呢，字面意思是用来暗示字面意义不相似的事物之间相似的东西。对应到开发过程中就是，需要寻求共识，对系统理解、目标价值以等；还有就是发明共享词汇，通过规范项目中常用通用的业务专有名词，减少不必要的沟通；描述体系结构；并不是每一种情况都能找到合适的隐喻，没必要强求，而是顺其自然。\n 4. 简单设计。强调简单的价值观，引出简单性假设原则。这里说的简单设计并不是忽略设计而是设计不应该一次完成，因为随着业务的变化，可能当时设想的可预知的未来根本就是不存在的，留有适当的扩展设计并满足现有需求的简单设计原则。\n 5. 测试先行。是指注重测试用例程序的编写，不能因为没有时间，工作紧张为由忽略测试工作，这样就会由于没有良好的测试用例而化大把的时间在后续的联调维护阶段，实际上这个整体上市大大降低产能、效率埂底下的做法。\n 6. 重构。重构是一种对待吗进行重写而不影响功能实现的的技术，XP要求在开发人员“问到代码的坏味道”时，就有重构代码的勇气。重构的目的是让代码降低因变化引起的风险、使得代码更加易于维护和阅读。\n 7. 结对编程。一开始虽然会牺牲一些速度，但慢慢的，开发速度会逐步加快，究其原因是结对编程大大降低了沟通成本，提高了工作的质量，具体表现在：\n    1. 所有的设计决策确保不是一个人做出来的\n    2. 系统的任何部分至少有2个人以上熟悉\n    3. 不能能同时2个人都忽略测试项\n    4. 阶段的动态性，是一个去也知识管理的好途径\n    5. 代码总是能够保证评审通过\n    6. XP方法集成的吉他最佳实践能够是的结对编程更加容易进行\n    7. 编码标准能够消除一些无谓的分歧\n    8. 隐喻可以帮助结对伙伴更好沟通\n    9. 简单设计能够是的伙伴更了解他们所从事的工作\n    \n    结对编程技术被誉为XP保持工作质量、强调人文主义的一个典型实践，能够是的开发团队之间的协作更加流畅、知识交流更加频繁、团队更加稳定。\n\n\n 8. 集体代码所有制。有XP方法鼓励团队进行结对编程，而且编程组是动态搭配的，每个人会遇到不同的代码，代码所有制就不是局限于某一个人，而是集体所有制，团队中的每个人都有进行修改的权利，每个人都拥有全部代码，也都需要对全部代码负责。同时XP强调代码是谁该坏的就应该有谁来修复。\n 9. 持续集成。持续集成是最佳实践的基本支撑条件。\n 10. 每周工作40小时。这是一个让开发者开心、管理者反对的一个最佳实践。加班早已成为开发人员的家常便饭，也是管理者最常用的一种策略。而XP方法认为，加班会扼杀团队的积极性，最终导致项目失败，这也体现了XP方法是关注人的因素比关注过程的因素更多一些。这里说的40小时不是绝对的额，是指根据团队公司合理的工作时长。提倡追求有效的、高效的工作时间，而不是绝对的时长。\n 11. 现场客户。为了保证开发出来的结果与客户的预想接近，XP方法认为最重要的是将客户请到现场，保持和客户的现场沟通，并让客户参与到开发决策中来。\n 12. 编码标准。拥有编码标准可以避免团队无关细节的争论。不过这个标准不是越细越好，而是要能够确保代码清晰，便于交流的一个指导方针。\n\nXP方法最大价值在于项目中融会贯通地运用这12个最佳实践，而非单独使用。当然可以使用其中一些实践，单并不意味这就应用了XP方法。\n\n## 4.2 特征驱动开发方法\nFDD也是一个迭代的开发模型。FDD每一步都强调质量，不断地交付可运行的软件，并以很小的开发提供准确的项目进度报告和状态信息。同敏捷开发一样，FDD弱化了过程在软件开发的地位。\n### 4.2.1 FDD的角色定义\nFDD认为，有效的软件开发不可或缺的三个要素是：人、过程和技术。软件开发不能没有过程，也不能没有技术，但最重要的还是人。定义了6中关键角色：\n1. 项目经理。项目开发的组织者，是团队的保护屏障，提供一个适宜的开发环境。\n2. 首席架构设计师。负责系统的架构设计\n3. 开发经理。负责团队日常的开发工作的安排，解决开发过程中的技术问题和资源冲突\n4. 主程序员。主程序员将带领小组完成特征的详细设计和构件工作，一般要求主程序员具有一定的工作经验，并能够带动小组工作。\n5. 程序员。若干个程序员在主程序员带领下完成小组的开发，按照特征开发疾患完成开发\n6. 领域专家。领域专家是指对业务精通的人，一般有客户、系统分析师担当。\n\n### 4.2.2 FDD的最佳实践\nFDD最佳实践包括：领域对象建模、根据特征进行开发、类的个体所有、组成特征小组、审查、定期构造、配置管理、结果的可见性\n其中最有特色的是个体所有，激活所有的而开发模型都是代码共有。但在FDD中，将类分配给特定的任何小组，分配给A小组的代码只能由A来维护，除A外的角色都不能修改它，只能使用它。\n优点是：\n1. 这个类的支配感会促使开发人员产生自豪感，从而更出色地完成任务。不过FDD也提到了类q\n2. 审查也是FDD中很具特设的一项实践。不少人认为审查是非常严格的软件过程特有的，然而FDD中明确将审查作为一项最佳实践。审查是一种很有效的发现缺陷的手段，但经常被忽视，国内的软件组织中很少有严格的审查制度保障软件质量。在开发阶段的代码审查机制能够很好的避免潜在的问题。\n\n缺点：\n1. 项目依赖关系增强，形成代码黑盒，除了负责人没人能修改。\n\n\n## 4.3 Scrum\nScrum是一个用于开发和维护复杂产品框架，是一个增量的、迭代的开发过程。由若干个迭代周期组成，一个短的迭代周期成为Sprint,每个Sprint的建议周期在2到4周。在Scrum中，使用产品的Backlog来管理产品的需求，产品Backlog是一个按商业价值拍下的需求列表。\nScrum团队重产品的Backlog中挑选优先级最高的需求进行开发。\n挑选的需求在sprint的计划会议上进行讨论、分析和估算得到相应的任务列表，称之为Sprint backlog.\n\n### 4.3.1 Scrum的5个活动\n![](leanote://file/getImage?fileId=5ea94009605ce63a32000000)\n1. 产品待办事项的梳理——Prodct Backlog. 产品待办事项通常会很多，也很宽泛，而且想法会变来变去、优先级也会变化，所以产品待办事项列表的梳理是一个贯穿整个Scrum项目的活动。梳理包括：整理需求、优先级排序、事项分解、归并以及商业价值分析等。待办事项的梳理最好是所有团队成员参与，因为有可能需要其他技术或者团队的参与，而不是单单产品经理。\n2. Sprint计划会议。每个Sprint工作周期以Sprint计划会议作为开始，让团队共同选择和理解即将到来的Sprint工作事项. Sprint计划会议的成功十分依赖产品待办事项列表的质量。Sprint计划会议工作内容有两部分：\n    1. 需要完成那些工作：产品负责人介绍排好序的代办事项，让整个Scrum团队共同理解这些工作。而产品待办事项的数目完全有开发团队决定，开发团队要考虑当天产品的增量状态，团队过去的工作情况，当前生产力等，产品负责人不能强加更多的工作量。\n    2. 如何完成工作：开发团队根据当前的“完成的定义”一起决定如何实现一个产品增量，进行任务分解，前几天的工作分解成小单元，每个单元不超过一天，之后的任务可以稍微大一些，以后再对它进行分解。总之产品和开发团队一起考虑斌讨论产品待办事项，确保每个人对事项的理解一致，最终产出待办事项列表就是“Sprint 待办事项列表”，称之为Sprint Backlog\n\n3. 每日Scrum会议。开发团队自组织，通过每日Scrum会议来确认他们任然可以实现Sprint的目标，每个人说下三点内容：上一个工作日完成了什么、当前工作日计划完成什么、有什么阻碍或风险。一般不超过15分钟。\n4. Sprint评审会议。一个Sprint周期结束时，Scrum团队和相关人员一起评审Sprint的产出，Sprint评审会议向每个人展示当前的产品增量情况，帮助大家了解我们目前的进度到哪里，讨论他们在Sprint过程中看到了什么、有什么想法，并一起探讨下一步如何更好的推进。\n5. Sprint回顾会议。每个Sprint周期结束之后，Scrum团队开回顾会议，目的是回顾一下团队在流程人际关系及工作方面做得如何，识别出团队中做得好的与不好的，并找潜在可以改进的事项，为将来的Sprint提供改进的计划\n\n### 4.3.2 Scrum的5大价值观\n1. 承若——愿意对目标负责\n2. 专注——把你的心思和能力都用到你承诺的工作上去\n3. 开放——Scrum把项目中的一切开放给每个人看，做到信息透明\n4. 尊重——每个人都有他独特的背景和经验，尊重每个人的特点\n5. 勇气——有勇气做出承诺，履行程度，接受别人的尊重\n   \n## 4.4 水晶方法\n水晶方法有七大体系特征：\n1. 经常交付。没过一段时间或者几个月向用户交付可测试运行的代码，让用户有机会发现原来需求是否是他真正想要的，有机会将结果反馈到开发中。\n2. 反思改进。开发过程中难免会遇到一些技术难题、各种烦心事，会影响项目进度，所以我们应该经常在迭代中及时地进行反思和改进，从慌乱的日常开发中，抽一点时间来思考更为行之有效的方法。\n3. 渗透式交流。渗透式交流就是信息交流在团队成员中形成背景听觉，使得成员就像通过渗透一样获取相关信息。团队通过在一个共同的工作空间内，若其中一个成员提出问题，其他成员可以选择关注或不关注，也可以随时加入到讨论中来，选择性地获取相关交流的信息。\n4. 个人安全。当你勇敢指出了困扰你的问题时，你可以不用担心受到报复，应该有保护机制，鼓励大家发现和改正自身的缺点，而不是知而不言，这样就会对团队造成损害，不利于整个团队的协作和稳定。\n5. 焦点。也叫聚焦，明确知道要做什么，然后再安排时间，确保团队成员都清楚地了解他们自己最重要的任务是什么，确保他们能够充分利用时间去完成这些任务。\n6. 与专家用户简历方便的联系。与专家用户简历方便的联系能够给团队提供很好的帮助，例如对业务的专业理解，成品的质量和快速罚款，设计理念和需求背景，用户最新的需求等。\n7. 自动化测试。自动化测试是在开发在修改代码之后能够进行自动化测试，以便发现一些bug，让开发能够及时地进行修复，节省了整体的开发时间，提高效率。\n\n## 4.5 其他敏捷方法——开放式源码\n开放式源码——是指以开放源码的方式运作，特别的就是开发人员可能地域分布很广，这和其他的敏捷方法不同，开放源码的一个好处就是排错的高度并行性，任何人都可以发现错误并修改代码提交给维护者。这里面体现的价值观就是猜测、合作和学习。\n\n# 5 软件重用\n\n软件产品和其他的产品不同，是抽象的，一旦产生就可以无限地复制，因此重复利用软件产品意义重大，可以节约大量的人力物力。软件重用包括：软件产品、源代码、文档、设计思想甚至领域知识。\n常见的重用形式：\n1. 源代码重用。这是简单最常见的重用形式，由于软件系统的复杂性，很难大规模地重用已有代码\n2. 架构重用。这个重用也很常见，随着软件架构风格和设计模式的推广和应用，架构重用已经对软件开发产生了重大影响\n3. 应用框架的重用。随着技术的发展，应用框架的重用变得越来越普遍，如AOP、EJB、Spring等应用框架技术\n4. 商业建模的重用。虽然软件领域各有不同，但是人们可以总结出常用的领域建模的方法，重用这些领域建模可以降低不确定性因素风险。\n5. 文档及过程的重用。有效地重用已有的文档有助于提高开发的效率\n6. 构件的重用。如第三方的组件，中间件等\n7. 软件服务的重用。随着web服务的提出，人们越来越关注服务的重用。例如SOA架构就是一个服务重用的实践，让一类功能收归到一个服务做不同业务软件的重用服务。\n\n# 6 基于架构的软件设计\n基于架构的软件设计（Architecture-Based Software Design,ABSD）是一种架构驱动的设计方法，这种方法有3个基础：\n1. 功能分解。在功能分解中，ABSD方法使用已有的基于模块内聚和耦合技术\n2. 通过选择架构风格来实现质量和业务需求\n3. 软件模板的使用。软件模板利用了一些软件系统的结构。\n\nABSB模型是吧整个过程划分为：架构需求、设计、文档化、复审、实现和演化\n\n## 6.1 ABSB方法与生命周期\n![](leanote://file/getImage?fileId=5ea97d8a605ce63a32000001)\n\n## 6.2 基于架构的软件开发模型\n基于架构的软件开发模型（Architecture-Based Software Design Model，ABSDM）把整个基于架构的软件过程划分为架构需求、架构设计、架构文档化、架构复审、架构实现和架构演化6个子过程：\n![](leanote://file/getImage?fileId=5eaa3c4f605ce63a32000002)\n\n1. 机构需求。是指用户对目标软件在系统功能、行为、性能、设计约束方面的期望。通过用户的需求，架构师根据技术环境和架构师经验标注出所需要的构件，最后进行需求的评审。必要时“需求获取——标识构件——需求评审”之间进行迭代。\n2. 架构设计。根据架构需求提出架构的模型、映射构件、分析构件相互作用、产生架构、设计评审\n3. 架构文档化。绝大多数架构都是抽象的，有一些概念的构件组成。为了开发人员更好地理解和实现架构，必须把架构进行文档化描述\n3. 架构复审。架构设计完成之后要安排一次由外部人员（用户和领域专家）参与的复审，其目的是识别潜在的风险，及早发现架构设计中的缺陷和错误，包括架构能否满足需求、质量需求是否得到体现、是否清晰、构件是否划分合理、文档标识是否明确、以及构架设计是否满足功能和性能要求等等\n4. 架构实现。开发人员根据复审后的架构文档，分析和实现其中的构件，然后组装测试的一个过程。\n5. 架构演化。在架构开发中，用户的需求可能变动，在开发完成正常运行后，也可能发生需求变化。那么就要相应地调整架构以适应新的软件需求。主要过程包括这7个步骤：需求变动归类、架构演化计划、构件变动、更新构件的相互作用关系、构件组装和测试、技术评审、技术评审，最后得出演化后的架构设计。\n\n# 7 形式化方法\n形式化方法是指采用严格的数据方法对软件的描述、开发和验证的过程进行严格规约的一种方法，通过这种方式可以需求和定义人员与开发人员的理解偏差，避免模糊性和二义性。通过形式化描述进行需求分析的质量大大提高，很多自然语言描述无法避免的缺陷在需求分析阶段就会被发现并等到解决，从而降低了后期的开发和维护的成本。形式化描述可以通过计算计算进行自动处理（一些专业软件），进行一致性检查和证明。\n一般一些安全要求较高的，如地铁、高铁、航空、核电等软件会考虑使用这种开发方法来保证系统的安全和可靠性。\n\n","slug":"软件开发方法","published":1,"updated":"2022-08-24T03:51:05.113Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczg40008vwm1cai924gj","content":"<blockquote>\n<p>前言：软件开发方法是软件开发的方法学，旨在提供软件的质量，降低开发成本</p>\n</blockquote>\n<h1 id=\"1-软件生命周期\"><a href=\"#1-软件生命周期\" class=\"headerlink\" title=\"1 软件生命周期\"></a>1 软件生命周期</h1><ol>\n<li>可行性研究和规划：通过可行性分析确认原件的必要性，价值点，初步确认软件的目标、范围、风险和开发成本等内容。</li>\n<li>需求分析：需求分析是开发过程的重要阶段，初步确认软件开发的目标和范围，之后则要对软件的需求进行细致分析，确认最终要做成什么样子。这个过程极其重要，如果这个阶段出现分析错误和偏差将导致后续开发过程偏离真实需求越远，修正的成本越大。</li>\n<li>概要设计：是程序员开发过程中的蓝图，包括确认系统架构、各个子系统依赖关系、数据库模型、编码规范、接口规约等内容</li>\n<li>详细设计：详细设计师开发之前的最后设计，是在概要设计的基础上进行进行细化，如类设计。详细设计不是必要过程，在规模较小，功能结构简单的系统中可以省略。</li>\n<li>实现：针对设计的单元模块进行开发，如一个过程、方法、函数，包括实现单元模块的单元测试</li>\n<li>集成测试：对单元模块进行组装联调测试</li>\n<li>确认测试：系统开发完后，需要验证是否和需求预期一致</li>\n<li>软件使用和维护：软件投入试运行，并不断对过程中出现的问题进行维护修正，软件维护郭晨会贯穿整个软件的使用郭晨直至软件自然消亡。</li>\n</ol>\n<h1 id=\"2-软件开发模型\"><a href=\"#2-软件开发模型\" class=\"headerlink\" title=\"2 软件开发模型\"></a>2 软件开发模型</h1><p>计算机刚刚诞生的年代，是一种只有天才才能掌握的巩固，人们对软件知识的认知仅仅停留在程序层面。随着技术发展，软件复杂度的提高，意识到必须遵循一定的开发方法才能取得成功，于是出现了模式化的开发方法称为开发模型。</p>\n<h2 id=\"2-1-瀑布模型\"><a href=\"#2-1-瀑布模型\" class=\"headerlink\" title=\"2.1 瀑布模型\"></a>2.1 瀑布模型</h2><p>特点：</p>\n<ol>\n<li>软件过程要经过需求分析、总体设计、详细设计、编码、调试、集成测试和系统测试阶段，开发阶段划分明确</li>\n<li>再每一个阶段结算后都有不定的文档或者程序流入下一个阶段</li>\n<li>每个阶段在发现问题时可以反馈给上一个阶段进行修正<br>适用场景：需求明确、稳定时</li>\n</ol>\n<h3 id=\"2-1-1-瀑布V模型\"><a href=\"#2-1-1-瀑布V模型\" class=\"headerlink\" title=\"2.1.1 瀑布V模型\"></a>2.1.1 瀑布V模型</h3><p>同标准瀑布模型一样，保持了瀑布模型的阶段式文档驱动的特点，但是更强调软件产品的验证工作，即需求分析的记过将作为系统测试的标准，能够在设计初期得到验证，以此类推，总体设计对应了集成测试，详细设计对应了单元测试。</p>\n<h3 id=\"2-1-2-瀑布模型的缺点\"><a href=\"#2-1-2-瀑布模型的缺点\" class=\"headerlink\" title=\"2.1.2 瀑布模型的缺点\"></a>2.1.2 瀑布模型的缺点</h3><ol>\n<li>需求分析是一切活动的基础，如果需求分析出现偏差，将导致后续活动放大这个偏差。但事实是，由于用户、开发者立场、经验不同、知识领域不同，对同一事物的表述不同造成的理解偏差难于避免，导致后期维护工作繁重</li>\n<li>难于适应需求变化，一旦需求变更要重头再来</li>\n<li>从需求提出到最后看到产品是一个相当长的过程，不能及时给用户反馈，并验证是否是能够满足客户需求的软件。</li>\n<li>瀑布模型是面向文档的开发模型，过程中将产生大量文档，大部分对客户没有意义，但却工作量繁重</li>\n</ol>\n<h2 id=\"2-2-演化模型\"><a href=\"#2-2-演化模型\" class=\"headerlink\" title=\"2.2 演化模型\"></a>2.2 演化模型</h2><p>演化模型是在瀑布模型难以一次性完全理解用户需求的基础上，对整个过程进行若干次的“瀑布模型”迭代，做到不断渐进、不断深入的过程</p>\n<h2 id=\"2-3-螺旋模型\"><a href=\"#2-3-螺旋模型\" class=\"headerlink\" title=\"2.3 螺旋模型\"></a>2.3 螺旋模型</h2><p>螺旋模型是在瀑布模型和演化模型结合的基础上，还强调其他模型忽略的风险分析。<br>特点：</p>\n<ol>\n<li>螺旋模型对每一期都包含需求定义、风险分析、工程实现、和评审4个阶段，对整个过程进行螺旋式迭代</li>\n<li>支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供方便，降低软件开发风险</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>螺旋模型的风险评估需要具有丰富风险评估经验和专业知识的人，否则将造成重大损失</li>\n<li>过多的迭代次数会增加开发成本，延迟提交时间</li>\n</ol>\n<h2 id=\"2-4-增量模型\"><a href=\"#2-4-增量模型\" class=\"headerlink\" title=\"2.4 增量模型\"></a>2.4 增量模型</h2><p>演化模型是另外一种增量模型的形式。在系统架构成熟、风险较低时，可采用增量方式进行系统开发，可提前进行基础测试和系统测试，缩短出事版本的发布周期，提高用户对系统的可见度。<br>特点：</p>\n<ol>\n<li>增量模型，做好系统的分析和设计，对系统划分为若干不同的版本，每一个版本都是完成可用的系统，后一个版本是前一个版本的基础进行开发，扩展前一个版本的功能，同时保证每个版本增量均匀。</li>\n<li>原型法，每一次发布都经历完成的生命周期，当用户需求很多不明确或者技术架构中很多不可知因素时，可采用原型增量法。在初始版本的原型并不考虑需求的合理性和系统稳定性，只为精准获取用户需求，一般会在后面的开发中抛弃这个原型进行完成的系统实现。</li>\n</ol>\n<h2 id=\"2-5-构件组装模型\"><a href=\"#2-5-构件组装模型\" class=\"headerlink\" title=\"2.5 构件组装模型\"></a>2.5 构件组装模型</h2><p>将系统划分为一组构件的集合，明确构件之间的关系。每个构件可以独立开发、自包容，可以是自己开发设计，也可以是第三方购买整合。最后进行构件组装的一个开发模型。<br>构件组装优点：</p>\n<ol>\n<li>构件自包容让系统扩展变得更加容易</li>\n<li>良好的构件更容易重用，降低开发成本</li>\n<li>构件力度较整个系统更小，更容易开发设计及安排工作更加灵活</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>对构件设计需要经验丰富的架构设计师，设计不良的构件难以实现他的优点</li>\n<li>考虑重用度是，往往会对其他方面设计做出让步，比如性能</li>\n<li>构件组装应用是，要求程序员熟悉掌握构件，增加了开发人员的学习成本</li>\n<li>第三方构件质量难以把控，将影响软件的质量。</li>\n</ol>\n<h1 id=\"3-统一过程模型\"><a href=\"#3-统一过程模型\" class=\"headerlink\" title=\"3 统一过程模型\"></a>3 统一过程模型</h1><p>统一过程（Unified Process, UP）是一种优秀的软件开发模型，可以有效地降低软件开发过程中的风险。这个开发模型的特点是每一个阶段的工作都不是绝对的，都是相互交叠配的的，但是每一个阶段都有侧重点。</p>\n<p><img src=\"leanote://file/getImage?fileId=5eaa43af605ce63a32000003\" alt></p>\n<p>整个过程大致分为</p>\n<ol>\n<li>初始阶段，刚刚接入系统开发工作，侧重工作是明确系统目的，业务建模和需求工作</li>\n<li>细化阶段，抽象软件逻辑模型，设计架构，侧重是分析设计工作</li>\n<li>构件阶段，完成系统的构件，使之成为一个完整的实体，并进行测试和部署</li>\n<li>交付阶段，软件系统需求已经完成，重点工作是对软件进行重构、修改、测试和部署</li>\n</ol>\n<p>整个工作内容整体包括：业务建模、需求、分析设计、实施、测试、部署、配置与变更管理、项目管理、环境。</p>\n<p>其中“环境”是相对于其他工作难以理解的。环境工作很重要，也称之为环境管理。在软件开发过程中，需要为各种工作准备相应的工作环境，在工作环境中包含必须的工具、活动指南、活动流程规范、工作产品模板、基本的开发设施等。环境管理应该在工作流中得到应有的重视，每个开发团队都有自己的特点和活动准则规范，这种准则和规范是团队协作的基础，万万不能少，否则开发活动就会使放养式的管理。</p>\n<p>** UP的生命周期**<br>分为4个里程碑</p>\n<ol>\n<li>目标里程碑。明确系统的目标和范围时达到这个里程</li>\n<li>架构里程碑。当开发者确定稳定系统的架构时达到这个里程</li>\n<li>能力里程碑。当系统已经足够稳定和成熟并完成了Alpha测试之后达到这个里程碑</li>\n<li>发布里程碑。当完成系统的测试、完成系统的发布和用户培训工作之后达到这个里程碑</li>\n</ol>\n<p>UP的特点：</p>\n<ol>\n<li>UP是一个迭代的二维开发模型，每个生命后期都可以进行需求、设计、开发等</li>\n<li>采用不同的迭代方式的UP可以演变为演化模型或增量模型</li>\n<li>UP的迭代特点使得更容易控制开发风险</li>\n<li>Up是迭代开发模型，但不属于敏捷开发模型。一般未经过裁剪的Up是一个重载过程</li>\n<li>实际应用可根据具体问题进行UP的裁剪，从而使用各种规模的软件和开发团队</li>\n</ol>\n<p>架构师在UP活动中的作用<br>架构师除了需要建立系统的架构模型外，在UP活动中承担非常重要的角色，例如：</p>\n<ol>\n<li>同需求人员和项目管理人员密切协作</li>\n<li>细化软件架构</li>\n<li>保持整个架构的概念完整性，具体地说就是定义设计方法、设计指南、编码规范、平舌工作</li>\n</ol>\n<p><strong>因此有人称UP是一个已加购书为中心的开发模型。</strong></p>\n<h1 id=\"4-敏捷开发方法\"><a href=\"#4-敏捷开发方法\" class=\"headerlink\" title=\"4 敏捷开发方法\"></a>4 敏捷开发方法</h1><p>2001年，17位“无政府主义者”共同发表了《敏捷软件开发宣言》：</p>\n<blockquote>\n<ol>\n<li>尽早地、持续地向客户交付有价值的软件对开发人员来说是最重要的。</li>\n<li>拥抱变化，即使在开发的后期。敏捷过程能够驾驭变化，保持客户的竞争力。</li>\n<li>经常交付可工作的软件，从几周到几个月，时间范围越小越好。</li>\n<li>在整个项目中，业务人员和开发者紧密合作。</li>\n<li>围绕士气高昂的团队进行开发，为团队成员提供适宜的环境，满足他们的需要，并给予<br>足够的信任。</li>\n<li>在团队中，最有效率的、也是效果最好的沟通方式是面对面地交流。</li>\n<li>可以工作的软件是进度首要的度量方式。</li>\n<li>可持续地开发。投资人、开发团队和用户应该保持固定的节奏。</li>\n<li>不断追求优秀的技术和良好的设计有助于提高敏捷性。</li>\n<li>要简单，尽可能减少工作量。减少工作量的艺术是非常重要的。</li>\n<li>最好的架构、需求和设计都来自于一个自我组织的团队。</li>\n<li>团队要定期地总结如何能够更有效率，然后相应地自我调整</li>\n</ol>\n</blockquote>\n<p>这份宣言就是敏捷开发方法的灯塔</p>\n<h2 id=\"4-1-敏捷开发方法实践之极限编程（eXtreme-Programming）\"><a href=\"#4-1-敏捷开发方法实践之极限编程（eXtreme-Programming）\" class=\"headerlink\" title=\"4.1 敏捷开发方法实践之极限编程（eXtreme Programming）\"></a>4.1 敏捷开发方法实践之极限编程（eXtreme Programming）</h2><p>极限编程（XP）是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方法。特点如下：</p>\n<ol>\n<li>在更短的周期内，更早地提供具体、持续的反馈信息。</li>\n<li>迭代地进行计划编制。在最开始迅速形成总体计划，然后开发过程中不断迭代发展它</li>\n<li>依赖自动化测试程序来监控开发进度，尽早地铺货缺陷</li>\n<li>依赖口头交流、测试和源程序进行沟通</li>\n<li>倡导持续的、演化式的设计</li>\n<li>依赖于开发团队内部的紧密协作</li>\n<li>尽可能达到程序员的短期利益和长期利益的平衡。即关注短期程序员的自主设计和参与感，同时帮助程序员长期的成长</li>\n</ol>\n<p>四大价值观：沟通、简单、反馈、勇气</p>\n<ol>\n<li>沟通。通常，程序员相对内向，不善言谈，项目中的许多问题都发生在缺乏良好的沟通上。而传统的开发方法中并不太在意这种口头的沟通，而是希望通过完善的流程和面面俱到的文档、报表、计划来代替，这同时就引入了效率不高的问题，往往一个小问题通过漫长的流程下来被放大。而XP方法认为，如果小组内成员无法做到持续的、无间断的交流，协作就无从谈起，XP鼓励大家进行口头的面对面交流快速解决问题，提高效率。</li>\n<li>简单。XP方法的工作中秉承“够用即好”，实现尽可能简单化，不要过度设计。这一点看上去容易，但要做到其实很淡，因为在传统的开发过程中需要开发人员对未来做一些预先的规划，以便后续做扩展预留空间，这是一个平衡的过程，并不是一点都不考虑未来的可扩展性，所以比较难做到</li>\n<li>反馈。传统的开发过程中缺乏对客户必要的反馈，整个开发过程像一个“黑盒子”，过程漫长，完全看不到效果和进度。容易造成最终偏离用户需求的系统软件。XP注重反馈的作用，通过持续的、明确的反馈来暴露软件当前的状态和问题，尽早地纠正一些可以避免的错误。</li>\n<li>勇气。在XP方法中，要有勇气面对每时每刻的变化带来的挑战。由于提倡良好的沟通，会有更多的需求调整；由于提倡系统保持简单，需求变更导致的重构；由于提倡尽早反馈，更多地发现问题并纠正。而面对这些带来的挑战，我们更需要为之提高勇气。因为相比于沟通、简单和反馈带来的挑战，更多的我们是得到了良好的信息同步，尽早地发现了问题，更清晰地理解了用户需求，以及更简单地实现了系统软件。</li>\n</ol>\n<p>XP的四大价值观之下，隐藏着一种更深刻的东西，那就是尊重，对人的尊重。因为这一切都是建立在团队成员之间的相互关系、相互理解的基础之上。</p>\n<h3 id=\"4-1-1-极限编程的十二个最佳实践\"><a href=\"#4-1-1-极限编程的十二个最佳实践\" class=\"headerlink\" title=\"4.1.1 极限编程的十二个最佳实践\"></a>4.1.1 极限编程的十二个最佳实践</h3><ol>\n<li><p>计划游戏。主要思想是先快速制定一份概要计划，然后随着项目细节的不断清醒，在逐步完善这份计划。“客户负责业务决策，开发负责计算决策”，也就是说系统的范围、下一次迭代发布的时间、用户股市的优先级应有客户决定，而每个用户故事所需的而开发时间、技术成本、如何组件团队、以及开发顺序应有开发团队决定。</p>\n<blockquote>\n<p>计划游戏开始，客户和开发同坐一屋子，每个人准备一支笔、一些用于记录用户需求的纸片，再准备一个白板就可以开始了。</p>\n<ol>\n<li>客户编写需求故事：由客户谈论系统应该完成什么功能，然后用自然语言词汇写在卡片上</li>\n<li>开发人员进行评估：有客户按优先级将故事需求标注为必须有、希望有、如果有三类，然后又开发人进行估算，优先级由高到低。如果估算的时候感到故事需求太大，不容易估算或者超过2人/周，那么应该进行分解在进行评估</li>\n<li>确定迭代周期：根据用户期望的需求优先级、期望发布的时间结合开发现有资源与用户协商，筛检出能够实现的需求，形成初步的需求计划。</li>\n</ol>\n</blockquote>\n</li>\n<li><p>小型发布。XP方法秉承“持续集成，小步快走”的哲学思维，也就是说每次发布的版本尽可能肖，当然前提是每个版本都有发布的商业价值，值得发布。</p>\n</li>\n<li><p>隐喻。相对而言，隐喻这个令人费解，什么时隐喻呢，字面意思是用来暗示字面意义不相似的事物之间相似的东西。对应到开发过程中就是，需要寻求共识，对系统理解、目标价值以等；还有就是发明共享词汇，通过规范项目中常用通用的业务专有名词，减少不必要的沟通；描述体系结构；并不是每一种情况都能找到合适的隐喻，没必要强求，而是顺其自然。</p>\n</li>\n<li><p>简单设计。强调简单的价值观，引出简单性假设原则。这里说的简单设计并不是忽略设计而是设计不应该一次完成，因为随着业务的变化，可能当时设想的可预知的未来根本就是不存在的，留有适当的扩展设计并满足现有需求的简单设计原则。</p>\n</li>\n<li><p>测试先行。是指注重测试用例程序的编写，不能因为没有时间，工作紧张为由忽略测试工作，这样就会由于没有良好的测试用例而化大把的时间在后续的联调维护阶段，实际上这个整体上市大大降低产能、效率埂底下的做法。</p>\n</li>\n<li><p>重构。重构是一种对待吗进行重写而不影响功能实现的的技术，XP要求在开发人员“问到代码的坏味道”时，就有重构代码的勇气。重构的目的是让代码降低因变化引起的风险、使得代码更加易于维护和阅读。</p>\n</li>\n<li><p>结对编程。一开始虽然会牺牲一些速度，但慢慢的，开发速度会逐步加快，究其原因是结对编程大大降低了沟通成本，提高了工作的质量，具体表现在：</p>\n<ol>\n<li>所有的设计决策确保不是一个人做出来的</li>\n<li>系统的任何部分至少有2个人以上熟悉</li>\n<li>不能能同时2个人都忽略测试项</li>\n<li>阶段的动态性，是一个去也知识管理的好途径</li>\n<li>代码总是能够保证评审通过</li>\n<li>XP方法集成的吉他最佳实践能够是的结对编程更加容易进行</li>\n<li>编码标准能够消除一些无谓的分歧</li>\n<li>隐喻可以帮助结对伙伴更好沟通</li>\n<li>简单设计能够是的伙伴更了解他们所从事的工作</li>\n</ol>\n<p>结对编程技术被誉为XP保持工作质量、强调人文主义的一个典型实践，能够是的开发团队之间的协作更加流畅、知识交流更加频繁、团队更加稳定。</p>\n</li>\n</ol>\n<ol start=\"8\">\n<li>集体代码所有制。有XP方法鼓励团队进行结对编程，而且编程组是动态搭配的，每个人会遇到不同的代码，代码所有制就不是局限于某一个人，而是集体所有制，团队中的每个人都有进行修改的权利，每个人都拥有全部代码，也都需要对全部代码负责。同时XP强调代码是谁该坏的就应该有谁来修复。</li>\n<li>持续集成。持续集成是最佳实践的基本支撑条件。</li>\n<li>每周工作40小时。这是一个让开发者开心、管理者反对的一个最佳实践。加班早已成为开发人员的家常便饭，也是管理者最常用的一种策略。而XP方法认为，加班会扼杀团队的积极性，最终导致项目失败，这也体现了XP方法是关注人的因素比关注过程的因素更多一些。这里说的40小时不是绝对的额，是指根据团队公司合理的工作时长。提倡追求有效的、高效的工作时间，而不是绝对的时长。</li>\n<li>现场客户。为了保证开发出来的结果与客户的预想接近，XP方法认为最重要的是将客户请到现场，保持和客户的现场沟通，并让客户参与到开发决策中来。</li>\n<li>编码标准。拥有编码标准可以避免团队无关细节的争论。不过这个标准不是越细越好，而是要能够确保代码清晰，便于交流的一个指导方针。</li>\n</ol>\n<p>XP方法最大价值在于项目中融会贯通地运用这12个最佳实践，而非单独使用。当然可以使用其中一些实践，单并不意味这就应用了XP方法。</p>\n<h2 id=\"4-2-特征驱动开发方法\"><a href=\"#4-2-特征驱动开发方法\" class=\"headerlink\" title=\"4.2 特征驱动开发方法\"></a>4.2 特征驱动开发方法</h2><p>FDD也是一个迭代的开发模型。FDD每一步都强调质量，不断地交付可运行的软件，并以很小的开发提供准确的项目进度报告和状态信息。同敏捷开发一样，FDD弱化了过程在软件开发的地位。</p>\n<h3 id=\"4-2-1-FDD的角色定义\"><a href=\"#4-2-1-FDD的角色定义\" class=\"headerlink\" title=\"4.2.1 FDD的角色定义\"></a>4.2.1 FDD的角色定义</h3><p>FDD认为，有效的软件开发不可或缺的三个要素是：人、过程和技术。软件开发不能没有过程，也不能没有技术，但最重要的还是人。定义了6中关键角色：</p>\n<ol>\n<li>项目经理。项目开发的组织者，是团队的保护屏障，提供一个适宜的开发环境。</li>\n<li>首席架构设计师。负责系统的架构设计</li>\n<li>开发经理。负责团队日常的开发工作的安排，解决开发过程中的技术问题和资源冲突</li>\n<li>主程序员。主程序员将带领小组完成特征的详细设计和构件工作，一般要求主程序员具有一定的工作经验，并能够带动小组工作。</li>\n<li>程序员。若干个程序员在主程序员带领下完成小组的开发，按照特征开发疾患完成开发</li>\n<li>领域专家。领域专家是指对业务精通的人，一般有客户、系统分析师担当。</li>\n</ol>\n<h3 id=\"4-2-2-FDD的最佳实践\"><a href=\"#4-2-2-FDD的最佳实践\" class=\"headerlink\" title=\"4.2.2 FDD的最佳实践\"></a>4.2.2 FDD的最佳实践</h3><p>FDD最佳实践包括：领域对象建模、根据特征进行开发、类的个体所有、组成特征小组、审查、定期构造、配置管理、结果的可见性<br>其中最有特色的是个体所有，激活所有的而开发模型都是代码共有。但在FDD中，将类分配给特定的任何小组，分配给A小组的代码只能由A来维护，除A外的角色都不能修改它，只能使用它。<br>优点是：</p>\n<ol>\n<li>这个类的支配感会促使开发人员产生自豪感，从而更出色地完成任务。不过FDD也提到了类q</li>\n<li>审查也是FDD中很具特设的一项实践。不少人认为审查是非常严格的软件过程特有的，然而FDD中明确将审查作为一项最佳实践。审查是一种很有效的发现缺陷的手段，但经常被忽视，国内的软件组织中很少有严格的审查制度保障软件质量。在开发阶段的代码审查机制能够很好的避免潜在的问题。</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>项目依赖关系增强，形成代码黑盒，除了负责人没人能修改。</li>\n</ol>\n<h2 id=\"4-3-Scrum\"><a href=\"#4-3-Scrum\" class=\"headerlink\" title=\"4.3 Scrum\"></a>4.3 Scrum</h2><p>Scrum是一个用于开发和维护复杂产品框架，是一个增量的、迭代的开发过程。由若干个迭代周期组成，一个短的迭代周期成为Sprint,每个Sprint的建议周期在2到4周。在Scrum中，使用产品的Backlog来管理产品的需求，产品Backlog是一个按商业价值拍下的需求列表。<br>Scrum团队重产品的Backlog中挑选优先级最高的需求进行开发。<br>挑选的需求在sprint的计划会议上进行讨论、分析和估算得到相应的任务列表，称之为Sprint backlog.</p>\n<h3 id=\"4-3-1-Scrum的5个活动\"><a href=\"#4-3-1-Scrum的5个活动\" class=\"headerlink\" title=\"4.3.1 Scrum的5个活动\"></a>4.3.1 Scrum的5个活动</h3><p><img src=\"leanote://file/getImage?fileId=5ea94009605ce63a32000000\" alt></p>\n<ol>\n<li><p>产品待办事项的梳理——Prodct Backlog. 产品待办事项通常会很多，也很宽泛，而且想法会变来变去、优先级也会变化，所以产品待办事项列表的梳理是一个贯穿整个Scrum项目的活动。梳理包括：整理需求、优先级排序、事项分解、归并以及商业价值分析等。待办事项的梳理最好是所有团队成员参与，因为有可能需要其他技术或者团队的参与，而不是单单产品经理。</p>\n</li>\n<li><p>Sprint计划会议。每个Sprint工作周期以Sprint计划会议作为开始，让团队共同选择和理解即将到来的Sprint工作事项. Sprint计划会议的成功十分依赖产品待办事项列表的质量。Sprint计划会议工作内容有两部分：</p>\n<ol>\n<li>需要完成那些工作：产品负责人介绍排好序的代办事项，让整个Scrum团队共同理解这些工作。而产品待办事项的数目完全有开发团队决定，开发团队要考虑当天产品的增量状态，团队过去的工作情况，当前生产力等，产品负责人不能强加更多的工作量。</li>\n<li>如何完成工作：开发团队根据当前的“完成的定义”一起决定如何实现一个产品增量，进行任务分解，前几天的工作分解成小单元，每个单元不超过一天，之后的任务可以稍微大一些，以后再对它进行分解。总之产品和开发团队一起考虑斌讨论产品待办事项，确保每个人对事项的理解一致，最终产出待办事项列表就是“Sprint 待办事项列表”，称之为Sprint Backlog</li>\n</ol>\n</li>\n<li><p>每日Scrum会议。开发团队自组织，通过每日Scrum会议来确认他们任然可以实现Sprint的目标，每个人说下三点内容：上一个工作日完成了什么、当前工作日计划完成什么、有什么阻碍或风险。一般不超过15分钟。</p>\n</li>\n<li><p>Sprint评审会议。一个Sprint周期结束时，Scrum团队和相关人员一起评审Sprint的产出，Sprint评审会议向每个人展示当前的产品增量情况，帮助大家了解我们目前的进度到哪里，讨论他们在Sprint过程中看到了什么、有什么想法，并一起探讨下一步如何更好的推进。</p>\n</li>\n<li><p>Sprint回顾会议。每个Sprint周期结束之后，Scrum团队开回顾会议，目的是回顾一下团队在流程人际关系及工作方面做得如何，识别出团队中做得好的与不好的，并找潜在可以改进的事项，为将来的Sprint提供改进的计划</p>\n</li>\n</ol>\n<h3 id=\"4-3-2-Scrum的5大价值观\"><a href=\"#4-3-2-Scrum的5大价值观\" class=\"headerlink\" title=\"4.3.2 Scrum的5大价值观\"></a>4.3.2 Scrum的5大价值观</h3><ol>\n<li>承若——愿意对目标负责</li>\n<li>专注——把你的心思和能力都用到你承诺的工作上去</li>\n<li>开放——Scrum把项目中的一切开放给每个人看，做到信息透明</li>\n<li>尊重——每个人都有他独特的背景和经验，尊重每个人的特点</li>\n<li>勇气——有勇气做出承诺，履行程度，接受别人的尊重</li>\n</ol>\n<h2 id=\"4-4-水晶方法\"><a href=\"#4-4-水晶方法\" class=\"headerlink\" title=\"4.4 水晶方法\"></a>4.4 水晶方法</h2><p>水晶方法有七大体系特征：</p>\n<ol>\n<li>经常交付。没过一段时间或者几个月向用户交付可测试运行的代码，让用户有机会发现原来需求是否是他真正想要的，有机会将结果反馈到开发中。</li>\n<li>反思改进。开发过程中难免会遇到一些技术难题、各种烦心事，会影响项目进度，所以我们应该经常在迭代中及时地进行反思和改进，从慌乱的日常开发中，抽一点时间来思考更为行之有效的方法。</li>\n<li>渗透式交流。渗透式交流就是信息交流在团队成员中形成背景听觉，使得成员就像通过渗透一样获取相关信息。团队通过在一个共同的工作空间内，若其中一个成员提出问题，其他成员可以选择关注或不关注，也可以随时加入到讨论中来，选择性地获取相关交流的信息。</li>\n<li>个人安全。当你勇敢指出了困扰你的问题时，你可以不用担心受到报复，应该有保护机制，鼓励大家发现和改正自身的缺点，而不是知而不言，这样就会对团队造成损害，不利于整个团队的协作和稳定。</li>\n<li>焦点。也叫聚焦，明确知道要做什么，然后再安排时间，确保团队成员都清楚地了解他们自己最重要的任务是什么，确保他们能够充分利用时间去完成这些任务。</li>\n<li>与专家用户简历方便的联系。与专家用户简历方便的联系能够给团队提供很好的帮助，例如对业务的专业理解，成品的质量和快速罚款，设计理念和需求背景，用户最新的需求等。</li>\n<li>自动化测试。自动化测试是在开发在修改代码之后能够进行自动化测试，以便发现一些bug，让开发能够及时地进行修复，节省了整体的开发时间，提高效率。</li>\n</ol>\n<h2 id=\"4-5-其他敏捷方法——开放式源码\"><a href=\"#4-5-其他敏捷方法——开放式源码\" class=\"headerlink\" title=\"4.5 其他敏捷方法——开放式源码\"></a>4.5 其他敏捷方法——开放式源码</h2><p>开放式源码——是指以开放源码的方式运作，特别的就是开发人员可能地域分布很广，这和其他的敏捷方法不同，开放源码的一个好处就是排错的高度并行性，任何人都可以发现错误并修改代码提交给维护者。这里面体现的价值观就是猜测、合作和学习。</p>\n<h1 id=\"5-软件重用\"><a href=\"#5-软件重用\" class=\"headerlink\" title=\"5 软件重用\"></a>5 软件重用</h1><p>软件产品和其他的产品不同，是抽象的，一旦产生就可以无限地复制，因此重复利用软件产品意义重大，可以节约大量的人力物力。软件重用包括：软件产品、源代码、文档、设计思想甚至领域知识。<br>常见的重用形式：</p>\n<ol>\n<li>源代码重用。这是简单最常见的重用形式，由于软件系统的复杂性，很难大规模地重用已有代码</li>\n<li>架构重用。这个重用也很常见，随着软件架构风格和设计模式的推广和应用，架构重用已经对软件开发产生了重大影响</li>\n<li>应用框架的重用。随着技术的发展，应用框架的重用变得越来越普遍，如AOP、EJB、Spring等应用框架技术</li>\n<li>商业建模的重用。虽然软件领域各有不同，但是人们可以总结出常用的领域建模的方法，重用这些领域建模可以降低不确定性因素风险。</li>\n<li>文档及过程的重用。有效地重用已有的文档有助于提高开发的效率</li>\n<li>构件的重用。如第三方的组件，中间件等</li>\n<li>软件服务的重用。随着web服务的提出，人们越来越关注服务的重用。例如SOA架构就是一个服务重用的实践，让一类功能收归到一个服务做不同业务软件的重用服务。</li>\n</ol>\n<h1 id=\"6-基于架构的软件设计\"><a href=\"#6-基于架构的软件设计\" class=\"headerlink\" title=\"6 基于架构的软件设计\"></a>6 基于架构的软件设计</h1><p>基于架构的软件设计（Architecture-Based Software Design,ABSD）是一种架构驱动的设计方法，这种方法有3个基础：</p>\n<ol>\n<li>功能分解。在功能分解中，ABSD方法使用已有的基于模块内聚和耦合技术</li>\n<li>通过选择架构风格来实现质量和业务需求</li>\n<li>软件模板的使用。软件模板利用了一些软件系统的结构。</li>\n</ol>\n<p>ABSB模型是吧整个过程划分为：架构需求、设计、文档化、复审、实现和演化</p>\n<h2 id=\"6-1-ABSB方法与生命周期\"><a href=\"#6-1-ABSB方法与生命周期\" class=\"headerlink\" title=\"6.1 ABSB方法与生命周期\"></a>6.1 ABSB方法与生命周期</h2><p><img src=\"leanote://file/getImage?fileId=5ea97d8a605ce63a32000001\" alt></p>\n<h2 id=\"6-2-基于架构的软件开发模型\"><a href=\"#6-2-基于架构的软件开发模型\" class=\"headerlink\" title=\"6.2 基于架构的软件开发模型\"></a>6.2 基于架构的软件开发模型</h2><p>基于架构的软件开发模型（Architecture-Based Software Design Model，ABSDM）把整个基于架构的软件过程划分为架构需求、架构设计、架构文档化、架构复审、架构实现和架构演化6个子过程：<br><img src=\"leanote://file/getImage?fileId=5eaa3c4f605ce63a32000002\" alt></p>\n<ol>\n<li>机构需求。是指用户对目标软件在系统功能、行为、性能、设计约束方面的期望。通过用户的需求，架构师根据技术环境和架构师经验标注出所需要的构件，最后进行需求的评审。必要时“需求获取——标识构件——需求评审”之间进行迭代。</li>\n<li>架构设计。根据架构需求提出架构的模型、映射构件、分析构件相互作用、产生架构、设计评审</li>\n<li>架构文档化。绝大多数架构都是抽象的，有一些概念的构件组成。为了开发人员更好地理解和实现架构，必须把架构进行文档化描述</li>\n<li>架构复审。架构设计完成之后要安排一次由外部人员（用户和领域专家）参与的复审，其目的是识别潜在的风险，及早发现架构设计中的缺陷和错误，包括架构能否满足需求、质量需求是否得到体现、是否清晰、构件是否划分合理、文档标识是否明确、以及构架设计是否满足功能和性能要求等等</li>\n<li>架构实现。开发人员根据复审后的架构文档，分析和实现其中的构件，然后组装测试的一个过程。</li>\n<li>架构演化。在架构开发中，用户的需求可能变动，在开发完成正常运行后，也可能发生需求变化。那么就要相应地调整架构以适应新的软件需求。主要过程包括这7个步骤：需求变动归类、架构演化计划、构件变动、更新构件的相互作用关系、构件组装和测试、技术评审、技术评审，最后得出演化后的架构设计。</li>\n</ol>\n<h1 id=\"7-形式化方法\"><a href=\"#7-形式化方法\" class=\"headerlink\" title=\"7 形式化方法\"></a>7 形式化方法</h1><p>形式化方法是指采用严格的数据方法对软件的描述、开发和验证的过程进行严格规约的一种方法，通过这种方式可以需求和定义人员与开发人员的理解偏差，避免模糊性和二义性。通过形式化描述进行需求分析的质量大大提高，很多自然语言描述无法避免的缺陷在需求分析阶段就会被发现并等到解决，从而降低了后期的开发和维护的成本。形式化描述可以通过计算计算进行自动处理（一些专业软件），进行一致性检查和证明。<br>一般一些安全要求较高的，如地铁、高铁、航空、核电等软件会考虑使用这种开发方法来保证系统的安全和可靠性。</p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<blockquote>\n<p>前言：软件开发方法是软件开发的方法学，旨在提供软件的质量，降低开发成本</p>\n</blockquote>\n<h1 id=\"1-软件生命周期\"><a href=\"#1-软件生命周期\" class=\"headerlink\" title=\"1 软件生命周期\"></a>1 软件生命周期</h1><ol>\n<li>可行性研究和规划：通过可行性分析确认原件的必要性，价值点，初步确认软件的目标、范围、风险和开发成本等内容。</li>\n<li>需求分析：需求分析是开发过程的重要阶段，初步确认软件开发的目标和范围，之后则要对软件的需求进行细致分析，确认最终要做成什么样子。这个过程极其重要，如果这个阶段出现分析错误和偏差将导致后续开发过程偏离真实需求越远，修正的成本越大。</li>\n<li>概要设计：是程序员开发过程中的蓝图，包括确认系统架构、各个子系统依赖关系、数据库模型、编码规范、接口规约等内容</li>\n<li>详细设计：详细设计师开发之前的最后设计，是在概要设计的基础上进行进行细化，如类设计。详细设计不是必要过程，在规模较小，功能结构简单的系统中可以省略。</li>\n<li>实现：针对设计的单元模块进行开发，如一个过程、方法、函数，包括实现单元模块的单元测试</li>\n<li>集成测试：对单元模块进行组装联调测试</li>\n<li>确认测试：系统开发完后，需要验证是否和需求预期一致</li>\n<li>软件使用和维护：软件投入试运行，并不断对过程中出现的问题进行维护修正，软件维护郭晨会贯穿整个软件的使用郭晨直至软件自然消亡。</li>\n</ol>\n<h1 id=\"2-软件开发模型\"><a href=\"#2-软件开发模型\" class=\"headerlink\" title=\"2 软件开发模型\"></a>2 软件开发模型</h1><p>计算机刚刚诞生的年代，是一种只有天才才能掌握的巩固，人们对软件知识的认知仅仅停留在程序层面。随着技术发展，软件复杂度的提高，意识到必须遵循一定的开发方法才能取得成功，于是出现了模式化的开发方法称为开发模型。</p>\n<h2 id=\"2-1-瀑布模型\"><a href=\"#2-1-瀑布模型\" class=\"headerlink\" title=\"2.1 瀑布模型\"></a>2.1 瀑布模型</h2><p>特点：</p>\n<ol>\n<li>软件过程要经过需求分析、总体设计、详细设计、编码、调试、集成测试和系统测试阶段，开发阶段划分明确</li>\n<li>再每一个阶段结算后都有不定的文档或者程序流入下一个阶段</li>\n<li>每个阶段在发现问题时可以反馈给上一个阶段进行修正<br>适用场景：需求明确、稳定时</li>\n</ol>\n<h3 id=\"2-1-1-瀑布V模型\"><a href=\"#2-1-1-瀑布V模型\" class=\"headerlink\" title=\"2.1.1 瀑布V模型\"></a>2.1.1 瀑布V模型</h3><p>同标准瀑布模型一样，保持了瀑布模型的阶段式文档驱动的特点，但是更强调软件产品的验证工作，即需求分析的记过将作为系统测试的标准，能够在设计初期得到验证，以此类推，总体设计对应了集成测试，详细设计对应了单元测试。</p>\n<h3 id=\"2-1-2-瀑布模型的缺点\"><a href=\"#2-1-2-瀑布模型的缺点\" class=\"headerlink\" title=\"2.1.2 瀑布模型的缺点\"></a>2.1.2 瀑布模型的缺点</h3><ol>\n<li>需求分析是一切活动的基础，如果需求分析出现偏差，将导致后续活动放大这个偏差。但事实是，由于用户、开发者立场、经验不同、知识领域不同，对同一事物的表述不同造成的理解偏差难于避免，导致后期维护工作繁重</li>\n<li>难于适应需求变化，一旦需求变更要重头再来</li>\n<li>从需求提出到最后看到产品是一个相当长的过程，不能及时给用户反馈，并验证是否是能够满足客户需求的软件。</li>\n<li>瀑布模型是面向文档的开发模型，过程中将产生大量文档，大部分对客户没有意义，但却工作量繁重</li>\n</ol>\n<h2 id=\"2-2-演化模型\"><a href=\"#2-2-演化模型\" class=\"headerlink\" title=\"2.2 演化模型\"></a>2.2 演化模型</h2><p>演化模型是在瀑布模型难以一次性完全理解用户需求的基础上，对整个过程进行若干次的“瀑布模型”迭代，做到不断渐进、不断深入的过程</p>\n<h2 id=\"2-3-螺旋模型\"><a href=\"#2-3-螺旋模型\" class=\"headerlink\" title=\"2.3 螺旋模型\"></a>2.3 螺旋模型</h2><p>螺旋模型是在瀑布模型和演化模型结合的基础上，还强调其他模型忽略的风险分析。<br>特点：</p>\n<ol>\n<li>螺旋模型对每一期都包含需求定义、风险分析、工程实现、和评审4个阶段，对整个过程进行螺旋式迭代</li>\n<li>支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供方便，降低软件开发风险</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>螺旋模型的风险评估需要具有丰富风险评估经验和专业知识的人，否则将造成重大损失</li>\n<li>过多的迭代次数会增加开发成本，延迟提交时间</li>\n</ol>\n<h2 id=\"2-4-增量模型\"><a href=\"#2-4-增量模型\" class=\"headerlink\" title=\"2.4 增量模型\"></a>2.4 增量模型</h2><p>演化模型是另外一种增量模型的形式。在系统架构成熟、风险较低时，可采用增量方式进行系统开发，可提前进行基础测试和系统测试，缩短出事版本的发布周期，提高用户对系统的可见度。<br>特点：</p>\n<ol>\n<li>增量模型，做好系统的分析和设计，对系统划分为若干不同的版本，每一个版本都是完成可用的系统，后一个版本是前一个版本的基础进行开发，扩展前一个版本的功能，同时保证每个版本增量均匀。</li>\n<li>原型法，每一次发布都经历完成的生命周期，当用户需求很多不明确或者技术架构中很多不可知因素时，可采用原型增量法。在初始版本的原型并不考虑需求的合理性和系统稳定性，只为精准获取用户需求，一般会在后面的开发中抛弃这个原型进行完成的系统实现。</li>\n</ol>\n<h2 id=\"2-5-构件组装模型\"><a href=\"#2-5-构件组装模型\" class=\"headerlink\" title=\"2.5 构件组装模型\"></a>2.5 构件组装模型</h2><p>将系统划分为一组构件的集合，明确构件之间的关系。每个构件可以独立开发、自包容，可以是自己开发设计，也可以是第三方购买整合。最后进行构件组装的一个开发模型。<br>构件组装优点：</p>\n<ol>\n<li>构件自包容让系统扩展变得更加容易</li>\n<li>良好的构件更容易重用，降低开发成本</li>\n<li>构件力度较整个系统更小，更容易开发设计及安排工作更加灵活</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>对构件设计需要经验丰富的架构设计师，设计不良的构件难以实现他的优点</li>\n<li>考虑重用度是，往往会对其他方面设计做出让步，比如性能</li>\n<li>构件组装应用是，要求程序员熟悉掌握构件，增加了开发人员的学习成本</li>\n<li>第三方构件质量难以把控，将影响软件的质量。</li>\n</ol>\n<h1 id=\"3-统一过程模型\"><a href=\"#3-统一过程模型\" class=\"headerlink\" title=\"3 统一过程模型\"></a>3 统一过程模型</h1><p>统一过程（Unified Process, UP）是一种优秀的软件开发模型，可以有效地降低软件开发过程中的风险。这个开发模型的特点是每一个阶段的工作都不是绝对的，都是相互交叠配的的，但是每一个阶段都有侧重点。</p>\n<p><img src=\"leanote://file/getImage?fileId=5eaa43af605ce63a32000003\" alt></p>\n<p>整个过程大致分为</p>\n<ol>\n<li>初始阶段，刚刚接入系统开发工作，侧重工作是明确系统目的，业务建模和需求工作</li>\n<li>细化阶段，抽象软件逻辑模型，设计架构，侧重是分析设计工作</li>\n<li>构件阶段，完成系统的构件，使之成为一个完整的实体，并进行测试和部署</li>\n<li>交付阶段，软件系统需求已经完成，重点工作是对软件进行重构、修改、测试和部署</li>\n</ol>\n<p>整个工作内容整体包括：业务建模、需求、分析设计、实施、测试、部署、配置与变更管理、项目管理、环境。</p>\n<p>其中“环境”是相对于其他工作难以理解的。环境工作很重要，也称之为环境管理。在软件开发过程中，需要为各种工作准备相应的工作环境，在工作环境中包含必须的工具、活动指南、活动流程规范、工作产品模板、基本的开发设施等。环境管理应该在工作流中得到应有的重视，每个开发团队都有自己的特点和活动准则规范，这种准则和规范是团队协作的基础，万万不能少，否则开发活动就会使放养式的管理。</p>\n<p>** UP的生命周期**<br>分为4个里程碑</p>\n<ol>\n<li>目标里程碑。明确系统的目标和范围时达到这个里程</li>\n<li>架构里程碑。当开发者确定稳定系统的架构时达到这个里程</li>\n<li>能力里程碑。当系统已经足够稳定和成熟并完成了Alpha测试之后达到这个里程碑</li>\n<li>发布里程碑。当完成系统的测试、完成系统的发布和用户培训工作之后达到这个里程碑</li>\n</ol>\n<p>UP的特点：</p>\n<ol>\n<li>UP是一个迭代的二维开发模型，每个生命后期都可以进行需求、设计、开发等</li>\n<li>采用不同的迭代方式的UP可以演变为演化模型或增量模型</li>\n<li>UP的迭代特点使得更容易控制开发风险</li>\n<li>Up是迭代开发模型，但不属于敏捷开发模型。一般未经过裁剪的Up是一个重载过程</li>\n<li>实际应用可根据具体问题进行UP的裁剪，从而使用各种规模的软件和开发团队</li>\n</ol>\n<p>架构师在UP活动中的作用<br>架构师除了需要建立系统的架构模型外，在UP活动中承担非常重要的角色，例如：</p>\n<ol>\n<li>同需求人员和项目管理人员密切协作</li>\n<li>细化软件架构</li>\n<li>保持整个架构的概念完整性，具体地说就是定义设计方法、设计指南、编码规范、平舌工作</li>\n</ol>\n<p><strong>因此有人称UP是一个已加购书为中心的开发模型。</strong></p>\n<h1 id=\"4-敏捷开发方法\"><a href=\"#4-敏捷开发方法\" class=\"headerlink\" title=\"4 敏捷开发方法\"></a>4 敏捷开发方法</h1><p>2001年，17位“无政府主义者”共同发表了《敏捷软件开发宣言》：</p>\n<blockquote>\n<ol>\n<li>尽早地、持续地向客户交付有价值的软件对开发人员来说是最重要的。</li>\n<li>拥抱变化，即使在开发的后期。敏捷过程能够驾驭变化，保持客户的竞争力。</li>\n<li>经常交付可工作的软件，从几周到几个月，时间范围越小越好。</li>\n<li>在整个项目中，业务人员和开发者紧密合作。</li>\n<li>围绕士气高昂的团队进行开发，为团队成员提供适宜的环境，满足他们的需要，并给予<br>足够的信任。</li>\n<li>在团队中，最有效率的、也是效果最好的沟通方式是面对面地交流。</li>\n<li>可以工作的软件是进度首要的度量方式。</li>\n<li>可持续地开发。投资人、开发团队和用户应该保持固定的节奏。</li>\n<li>不断追求优秀的技术和良好的设计有助于提高敏捷性。</li>\n<li>要简单，尽可能减少工作量。减少工作量的艺术是非常重要的。</li>\n<li>最好的架构、需求和设计都来自于一个自我组织的团队。</li>\n<li>团队要定期地总结如何能够更有效率，然后相应地自我调整</li>\n</ol>\n</blockquote>\n<p>这份宣言就是敏捷开发方法的灯塔</p>\n<h2 id=\"4-1-敏捷开发方法实践之极限编程（eXtreme-Programming）\"><a href=\"#4-1-敏捷开发方法实践之极限编程（eXtreme-Programming）\" class=\"headerlink\" title=\"4.1 敏捷开发方法实践之极限编程（eXtreme Programming）\"></a>4.1 敏捷开发方法实践之极限编程（eXtreme Programming）</h2><p>极限编程（XP）是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方法。特点如下：</p>\n<ol>\n<li>在更短的周期内，更早地提供具体、持续的反馈信息。</li>\n<li>迭代地进行计划编制。在最开始迅速形成总体计划，然后开发过程中不断迭代发展它</li>\n<li>依赖自动化测试程序来监控开发进度，尽早地铺货缺陷</li>\n<li>依赖口头交流、测试和源程序进行沟通</li>\n<li>倡导持续的、演化式的设计</li>\n<li>依赖于开发团队内部的紧密协作</li>\n<li>尽可能达到程序员的短期利益和长期利益的平衡。即关注短期程序员的自主设计和参与感，同时帮助程序员长期的成长</li>\n</ol>\n<p>四大价值观：沟通、简单、反馈、勇气</p>\n<ol>\n<li>沟通。通常，程序员相对内向，不善言谈，项目中的许多问题都发生在缺乏良好的沟通上。而传统的开发方法中并不太在意这种口头的沟通，而是希望通过完善的流程和面面俱到的文档、报表、计划来代替，这同时就引入了效率不高的问题，往往一个小问题通过漫长的流程下来被放大。而XP方法认为，如果小组内成员无法做到持续的、无间断的交流，协作就无从谈起，XP鼓励大家进行口头的面对面交流快速解决问题，提高效率。</li>\n<li>简单。XP方法的工作中秉承“够用即好”，实现尽可能简单化，不要过度设计。这一点看上去容易，但要做到其实很淡，因为在传统的开发过程中需要开发人员对未来做一些预先的规划，以便后续做扩展预留空间，这是一个平衡的过程，并不是一点都不考虑未来的可扩展性，所以比较难做到</li>\n<li>反馈。传统的开发过程中缺乏对客户必要的反馈，整个开发过程像一个“黑盒子”，过程漫长，完全看不到效果和进度。容易造成最终偏离用户需求的系统软件。XP注重反馈的作用，通过持续的、明确的反馈来暴露软件当前的状态和问题，尽早地纠正一些可以避免的错误。</li>\n<li>勇气。在XP方法中，要有勇气面对每时每刻的变化带来的挑战。由于提倡良好的沟通，会有更多的需求调整；由于提倡系统保持简单，需求变更导致的重构；由于提倡尽早反馈，更多地发现问题并纠正。而面对这些带来的挑战，我们更需要为之提高勇气。因为相比于沟通、简单和反馈带来的挑战，更多的我们是得到了良好的信息同步，尽早地发现了问题，更清晰地理解了用户需求，以及更简单地实现了系统软件。</li>\n</ol>\n<p>XP的四大价值观之下，隐藏着一种更深刻的东西，那就是尊重，对人的尊重。因为这一切都是建立在团队成员之间的相互关系、相互理解的基础之上。</p>\n<h3 id=\"4-1-1-极限编程的十二个最佳实践\"><a href=\"#4-1-1-极限编程的十二个最佳实践\" class=\"headerlink\" title=\"4.1.1 极限编程的十二个最佳实践\"></a>4.1.1 极限编程的十二个最佳实践</h3><ol>\n<li><p>计划游戏。主要思想是先快速制定一份概要计划，然后随着项目细节的不断清醒，在逐步完善这份计划。“客户负责业务决策，开发负责计算决策”，也就是说系统的范围、下一次迭代发布的时间、用户股市的优先级应有客户决定，而每个用户故事所需的而开发时间、技术成本、如何组件团队、以及开发顺序应有开发团队决定。</p>\n<blockquote>\n<p>计划游戏开始，客户和开发同坐一屋子，每个人准备一支笔、一些用于记录用户需求的纸片，再准备一个白板就可以开始了。</p>\n<ol>\n<li>客户编写需求故事：由客户谈论系统应该完成什么功能，然后用自然语言词汇写在卡片上</li>\n<li>开发人员进行评估：有客户按优先级将故事需求标注为必须有、希望有、如果有三类，然后又开发人进行估算，优先级由高到低。如果估算的时候感到故事需求太大，不容易估算或者超过2人/周，那么应该进行分解在进行评估</li>\n<li>确定迭代周期：根据用户期望的需求优先级、期望发布的时间结合开发现有资源与用户协商，筛检出能够实现的需求，形成初步的需求计划。</li>\n</ol>\n</blockquote>\n</li>\n<li><p>小型发布。XP方法秉承“持续集成，小步快走”的哲学思维，也就是说每次发布的版本尽可能肖，当然前提是每个版本都有发布的商业价值，值得发布。</p>\n</li>\n<li><p>隐喻。相对而言，隐喻这个令人费解，什么时隐喻呢，字面意思是用来暗示字面意义不相似的事物之间相似的东西。对应到开发过程中就是，需要寻求共识，对系统理解、目标价值以等；还有就是发明共享词汇，通过规范项目中常用通用的业务专有名词，减少不必要的沟通；描述体系结构；并不是每一种情况都能找到合适的隐喻，没必要强求，而是顺其自然。</p>\n</li>\n<li><p>简单设计。强调简单的价值观，引出简单性假设原则。这里说的简单设计并不是忽略设计而是设计不应该一次完成，因为随着业务的变化，可能当时设想的可预知的未来根本就是不存在的，留有适当的扩展设计并满足现有需求的简单设计原则。</p>\n</li>\n<li><p>测试先行。是指注重测试用例程序的编写，不能因为没有时间，工作紧张为由忽略测试工作，这样就会由于没有良好的测试用例而化大把的时间在后续的联调维护阶段，实际上这个整体上市大大降低产能、效率埂底下的做法。</p>\n</li>\n<li><p>重构。重构是一种对待吗进行重写而不影响功能实现的的技术，XP要求在开发人员“问到代码的坏味道”时，就有重构代码的勇气。重构的目的是让代码降低因变化引起的风险、使得代码更加易于维护和阅读。</p>\n</li>\n<li><p>结对编程。一开始虽然会牺牲一些速度，但慢慢的，开发速度会逐步加快，究其原因是结对编程大大降低了沟通成本，提高了工作的质量，具体表现在：</p>\n<ol>\n<li>所有的设计决策确保不是一个人做出来的</li>\n<li>系统的任何部分至少有2个人以上熟悉</li>\n<li>不能能同时2个人都忽略测试项</li>\n<li>阶段的动态性，是一个去也知识管理的好途径</li>\n<li>代码总是能够保证评审通过</li>\n<li>XP方法集成的吉他最佳实践能够是的结对编程更加容易进行</li>\n<li>编码标准能够消除一些无谓的分歧</li>\n<li>隐喻可以帮助结对伙伴更好沟通</li>\n<li>简单设计能够是的伙伴更了解他们所从事的工作</li>\n</ol>\n<p>结对编程技术被誉为XP保持工作质量、强调人文主义的一个典型实践，能够是的开发团队之间的协作更加流畅、知识交流更加频繁、团队更加稳定。</p>\n</li>\n</ol>\n<ol start=\"8\">\n<li>集体代码所有制。有XP方法鼓励团队进行结对编程，而且编程组是动态搭配的，每个人会遇到不同的代码，代码所有制就不是局限于某一个人，而是集体所有制，团队中的每个人都有进行修改的权利，每个人都拥有全部代码，也都需要对全部代码负责。同时XP强调代码是谁该坏的就应该有谁来修复。</li>\n<li>持续集成。持续集成是最佳实践的基本支撑条件。</li>\n<li>每周工作40小时。这是一个让开发者开心、管理者反对的一个最佳实践。加班早已成为开发人员的家常便饭，也是管理者最常用的一种策略。而XP方法认为，加班会扼杀团队的积极性，最终导致项目失败，这也体现了XP方法是关注人的因素比关注过程的因素更多一些。这里说的40小时不是绝对的额，是指根据团队公司合理的工作时长。提倡追求有效的、高效的工作时间，而不是绝对的时长。</li>\n<li>现场客户。为了保证开发出来的结果与客户的预想接近，XP方法认为最重要的是将客户请到现场，保持和客户的现场沟通，并让客户参与到开发决策中来。</li>\n<li>编码标准。拥有编码标准可以避免团队无关细节的争论。不过这个标准不是越细越好，而是要能够确保代码清晰，便于交流的一个指导方针。</li>\n</ol>\n<p>XP方法最大价值在于项目中融会贯通地运用这12个最佳实践，而非单独使用。当然可以使用其中一些实践，单并不意味这就应用了XP方法。</p>\n<h2 id=\"4-2-特征驱动开发方法\"><a href=\"#4-2-特征驱动开发方法\" class=\"headerlink\" title=\"4.2 特征驱动开发方法\"></a>4.2 特征驱动开发方法</h2><p>FDD也是一个迭代的开发模型。FDD每一步都强调质量，不断地交付可运行的软件，并以很小的开发提供准确的项目进度报告和状态信息。同敏捷开发一样，FDD弱化了过程在软件开发的地位。</p>\n<h3 id=\"4-2-1-FDD的角色定义\"><a href=\"#4-2-1-FDD的角色定义\" class=\"headerlink\" title=\"4.2.1 FDD的角色定义\"></a>4.2.1 FDD的角色定义</h3><p>FDD认为，有效的软件开发不可或缺的三个要素是：人、过程和技术。软件开发不能没有过程，也不能没有技术，但最重要的还是人。定义了6中关键角色：</p>\n<ol>\n<li>项目经理。项目开发的组织者，是团队的保护屏障，提供一个适宜的开发环境。</li>\n<li>首席架构设计师。负责系统的架构设计</li>\n<li>开发经理。负责团队日常的开发工作的安排，解决开发过程中的技术问题和资源冲突</li>\n<li>主程序员。主程序员将带领小组完成特征的详细设计和构件工作，一般要求主程序员具有一定的工作经验，并能够带动小组工作。</li>\n<li>程序员。若干个程序员在主程序员带领下完成小组的开发，按照特征开发疾患完成开发</li>\n<li>领域专家。领域专家是指对业务精通的人，一般有客户、系统分析师担当。</li>\n</ol>\n<h3 id=\"4-2-2-FDD的最佳实践\"><a href=\"#4-2-2-FDD的最佳实践\" class=\"headerlink\" title=\"4.2.2 FDD的最佳实践\"></a>4.2.2 FDD的最佳实践</h3><p>FDD最佳实践包括：领域对象建模、根据特征进行开发、类的个体所有、组成特征小组、审查、定期构造、配置管理、结果的可见性<br>其中最有特色的是个体所有，激活所有的而开发模型都是代码共有。但在FDD中，将类分配给特定的任何小组，分配给A小组的代码只能由A来维护，除A外的角色都不能修改它，只能使用它。<br>优点是：</p>\n<ol>\n<li>这个类的支配感会促使开发人员产生自豪感，从而更出色地完成任务。不过FDD也提到了类q</li>\n<li>审查也是FDD中很具特设的一项实践。不少人认为审查是非常严格的软件过程特有的，然而FDD中明确将审查作为一项最佳实践。审查是一种很有效的发现缺陷的手段，但经常被忽视，国内的软件组织中很少有严格的审查制度保障软件质量。在开发阶段的代码审查机制能够很好的避免潜在的问题。</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>项目依赖关系增强，形成代码黑盒，除了负责人没人能修改。</li>\n</ol>\n<h2 id=\"4-3-Scrum\"><a href=\"#4-3-Scrum\" class=\"headerlink\" title=\"4.3 Scrum\"></a>4.3 Scrum</h2><p>Scrum是一个用于开发和维护复杂产品框架，是一个增量的、迭代的开发过程。由若干个迭代周期组成，一个短的迭代周期成为Sprint,每个Sprint的建议周期在2到4周。在Scrum中，使用产品的Backlog来管理产品的需求，产品Backlog是一个按商业价值拍下的需求列表。<br>Scrum团队重产品的Backlog中挑选优先级最高的需求进行开发。<br>挑选的需求在sprint的计划会议上进行讨论、分析和估算得到相应的任务列表，称之为Sprint backlog.</p>\n<h3 id=\"4-3-1-Scrum的5个活动\"><a href=\"#4-3-1-Scrum的5个活动\" class=\"headerlink\" title=\"4.3.1 Scrum的5个活动\"></a>4.3.1 Scrum的5个活动</h3><p><img src=\"leanote://file/getImage?fileId=5ea94009605ce63a32000000\" alt></p>\n<ol>\n<li><p>产品待办事项的梳理——Prodct Backlog. 产品待办事项通常会很多，也很宽泛，而且想法会变来变去、优先级也会变化，所以产品待办事项列表的梳理是一个贯穿整个Scrum项目的活动。梳理包括：整理需求、优先级排序、事项分解、归并以及商业价值分析等。待办事项的梳理最好是所有团队成员参与，因为有可能需要其他技术或者团队的参与，而不是单单产品经理。</p>\n</li>\n<li><p>Sprint计划会议。每个Sprint工作周期以Sprint计划会议作为开始，让团队共同选择和理解即将到来的Sprint工作事项. Sprint计划会议的成功十分依赖产品待办事项列表的质量。Sprint计划会议工作内容有两部分：</p>\n<ol>\n<li>需要完成那些工作：产品负责人介绍排好序的代办事项，让整个Scrum团队共同理解这些工作。而产品待办事项的数目完全有开发团队决定，开发团队要考虑当天产品的增量状态，团队过去的工作情况，当前生产力等，产品负责人不能强加更多的工作量。</li>\n<li>如何完成工作：开发团队根据当前的“完成的定义”一起决定如何实现一个产品增量，进行任务分解，前几天的工作分解成小单元，每个单元不超过一天，之后的任务可以稍微大一些，以后再对它进行分解。总之产品和开发团队一起考虑斌讨论产品待办事项，确保每个人对事项的理解一致，最终产出待办事项列表就是“Sprint 待办事项列表”，称之为Sprint Backlog</li>\n</ol>\n</li>\n<li><p>每日Scrum会议。开发团队自组织，通过每日Scrum会议来确认他们任然可以实现Sprint的目标，每个人说下三点内容：上一个工作日完成了什么、当前工作日计划完成什么、有什么阻碍或风险。一般不超过15分钟。</p>\n</li>\n<li><p>Sprint评审会议。一个Sprint周期结束时，Scrum团队和相关人员一起评审Sprint的产出，Sprint评审会议向每个人展示当前的产品增量情况，帮助大家了解我们目前的进度到哪里，讨论他们在Sprint过程中看到了什么、有什么想法，并一起探讨下一步如何更好的推进。</p>\n</li>\n<li><p>Sprint回顾会议。每个Sprint周期结束之后，Scrum团队开回顾会议，目的是回顾一下团队在流程人际关系及工作方面做得如何，识别出团队中做得好的与不好的，并找潜在可以改进的事项，为将来的Sprint提供改进的计划</p>\n</li>\n</ol>\n<h3 id=\"4-3-2-Scrum的5大价值观\"><a href=\"#4-3-2-Scrum的5大价值观\" class=\"headerlink\" title=\"4.3.2 Scrum的5大价值观\"></a>4.3.2 Scrum的5大价值观</h3><ol>\n<li>承若——愿意对目标负责</li>\n<li>专注——把你的心思和能力都用到你承诺的工作上去</li>\n<li>开放——Scrum把项目中的一切开放给每个人看，做到信息透明</li>\n<li>尊重——每个人都有他独特的背景和经验，尊重每个人的特点</li>\n<li>勇气——有勇气做出承诺，履行程度，接受别人的尊重</li>\n</ol>\n<h2 id=\"4-4-水晶方法\"><a href=\"#4-4-水晶方法\" class=\"headerlink\" title=\"4.4 水晶方法\"></a>4.4 水晶方法</h2><p>水晶方法有七大体系特征：</p>\n<ol>\n<li>经常交付。没过一段时间或者几个月向用户交付可测试运行的代码，让用户有机会发现原来需求是否是他真正想要的，有机会将结果反馈到开发中。</li>\n<li>反思改进。开发过程中难免会遇到一些技术难题、各种烦心事，会影响项目进度，所以我们应该经常在迭代中及时地进行反思和改进，从慌乱的日常开发中，抽一点时间来思考更为行之有效的方法。</li>\n<li>渗透式交流。渗透式交流就是信息交流在团队成员中形成背景听觉，使得成员就像通过渗透一样获取相关信息。团队通过在一个共同的工作空间内，若其中一个成员提出问题，其他成员可以选择关注或不关注，也可以随时加入到讨论中来，选择性地获取相关交流的信息。</li>\n<li>个人安全。当你勇敢指出了困扰你的问题时，你可以不用担心受到报复，应该有保护机制，鼓励大家发现和改正自身的缺点，而不是知而不言，这样就会对团队造成损害，不利于整个团队的协作和稳定。</li>\n<li>焦点。也叫聚焦，明确知道要做什么，然后再安排时间，确保团队成员都清楚地了解他们自己最重要的任务是什么，确保他们能够充分利用时间去完成这些任务。</li>\n<li>与专家用户简历方便的联系。与专家用户简历方便的联系能够给团队提供很好的帮助，例如对业务的专业理解，成品的质量和快速罚款，设计理念和需求背景，用户最新的需求等。</li>\n<li>自动化测试。自动化测试是在开发在修改代码之后能够进行自动化测试，以便发现一些bug，让开发能够及时地进行修复，节省了整体的开发时间，提高效率。</li>\n</ol>\n<h2 id=\"4-5-其他敏捷方法——开放式源码\"><a href=\"#4-5-其他敏捷方法——开放式源码\" class=\"headerlink\" title=\"4.5 其他敏捷方法——开放式源码\"></a>4.5 其他敏捷方法——开放式源码</h2><p>开放式源码——是指以开放源码的方式运作，特别的就是开发人员可能地域分布很广，这和其他的敏捷方法不同，开放源码的一个好处就是排错的高度并行性，任何人都可以发现错误并修改代码提交给维护者。这里面体现的价值观就是猜测、合作和学习。</p>\n<h1 id=\"5-软件重用\"><a href=\"#5-软件重用\" class=\"headerlink\" title=\"5 软件重用\"></a>5 软件重用</h1><p>软件产品和其他的产品不同，是抽象的，一旦产生就可以无限地复制，因此重复利用软件产品意义重大，可以节约大量的人力物力。软件重用包括：软件产品、源代码、文档、设计思想甚至领域知识。<br>常见的重用形式：</p>\n<ol>\n<li>源代码重用。这是简单最常见的重用形式，由于软件系统的复杂性，很难大规模地重用已有代码</li>\n<li>架构重用。这个重用也很常见，随着软件架构风格和设计模式的推广和应用，架构重用已经对软件开发产生了重大影响</li>\n<li>应用框架的重用。随着技术的发展，应用框架的重用变得越来越普遍，如AOP、EJB、Spring等应用框架技术</li>\n<li>商业建模的重用。虽然软件领域各有不同，但是人们可以总结出常用的领域建模的方法，重用这些领域建模可以降低不确定性因素风险。</li>\n<li>文档及过程的重用。有效地重用已有的文档有助于提高开发的效率</li>\n<li>构件的重用。如第三方的组件，中间件等</li>\n<li>软件服务的重用。随着web服务的提出，人们越来越关注服务的重用。例如SOA架构就是一个服务重用的实践，让一类功能收归到一个服务做不同业务软件的重用服务。</li>\n</ol>\n<h1 id=\"6-基于架构的软件设计\"><a href=\"#6-基于架构的软件设计\" class=\"headerlink\" title=\"6 基于架构的软件设计\"></a>6 基于架构的软件设计</h1><p>基于架构的软件设计（Architecture-Based Software Design,ABSD）是一种架构驱动的设计方法，这种方法有3个基础：</p>\n<ol>\n<li>功能分解。在功能分解中，ABSD方法使用已有的基于模块内聚和耦合技术</li>\n<li>通过选择架构风格来实现质量和业务需求</li>\n<li>软件模板的使用。软件模板利用了一些软件系统的结构。</li>\n</ol>\n<p>ABSB模型是吧整个过程划分为：架构需求、设计、文档化、复审、实现和演化</p>\n<h2 id=\"6-1-ABSB方法与生命周期\"><a href=\"#6-1-ABSB方法与生命周期\" class=\"headerlink\" title=\"6.1 ABSB方法与生命周期\"></a>6.1 ABSB方法与生命周期</h2><p><img src=\"leanote://file/getImage?fileId=5ea97d8a605ce63a32000001\" alt></p>\n<h2 id=\"6-2-基于架构的软件开发模型\"><a href=\"#6-2-基于架构的软件开发模型\" class=\"headerlink\" title=\"6.2 基于架构的软件开发模型\"></a>6.2 基于架构的软件开发模型</h2><p>基于架构的软件开发模型（Architecture-Based Software Design Model，ABSDM）把整个基于架构的软件过程划分为架构需求、架构设计、架构文档化、架构复审、架构实现和架构演化6个子过程：<br><img src=\"leanote://file/getImage?fileId=5eaa3c4f605ce63a32000002\" alt></p>\n<ol>\n<li>机构需求。是指用户对目标软件在系统功能、行为、性能、设计约束方面的期望。通过用户的需求，架构师根据技术环境和架构师经验标注出所需要的构件，最后进行需求的评审。必要时“需求获取——标识构件——需求评审”之间进行迭代。</li>\n<li>架构设计。根据架构需求提出架构的模型、映射构件、分析构件相互作用、产生架构、设计评审</li>\n<li>架构文档化。绝大多数架构都是抽象的，有一些概念的构件组成。为了开发人员更好地理解和实现架构，必须把架构进行文档化描述</li>\n<li>架构复审。架构设计完成之后要安排一次由外部人员（用户和领域专家）参与的复审，其目的是识别潜在的风险，及早发现架构设计中的缺陷和错误，包括架构能否满足需求、质量需求是否得到体现、是否清晰、构件是否划分合理、文档标识是否明确、以及构架设计是否满足功能和性能要求等等</li>\n<li>架构实现。开发人员根据复审后的架构文档，分析和实现其中的构件，然后组装测试的一个过程。</li>\n<li>架构演化。在架构开发中，用户的需求可能变动，在开发完成正常运行后，也可能发生需求变化。那么就要相应地调整架构以适应新的软件需求。主要过程包括这7个步骤：需求变动归类、架构演化计划、构件变动、更新构件的相互作用关系、构件组装和测试、技术评审、技术评审，最后得出演化后的架构设计。</li>\n</ol>\n<h1 id=\"7-形式化方法\"><a href=\"#7-形式化方法\" class=\"headerlink\" title=\"7 形式化方法\"></a>7 形式化方法</h1><p>形式化方法是指采用严格的数据方法对软件的描述、开发和验证的过程进行严格规约的一种方法，通过这种方式可以需求和定义人员与开发人员的理解偏差，避免模糊性和二义性。通过形式化描述进行需求分析的质量大大提高，很多自然语言描述无法避免的缺陷在需求分析阶段就会被发现并等到解决，从而降低了后期的开发和维护的成本。形式化描述可以通过计算计算进行自动处理（一些专业软件），进行一致性检查和证明。<br>一般一些安全要求较高的，如地铁、高铁、航空、核电等软件会考虑使用这种开发方法来保证系统的安全和可靠性。</p>\n"},{"title":"从零开始使用Solidity编写以太坊智能合约并使用Nodejs SDK访问以太坊网络","date":"2019-08-29T01:25:00.000Z","author":"okeeper","top":true,"toc":true,"_content":"\n# Nodejs安装\n\nNodejs 版本建议8.0以上\n官网：https://nodejs.org/en/\n官网下载安装包:https://nodejs.org/dist/v8.12.0/node-v8.12.0-x64.msi\n安装参考：https://blog.csdn.net/qq_26562641/article/details/72235585\n\n配置淘宝镜像：\n```\nnpm config set registry https://registry.npm.taobao.org\n```\n\n# 新建一个Hello World只能合约的访问\n1. 使用IDEA安装nodejs插件，在插件列表搜索\n2. 新建一个node工程项目，File>New Project 选择Node.js and NPM\n ![](../images/未命名/getImage-20220825155544126.png)\n 默认有很多其他的目录，我们删除其他目录，只保留如下的目录：\n ![](../images/未命名/getImage-20220825155543961.png)\n 或者使用`npm init`命令初始化一个nodejs工程\n3.  安装solidity编译器依赖，用于编译Solidity，才能被nodejs使用到\n\n    ```\n    npm install --save solc\n    ```\n4. 安装以太坊的访问SDK web3.js\n\n    ```\n    npm install --save web3\n    ```\n    报错解决：\n    > 1. 报`gyp ERR! configure error\n    > gyp ERR! stack Error: Command failed: C:\\Users\\yan6\\AppData\\Local\\Programs\\Pytho\n    > n\\Python37-32\\python.EXE -c import sys; print \"%s.%s.%s\" % sys.version_info[:3];`\n    > 原因：安装脚本中用到了Python2的语法，你的环境变量中配置的Python3所以报这个错\n    > 解决：修改python的环境变量，将Python3改成Python2，如果没有到官网下载一个Python2\n    > 2. 报` error MSB3428: 未能加载 Visual C++ 组件“VCBuild.exe”。要解决此问题，1)`\n    >   ```\n    >   MSBUILD : error MSB3428: 未能加载 Visual C++ 组件“VCBuild.exe”。要解决此问题，1) 安装 .NET Framework 2.0 SDK；2) 安装 Microsoft Visual\n    >   Studio 2005；或 3) 如果将\n    >   该组件安装到了其他位置，请将其位置添加到系统路径中。 [D:\\workspace\\idea_workspace\\blockchian1\\node_modules\\scrypt\\build\\binding.sln]\n    >   MSBUILD : error MSB3428: 未能加载 Visual C++ 组件“VCBuild.exe”。要解决此问题，1) 安装 .NET Framework 2.0 SDK；2) 安装 Microsoft Visual\n    >   Studio 2005；或 3) 如果将\n    >   该组件安装到了其他位置，请将其位置添加到系统路径中。 [D:\\workspace\\idea_workspace\\blockchian1\\node_modules\\scrypt\\build\\binding.sln]\n    >   ```\n    >  解决办法,按装全局windows相关组件：\n    >   ```\n    >   npm install --global --production windows-build-tools \n    >   ```\n\n5. 安装ganache,ganache是用来在本地测试用的测试以太坊网络\n\n    ```\n    npm install -g ganache-cli\n    ```\n    \n6. 新建一个Solidity脚本，`Hello.sol`\n\n    ```\n    pragma solidity ^0.4.17;\n    \n    contract Hello {\n        string public name;\n    \n        function Hello(string _name) public {\n            name = _name;\n        }\n    \n        function setName(string _name) public {\n            name = _name;\n        }\n    \n        function getName() public view returns(string ) {\n            return name;\n        }\n    }\n    \n    ```\n7. 编写一个solidity的编译脚本compile.js\n\n    ```\n    const path = require('path');\n    const  fs = require('fs');\n    \n    const solc = require('solc');\n    \n    const srcpath = path.resolve(__dirname,'contracts', 'Hello.sol');\n    const source = fs.readFileSync(srcpath, 'utf-8');\n    //console.log(source);\n    \n    const result = solc.compile(source,1);\n    //console.log(result);\n    module.exports = result.contracts[':Hello'];\n    ```\n8. 在tests下新建一个本地Hello World测试类,`Web3Test.test.js`\n   \n    ```\n    const  assert = require('assert');\n    //约定规范，如果变量是大写\n    const Web3 = require('web3');\n    //内存里面的以太坊测试环境\n    const  ganache = require('ganache-cli');\n    const web3 = new Web3(ganache.provider());\n    \n    //执行编译脚本，并将编译结果引入进来\n    const {interface,bytecode} = require('../compile');\n    \n    /**\n     * 测试一个Hello World智能合约\n     * @returns {Promise.<void>}\n     */\n    testGetSet = async ()=> {\n        let accounts = await web3.eth.getAccounts();\n        //部署也是一个交易命令，所以需要花gas\n        const abi = JSON.parse(interface);\n        const contract = new web3.eth.Contract(abi);\n    \n        const result = await contract.deploy({\n            data:bytecode,\n            arguments:['Hello World']\n        }).send({\n            from:accounts[0],\n            gas: 1500000,\n            gasPrice: '30000'\n        });\n        console.log('deploy success:' + result.options.address);\n    \n        //测试查询\n        assert.equal(await result.methods.getName().call(),'Hello World');\n    \n        await result.methods.setName('hahaha').send({\n            from:accounts[0],\n            gas:100000\n        });\n        assert.equal(await result.methods.getName().call(),'hahaha');\n        console.log('测试智能合约成功');\n    }\n    \n    \n    /**\n     * 测试以太坊转账\n     * @returns {Promise.<void>}\n     */\n    testTrade = async ()=> {\n        let accounts = await web3.eth.getAccounts();\n        let b0 = await web3.eth.getBalance(accounts[0]);\n        let b1 = await web3.eth.getBalance(accounts[1]);\n        //发送交易\n        console.log('开始转账：account0:' + b0 + ' account1:' + b1);\n        await web3.eth.sendTransaction({\n            from:accounts[0],\n            to:accounts[1],\n            value:'1000000000000000'\n        });\n    \n        b0 = await web3.eth.getBalance(accounts[0]);\n        b1 = await web3.eth.getBalance(accounts[1]);\n        //发送交易\n        console.log('转账成功：account0:' + b0 + ' account1:' + b1);\n    }\n    \n    testGetSet();\n    testTrade();\n    \n    ```\n> 以上代码`\n> const {interface,bytecode} = require('../compile');`\n> 这句话的意思是将Hello.sol编译后的导入到当前的node上下文，interface就是编译后的一些方法定义，bytecode就是最终部署到以太坊网络的二进制数据\n\n9. 测试运行\n    ```\n    node `Web3Test.test.js\n    ```\n    运行结果：\n    ![](../images/未命名/getImage-20220825155544126-1414144.png)\n\n# 将代码提交到以太坊rankeby测试网络\n1. 安装truffle-hdwallet-provider\n   组件官方文档：https://www.npmjs.com/package/truffle-hdwallet-provider\n    ```\n     npm install truffle-hdwallet-provider\n    ```\n2. 使用truffle-hdwallet-provider：\n    ```\n    //线上的测试环境\n    var HDWalletProvider = require(\"truffle-hdwallet-provider\");\n    var mnemonic = \"这里是你的以太坊钱包私钥助记词\"; // 12 word mnemonic\n    //使用infura在线的provider\n    var provider = new HDWalletProvider(mnemonic, \"https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5\");\n    const web3 = new Web3(provider);\n    ```\n    > 上面用到的provider_url：https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5是infura的在线url,到https://rinkeby.infura.io注册一个账号并添加一个rinkeby的测试PROJECT就可以得到一个测试provider_url了，网络不好可能需要翻墙\n\n3. 新增一个测试代码进行测试交易,`EtherOnlieRinkebyTest.test.js`\n    ```\n    //约定规范，如果变量是大写\n    const Web3 = require('web3');\n    \n    //线上的测试环境\n    var HDWalletProvider = require(\"truffle-hdwallet-provider\");\n    var mnemonic = \"这里是你的以太坊钱包私钥助记词\"; // 12 word mnemonic\n    //使用infura在线的provider\n    var provider = new HDWalletProvider(mnemonic, \"https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5\");\n    const web3 = new Web3(provider);\n    \n    /**\n     * 测试web3\n     */\n    testSend = async ()=> {\n    \n            let accounts = await web3.eth.getAccounts();\n    \n            console.log(accounts);\n            let account0 = accounts[0];\n            let account1 = '0x5828eb46D40795Da76429553845DfA622F062CB2';\n    \n            let b0 = await web3.eth.getBalance(account0);\n            let b1 = await web3.eth.getBalance(account1);\n            console.log('开始转账：address0:' + account0 + ' :' + b0 + ' address1:'+account1 + ' account1:' + b1);\n            const tx = web3.eth.sendTransaction({\n                from:account0,\n                to:account1,\n                value: web3.utils.toWei('1', 'ether'),\n                data: web3.utils.toHex('I love you ,xiao man ju')\n            },async (err,address)=>  {\n                console.log(\"转账成功,address:\" + address);\n                b0 = await web3.eth.getBalance(account0);\n                b1 = await web3.eth.getBalance(account1);\n    \n                let tx = await web3.eth.getTransaction(address);\n                console.log('tx:'+ JSON.stringify(tx) +' 转账成功：address0:'+account0+':' + b0 + ' address1:'+account1+' account1:' + b1);\n            });\n           }\n    \n    testSend();\n    \n    ```\n\n4. 使用nodejs运行测试代码\n    ```\n    node EtherOnlieRinkebyTest.test.js\n    ```\n    输出结果如下：\n    ![](../images/未命名/getImage-20220825155544225.png)\n\n到此从开发到上传到访问以太坊rinkeby测试网络已经完成。\n\n\n# Nodejs测试框架\n上面我们测试一个node脚本是直接使用node命令直接运行，对于实际开发应用中如果想做到自动化测试用例的运行，需要用到类型java里面Junit测试框架的东西，这个东西在node里面叫Mocha\n\n1. 安装mocha\n    ```\n    npm install --save mocha\n    ```\n2. 修改`package.json`，将scripts.test改成`mocha`\n\n    ```\n    {\n      \"name\": \"blockchian1\",\n      \"version\": \"1.0.0\",\n      \"description\": \"\",\n      \"main\": \"app.js\",\n      \"directories\": {\n        \"test\": \"test\"\n      },\n      \"dependencies\": {\n        \"mocha\": \"^5.2.0\",\n        \"solc\": \"^0.4.25\"\n      },\n      \"devDependencies\": {},\n      \"scripts\": {\n        \"test\": \"mocha\"\n      },\n      \"author\": \"\",\n      \"license\": \"ISC\"\n    }\n    ```\n    > 配置了scripts.test 为mocha命令，`npm run test`访问的就是mocha的测框架\n3. mocha测试，`MochaTest.test.js`, describe就是基本的mocha测试骨架，it是测试用例\n\n    ```\n    const assert = require('assert');\n    /**\n     * ecs6 mocha测试\n     */\n    class Test {\n        say() {\n            return 'hello';\n        }\n    \n        happy() {\n            return 'haha';\n        }\n    }\n    \n    //开始写mocha测试框架\n    \n    let dog;\n    beforeEach(()=>{\n        dog = new Test();\n    })\n    \n    describe('第一个mocha测试用例',()=> {\n        it('测试hello()',()=>{\n            //const  dog = new Test();\n            let say = dog.say();\n            console.log(say);\n            assert.equal(say,'hello');\n    \n        })\n    \n        it('测试happy()',()=>{\n            let happy = dog.happy();\n            console.log(happy);\n            assert.equal(happy,'haha');\n        })\n    })\n    ```\n> 以上用到了assert组件，这个类似java里面的Assert断言，默认在node上下文已将安装，直接依赖使用即可\n\n4. 运行测试用例\n    ```\n    npm run test\n    ```\n    这个test访问的就是我们之前修改的`package.json`里面的test命令mocha，类似maven构建时的测试，它将运行项目上下文中的所有实现了mocha的测试用例","source":"_posts/区块链/从零开始使用Solidity编写以太坊智能合约并使用Nodejs SDK访问以太坊网络.md","raw":"---\ntitle: 从零开始使用Solidity编写以太坊智能合约并使用Nodejs SDK访问以太坊网络\ndate: 2019-08-29 09:25:00\nauthor: okeeper\ntop: true\ntoc: true\ncategories: 区块链\ntags:\n  - 区块链\n---\n\n# Nodejs安装\n\nNodejs 版本建议8.0以上\n官网：https://nodejs.org/en/\n官网下载安装包:https://nodejs.org/dist/v8.12.0/node-v8.12.0-x64.msi\n安装参考：https://blog.csdn.net/qq_26562641/article/details/72235585\n\n配置淘宝镜像：\n```\nnpm config set registry https://registry.npm.taobao.org\n```\n\n# 新建一个Hello World只能合约的访问\n1. 使用IDEA安装nodejs插件，在插件列表搜索\n2. 新建一个node工程项目，File>New Project 选择Node.js and NPM\n ![](../images/未命名/getImage-20220825155544126.png)\n 默认有很多其他的目录，我们删除其他目录，只保留如下的目录：\n ![](../images/未命名/getImage-20220825155543961.png)\n 或者使用`npm init`命令初始化一个nodejs工程\n3.  安装solidity编译器依赖，用于编译Solidity，才能被nodejs使用到\n\n    ```\n    npm install --save solc\n    ```\n4. 安装以太坊的访问SDK web3.js\n\n    ```\n    npm install --save web3\n    ```\n    报错解决：\n    > 1. 报`gyp ERR! configure error\n    > gyp ERR! stack Error: Command failed: C:\\Users\\yan6\\AppData\\Local\\Programs\\Pytho\n    > n\\Python37-32\\python.EXE -c import sys; print \"%s.%s.%s\" % sys.version_info[:3];`\n    > 原因：安装脚本中用到了Python2的语法，你的环境变量中配置的Python3所以报这个错\n    > 解决：修改python的环境变量，将Python3改成Python2，如果没有到官网下载一个Python2\n    > 2. 报` error MSB3428: 未能加载 Visual C++ 组件“VCBuild.exe”。要解决此问题，1)`\n    >   ```\n    >   MSBUILD : error MSB3428: 未能加载 Visual C++ 组件“VCBuild.exe”。要解决此问题，1) 安装 .NET Framework 2.0 SDK；2) 安装 Microsoft Visual\n    >   Studio 2005；或 3) 如果将\n    >   该组件安装到了其他位置，请将其位置添加到系统路径中。 [D:\\workspace\\idea_workspace\\blockchian1\\node_modules\\scrypt\\build\\binding.sln]\n    >   MSBUILD : error MSB3428: 未能加载 Visual C++ 组件“VCBuild.exe”。要解决此问题，1) 安装 .NET Framework 2.0 SDK；2) 安装 Microsoft Visual\n    >   Studio 2005；或 3) 如果将\n    >   该组件安装到了其他位置，请将其位置添加到系统路径中。 [D:\\workspace\\idea_workspace\\blockchian1\\node_modules\\scrypt\\build\\binding.sln]\n    >   ```\n    >  解决办法,按装全局windows相关组件：\n    >   ```\n    >   npm install --global --production windows-build-tools \n    >   ```\n\n5. 安装ganache,ganache是用来在本地测试用的测试以太坊网络\n\n    ```\n    npm install -g ganache-cli\n    ```\n    \n6. 新建一个Solidity脚本，`Hello.sol`\n\n    ```\n    pragma solidity ^0.4.17;\n    \n    contract Hello {\n        string public name;\n    \n        function Hello(string _name) public {\n            name = _name;\n        }\n    \n        function setName(string _name) public {\n            name = _name;\n        }\n    \n        function getName() public view returns(string ) {\n            return name;\n        }\n    }\n    \n    ```\n7. 编写一个solidity的编译脚本compile.js\n\n    ```\n    const path = require('path');\n    const  fs = require('fs');\n    \n    const solc = require('solc');\n    \n    const srcpath = path.resolve(__dirname,'contracts', 'Hello.sol');\n    const source = fs.readFileSync(srcpath, 'utf-8');\n    //console.log(source);\n    \n    const result = solc.compile(source,1);\n    //console.log(result);\n    module.exports = result.contracts[':Hello'];\n    ```\n8. 在tests下新建一个本地Hello World测试类,`Web3Test.test.js`\n   \n    ```\n    const  assert = require('assert');\n    //约定规范，如果变量是大写\n    const Web3 = require('web3');\n    //内存里面的以太坊测试环境\n    const  ganache = require('ganache-cli');\n    const web3 = new Web3(ganache.provider());\n    \n    //执行编译脚本，并将编译结果引入进来\n    const {interface,bytecode} = require('../compile');\n    \n    /**\n     * 测试一个Hello World智能合约\n     * @returns {Promise.<void>}\n     */\n    testGetSet = async ()=> {\n        let accounts = await web3.eth.getAccounts();\n        //部署也是一个交易命令，所以需要花gas\n        const abi = JSON.parse(interface);\n        const contract = new web3.eth.Contract(abi);\n    \n        const result = await contract.deploy({\n            data:bytecode,\n            arguments:['Hello World']\n        }).send({\n            from:accounts[0],\n            gas: 1500000,\n            gasPrice: '30000'\n        });\n        console.log('deploy success:' + result.options.address);\n    \n        //测试查询\n        assert.equal(await result.methods.getName().call(),'Hello World');\n    \n        await result.methods.setName('hahaha').send({\n            from:accounts[0],\n            gas:100000\n        });\n        assert.equal(await result.methods.getName().call(),'hahaha');\n        console.log('测试智能合约成功');\n    }\n    \n    \n    /**\n     * 测试以太坊转账\n     * @returns {Promise.<void>}\n     */\n    testTrade = async ()=> {\n        let accounts = await web3.eth.getAccounts();\n        let b0 = await web3.eth.getBalance(accounts[0]);\n        let b1 = await web3.eth.getBalance(accounts[1]);\n        //发送交易\n        console.log('开始转账：account0:' + b0 + ' account1:' + b1);\n        await web3.eth.sendTransaction({\n            from:accounts[0],\n            to:accounts[1],\n            value:'1000000000000000'\n        });\n    \n        b0 = await web3.eth.getBalance(accounts[0]);\n        b1 = await web3.eth.getBalance(accounts[1]);\n        //发送交易\n        console.log('转账成功：account0:' + b0 + ' account1:' + b1);\n    }\n    \n    testGetSet();\n    testTrade();\n    \n    ```\n> 以上代码`\n> const {interface,bytecode} = require('../compile');`\n> 这句话的意思是将Hello.sol编译后的导入到当前的node上下文，interface就是编译后的一些方法定义，bytecode就是最终部署到以太坊网络的二进制数据\n\n9. 测试运行\n    ```\n    node `Web3Test.test.js\n    ```\n    运行结果：\n    ![](../images/未命名/getImage-20220825155544126-1414144.png)\n\n# 将代码提交到以太坊rankeby测试网络\n1. 安装truffle-hdwallet-provider\n   组件官方文档：https://www.npmjs.com/package/truffle-hdwallet-provider\n    ```\n     npm install truffle-hdwallet-provider\n    ```\n2. 使用truffle-hdwallet-provider：\n    ```\n    //线上的测试环境\n    var HDWalletProvider = require(\"truffle-hdwallet-provider\");\n    var mnemonic = \"这里是你的以太坊钱包私钥助记词\"; // 12 word mnemonic\n    //使用infura在线的provider\n    var provider = new HDWalletProvider(mnemonic, \"https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5\");\n    const web3 = new Web3(provider);\n    ```\n    > 上面用到的provider_url：https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5是infura的在线url,到https://rinkeby.infura.io注册一个账号并添加一个rinkeby的测试PROJECT就可以得到一个测试provider_url了，网络不好可能需要翻墙\n\n3. 新增一个测试代码进行测试交易,`EtherOnlieRinkebyTest.test.js`\n    ```\n    //约定规范，如果变量是大写\n    const Web3 = require('web3');\n    \n    //线上的测试环境\n    var HDWalletProvider = require(\"truffle-hdwallet-provider\");\n    var mnemonic = \"这里是你的以太坊钱包私钥助记词\"; // 12 word mnemonic\n    //使用infura在线的provider\n    var provider = new HDWalletProvider(mnemonic, \"https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5\");\n    const web3 = new Web3(provider);\n    \n    /**\n     * 测试web3\n     */\n    testSend = async ()=> {\n    \n            let accounts = await web3.eth.getAccounts();\n    \n            console.log(accounts);\n            let account0 = accounts[0];\n            let account1 = '0x5828eb46D40795Da76429553845DfA622F062CB2';\n    \n            let b0 = await web3.eth.getBalance(account0);\n            let b1 = await web3.eth.getBalance(account1);\n            console.log('开始转账：address0:' + account0 + ' :' + b0 + ' address1:'+account1 + ' account1:' + b1);\n            const tx = web3.eth.sendTransaction({\n                from:account0,\n                to:account1,\n                value: web3.utils.toWei('1', 'ether'),\n                data: web3.utils.toHex('I love you ,xiao man ju')\n            },async (err,address)=>  {\n                console.log(\"转账成功,address:\" + address);\n                b0 = await web3.eth.getBalance(account0);\n                b1 = await web3.eth.getBalance(account1);\n    \n                let tx = await web3.eth.getTransaction(address);\n                console.log('tx:'+ JSON.stringify(tx) +' 转账成功：address0:'+account0+':' + b0 + ' address1:'+account1+' account1:' + b1);\n            });\n           }\n    \n    testSend();\n    \n    ```\n\n4. 使用nodejs运行测试代码\n    ```\n    node EtherOnlieRinkebyTest.test.js\n    ```\n    输出结果如下：\n    ![](../images/未命名/getImage-20220825155544225.png)\n\n到此从开发到上传到访问以太坊rinkeby测试网络已经完成。\n\n\n# Nodejs测试框架\n上面我们测试一个node脚本是直接使用node命令直接运行，对于实际开发应用中如果想做到自动化测试用例的运行，需要用到类型java里面Junit测试框架的东西，这个东西在node里面叫Mocha\n\n1. 安装mocha\n    ```\n    npm install --save mocha\n    ```\n2. 修改`package.json`，将scripts.test改成`mocha`\n\n    ```\n    {\n      \"name\": \"blockchian1\",\n      \"version\": \"1.0.0\",\n      \"description\": \"\",\n      \"main\": \"app.js\",\n      \"directories\": {\n        \"test\": \"test\"\n      },\n      \"dependencies\": {\n        \"mocha\": \"^5.2.0\",\n        \"solc\": \"^0.4.25\"\n      },\n      \"devDependencies\": {},\n      \"scripts\": {\n        \"test\": \"mocha\"\n      },\n      \"author\": \"\",\n      \"license\": \"ISC\"\n    }\n    ```\n    > 配置了scripts.test 为mocha命令，`npm run test`访问的就是mocha的测框架\n3. mocha测试，`MochaTest.test.js`, describe就是基本的mocha测试骨架，it是测试用例\n\n    ```\n    const assert = require('assert');\n    /**\n     * ecs6 mocha测试\n     */\n    class Test {\n        say() {\n            return 'hello';\n        }\n    \n        happy() {\n            return 'haha';\n        }\n    }\n    \n    //开始写mocha测试框架\n    \n    let dog;\n    beforeEach(()=>{\n        dog = new Test();\n    })\n    \n    describe('第一个mocha测试用例',()=> {\n        it('测试hello()',()=>{\n            //const  dog = new Test();\n            let say = dog.say();\n            console.log(say);\n            assert.equal(say,'hello');\n    \n        })\n    \n        it('测试happy()',()=>{\n            let happy = dog.happy();\n            console.log(happy);\n            assert.equal(happy,'haha');\n        })\n    })\n    ```\n> 以上用到了assert组件，这个类似java里面的Assert断言，默认在node上下文已将安装，直接依赖使用即可\n\n4. 运行测试用例\n    ```\n    npm run test\n    ```\n    这个test访问的就是我们之前修改的`package.json`里面的test命令mocha，类似maven构建时的测试，它将运行项目上下文中的所有实现了mocha的测试用例","slug":"区块链/从零开始使用Solidity编写以太坊智能合约并使用Nodejs SDK访问以太坊网络","published":1,"updated":"2022-08-25T11:05:39.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczio000zvwm1f7ct0g6i","content":"<h1 id=\"Nodejs安装\"><a href=\"#Nodejs安装\" class=\"headerlink\" title=\"Nodejs安装\"></a>Nodejs安装</h1><p>Nodejs 版本建议8.0以上<br>官网：<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/en/</a><br>官网下载安装包:<a href=\"https://nodejs.org/dist/v8.12.0/node-v8.12.0-x64.msi\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/dist/v8.12.0/node-v8.12.0-x64.msi</a><br>安装参考：<a href=\"https://blog.csdn.net/qq_26562641/article/details/72235585\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_26562641/article/details/72235585</a></p>\n<p>配置淘宝镜像：</p>\n<pre><code>npm config set registry https://registry.npm.taobao.org</code></pre><h1 id=\"新建一个Hello-World只能合约的访问\"><a href=\"#新建一个Hello-World只能合约的访问\" class=\"headerlink\" title=\"新建一个Hello World只能合约的访问\"></a>新建一个Hello World只能合约的访问</h1><ol>\n<li><p>使用IDEA安装nodejs插件，在插件列表搜索</p>\n</li>\n<li><p>新建一个node工程项目，File&gt;New Project 选择Node.js and NPM<br><img src=\"../images/%E6%9C%AA%E5%91%BD%E5%90%8D/getImage-20220825155544126.png\" alt><br>默认有很多其他的目录，我们删除其他目录，只保留如下的目录：<br><img src=\"../images/%E6%9C%AA%E5%91%BD%E5%90%8D/getImage-20220825155543961.png\" alt><br>或者使用<code>npm init</code>命令初始化一个nodejs工程</p>\n</li>\n<li><p>安装solidity编译器依赖，用于编译Solidity，才能被nodejs使用到</p>\n<pre><code>npm install --save solc</code></pre></li>\n<li><p>安装以太坊的访问SDK web3.js</p>\n<pre><code> npm install --save web3</code></pre><p> 报错解决：</p>\n<blockquote>\n<ol>\n<li>报<code>gyp ERR! configure error\ngyp ERR! stack Error: Command failed: C:\\Users\\yan6\\AppData\\Local\\Programs\\Pytho\nn\\Python37-32\\python.EXE -c import sys; print &quot;%s.%s.%s&quot; % sys.version_info[:3];</code><br>原因：安装脚本中用到了Python2的语法，你的环境变量中配置的Python3所以报这个错<br>解决：修改python的环境变量，将Python3改成Python2，如果没有到官网下载一个Python2</li>\n<li>报<code>error MSB3428: 未能加载 Visual C++ 组件“VCBuild.exe”。要解决此问题，1)</code><pre><code>MSBUILD : error MSB3428: 未能加载 Visual C++ 组件“VCBuild.exe”。要解决此问题，1) 安装 .NET Framework 2.0 SDK；2) 安装 Microsoft Visual\nStudio 2005；或 3) 如果将\n该组件安装到了其他位置，请将其位置添加到系统路径中。 [D:\\workspace\\idea_workspace\\blockchian1\\node_modules\\scrypt\\build\\binding.sln]\nMSBUILD : error MSB3428: 未能加载 Visual C++ 组件“VCBuild.exe”。要解决此问题，1) 安装 .NET Framework 2.0 SDK；2) 安装 Microsoft Visual\nStudio 2005；或 3) 如果将\n该组件安装到了其他位置，请将其位置添加到系统路径中。 [D:\\workspace\\idea_workspace\\blockchian1\\node_modules\\scrypt\\build\\binding.sln]</code></pre>解决办法,按装全局windows相关组件：<pre><code>npm install --global --production windows-build-tools </code></pre></li>\n</ol>\n</blockquote>\n</li>\n<li><p>安装ganache,ganache是用来在本地测试用的测试以太坊网络</p>\n<pre><code> npm install -g ganache-cli</code></pre></li>\n<li><p>新建一个Solidity脚本，<code>Hello.sol</code></p>\n<pre><code> pragma solidity ^0.4.17;\n\n contract Hello {\n     string public name;\n\n     function Hello(string _name) public {\n         name = _name;\n     }\n\n     function setName(string _name) public {\n         name = _name;\n     }\n\n     function getName() public view returns(string ) {\n         return name;\n     }\n }\n</code></pre></li>\n<li><p>编写一个solidity的编译脚本compile.js</p>\n<pre><code> const path = require(&#39;path&#39;);\n const  fs = require(&#39;fs&#39;);\n\n const solc = require(&#39;solc&#39;);\n\n const srcpath = path.resolve(__dirname,&#39;contracts&#39;, &#39;Hello.sol&#39;);\n const source = fs.readFileSync(srcpath, &#39;utf-8&#39;);\n //console.log(source);\n\n const result = solc.compile(source,1);\n //console.log(result);\n module.exports = result.contracts[&#39;:Hello&#39;];</code></pre></li>\n<li><p>在tests下新建一个本地Hello World测试类,<code>Web3Test.test.js</code></p>\n<pre><code> const  assert = require(&#39;assert&#39;);\n //约定规范，如果变量是大写\n const Web3 = require(&#39;web3&#39;);\n //内存里面的以太坊测试环境\n const  ganache = require(&#39;ganache-cli&#39;);\n const web3 = new Web3(ganache.provider());\n\n //执行编译脚本，并将编译结果引入进来\n const {interface,bytecode} = require(&#39;../compile&#39;);\n\n /**\n  * 测试一个Hello World智能合约\n  * @returns {Promise.&lt;void&gt;}\n  */\n testGetSet = async ()=&gt; {\n     let accounts = await web3.eth.getAccounts();\n     //部署也是一个交易命令，所以需要花gas\n     const abi = JSON.parse(interface);\n     const contract = new web3.eth.Contract(abi);\n\n     const result = await contract.deploy({\n         data:bytecode,\n         arguments:[&#39;Hello World&#39;]\n     }).send({\n         from:accounts[0],\n         gas: 1500000,\n         gasPrice: &#39;30000&#39;\n     });\n     console.log(&#39;deploy success:&#39; + result.options.address);\n\n     //测试查询\n     assert.equal(await result.methods.getName().call(),&#39;Hello World&#39;);\n\n     await result.methods.setName(&#39;hahaha&#39;).send({\n         from:accounts[0],\n         gas:100000\n     });\n     assert.equal(await result.methods.getName().call(),&#39;hahaha&#39;);\n     console.log(&#39;测试智能合约成功&#39;);\n }\n\n</code></pre></li>\n</ol>\n<pre><code>/**\n * 测试以太坊转账\n * @returns {Promise.&lt;void&gt;}\n */\ntestTrade = async ()=&gt; {\n    let accounts = await web3.eth.getAccounts();\n    let b0 = await web3.eth.getBalance(accounts[0]);\n    let b1 = await web3.eth.getBalance(accounts[1]);\n    //发送交易\n    console.log(&#39;开始转账：account0:&#39; + b0 + &#39; account1:&#39; + b1);\n    await web3.eth.sendTransaction({\n        from:accounts[0],\n        to:accounts[1],\n        value:&#39;1000000000000000&#39;\n    });\n\n    b0 = await web3.eth.getBalance(accounts[0]);\n    b1 = await web3.eth.getBalance(accounts[1]);\n    //发送交易\n    console.log(&#39;转账成功：account0:&#39; + b0 + &#39; account1:&#39; + b1);\n}\n\ntestGetSet();\ntestTrade();\n\n```</code></pre><blockquote>\n<p>以上代码<code>const {interface,bytecode} = require(&#39;../compile&#39;);</code><br>这句话的意思是将Hello.sol编译后的导入到当前的node上下文，interface就是编译后的一些方法定义，bytecode就是最终部署到以太坊网络的二进制数据</p>\n</blockquote>\n<ol start=\"9\">\n<li>测试运行<pre><code> node `Web3Test.test.js</code></pre> 运行结果：<br> <img src=\"../images/%E6%9C%AA%E5%91%BD%E5%90%8D/getImage-20220825155544126-1414144.png\" alt></li>\n</ol>\n<h1 id=\"将代码提交到以太坊rankeby测试网络\"><a href=\"#将代码提交到以太坊rankeby测试网络\" class=\"headerlink\" title=\"将代码提交到以太坊rankeby测试网络\"></a>将代码提交到以太坊rankeby测试网络</h1><ol>\n<li><p>安装truffle-hdwallet-provider<br>组件官方文档：<a href=\"https://www.npmjs.com/package/truffle-hdwallet-provider\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/truffle-hdwallet-provider</a></p>\n<pre><code>  npm install truffle-hdwallet-provider</code></pre></li>\n<li><p>使用truffle-hdwallet-provider：</p>\n<pre><code> //线上的测试环境\n var HDWalletProvider = require(&quot;truffle-hdwallet-provider&quot;);\n var mnemonic = &quot;这里是你的以太坊钱包私钥助记词&quot;; // 12 word mnemonic\n //使用infura在线的provider\n var provider = new HDWalletProvider(mnemonic, &quot;https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5&quot;);\n const web3 = new Web3(provider);</code></pre><blockquote>\n<p>上面用到的provider_url：<a href=\"https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5是infura的在线url,到https://rinkeby.infura.io注册一个账号并添加一个rinkeby的测试PROJECT就可以得到一个测试provider_url了，网络不好可能需要翻墙\" target=\"_blank\" rel=\"noopener\">https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5是infura的在线url,到https://rinkeby.infura.io注册一个账号并添加一个rinkeby的测试PROJECT就可以得到一个测试provider_url了，网络不好可能需要翻墙</a></p>\n</blockquote>\n</li>\n<li><p>新增一个测试代码进行测试交易,<code>EtherOnlieRinkebyTest.test.js</code></p>\n<pre><code> //约定规范，如果变量是大写\n const Web3 = require(&#39;web3&#39;);\n\n //线上的测试环境\n var HDWalletProvider = require(&quot;truffle-hdwallet-provider&quot;);\n var mnemonic = &quot;这里是你的以太坊钱包私钥助记词&quot;; // 12 word mnemonic\n //使用infura在线的provider\n var provider = new HDWalletProvider(mnemonic, &quot;https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5&quot;);\n const web3 = new Web3(provider);\n\n /**\n  * 测试web3\n  */\n testSend = async ()=&gt; {\n\n         let accounts = await web3.eth.getAccounts();\n\n         console.log(accounts);\n         let account0 = accounts[0];\n         let account1 = &#39;0x5828eb46D40795Da76429553845DfA622F062CB2&#39;;\n\n         let b0 = await web3.eth.getBalance(account0);\n         let b1 = await web3.eth.getBalance(account1);\n         console.log(&#39;开始转账：address0:&#39; + account0 + &#39; :&#39; + b0 + &#39; address1:&#39;+account1 + &#39; account1:&#39; + b1);\n         const tx = web3.eth.sendTransaction({\n             from:account0,\n             to:account1,\n             value: web3.utils.toWei(&#39;1&#39;, &#39;ether&#39;),\n             data: web3.utils.toHex(&#39;I love you ,xiao man ju&#39;)\n         },async (err,address)=&gt;  {\n             console.log(&quot;转账成功,address:&quot; + address);\n             b0 = await web3.eth.getBalance(account0);\n             b1 = await web3.eth.getBalance(account1);\n\n             let tx = await web3.eth.getTransaction(address);\n             console.log(&#39;tx:&#39;+ JSON.stringify(tx) +&#39; 转账成功：address0:&#39;+account0+&#39;:&#39; + b0 + &#39; address1:&#39;+account1+&#39; account1:&#39; + b1);\n         });\n        }\n\n testSend();\n</code></pre></li>\n<li><p>使用nodejs运行测试代码</p>\n<pre><code> node EtherOnlieRinkebyTest.test.js</code></pre><p> 输出结果如下：<br> <img src=\"../images/%E6%9C%AA%E5%91%BD%E5%90%8D/getImage-20220825155544225.png\" alt></p>\n</li>\n</ol>\n<p>到此从开发到上传到访问以太坊rinkeby测试网络已经完成。</p>\n<h1 id=\"Nodejs测试框架\"><a href=\"#Nodejs测试框架\" class=\"headerlink\" title=\"Nodejs测试框架\"></a>Nodejs测试框架</h1><p>上面我们测试一个node脚本是直接使用node命令直接运行，对于实际开发应用中如果想做到自动化测试用例的运行，需要用到类型java里面Junit测试框架的东西，这个东西在node里面叫Mocha</p>\n<ol>\n<li><p>安装mocha</p>\n<pre><code> npm install --save mocha</code></pre></li>\n<li><p>修改<code>package.json</code>，将scripts.test改成<code>mocha</code></p>\n<pre><code> {\n   &quot;name&quot;: &quot;blockchian1&quot;,\n   &quot;version&quot;: &quot;1.0.0&quot;,\n   &quot;description&quot;: &quot;&quot;,\n   &quot;main&quot;: &quot;app.js&quot;,\n   &quot;directories&quot;: {\n     &quot;test&quot;: &quot;test&quot;\n   },\n   &quot;dependencies&quot;: {\n     &quot;mocha&quot;: &quot;^5.2.0&quot;,\n     &quot;solc&quot;: &quot;^0.4.25&quot;\n   },\n   &quot;devDependencies&quot;: {},\n   &quot;scripts&quot;: {\n     &quot;test&quot;: &quot;mocha&quot;\n   },\n   &quot;author&quot;: &quot;&quot;,\n   &quot;license&quot;: &quot;ISC&quot;\n }</code></pre><blockquote>\n<p>配置了scripts.test 为mocha命令，<code>npm run test</code>访问的就是mocha的测框架</p>\n</blockquote>\n</li>\n<li><p>mocha测试，<code>MochaTest.test.js</code>, describe就是基本的mocha测试骨架，it是测试用例</p>\n<pre><code> const assert = require(&#39;assert&#39;);\n /**\n  * ecs6 mocha测试\n  */\n class Test {\n     say() {\n         return &#39;hello&#39;;\n     }\n\n     happy() {\n         return &#39;haha&#39;;\n     }\n }\n\n //开始写mocha测试框架\n\n let dog;\n beforeEach(()=&gt;{\n     dog = new Test();\n })\n\n describe(&#39;第一个mocha测试用例&#39;,()=&gt; {\n     it(&#39;测试hello()&#39;,()=&gt;{\n         //const  dog = new Test();\n         let say = dog.say();\n         console.log(say);\n         assert.equal(say,&#39;hello&#39;);\n\n     })\n\n     it(&#39;测试happy()&#39;,()=&gt;{\n         let happy = dog.happy();\n         console.log(happy);\n         assert.equal(happy,&#39;haha&#39;);\n     })\n })</code></pre><blockquote>\n<p>以上用到了assert组件，这个类似java里面的Assert断言，默认在node上下文已将安装，直接依赖使用即可</p>\n</blockquote>\n</li>\n<li><p>运行测试用例</p>\n<pre><code> npm run test</code></pre><p> 这个test访问的就是我们之前修改的<code>package.json</code>里面的test命令mocha，类似maven构建时的测试，它将运行项目上下文中的所有实现了mocha的测试用例</p>\n</li>\n</ol>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"Nodejs安装\"><a href=\"#Nodejs安装\" class=\"headerlink\" title=\"Nodejs安装\"></a>Nodejs安装</h1><p>Nodejs 版本建议8.0以上<br>官网：<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/en/</a><br>官网下载安装包:<a href=\"https://nodejs.org/dist/v8.12.0/node-v8.12.0-x64.msi\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/dist/v8.12.0/node-v8.12.0-x64.msi</a><br>安装参考：<a href=\"https://blog.csdn.net/qq_26562641/article/details/72235585\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_26562641/article/details/72235585</a></p>\n<p>配置淘宝镜像：</p>\n<pre><code>npm config set registry https://registry.npm.taobao.org</code></pre><h1 id=\"新建一个Hello-World只能合约的访问\"><a href=\"#新建一个Hello-World只能合约的访问\" class=\"headerlink\" title=\"新建一个Hello World只能合约的访问\"></a>新建一个Hello World只能合约的访问</h1><ol>\n<li><p>使用IDEA安装nodejs插件，在插件列表搜索</p>\n</li>\n<li><p>新建一个node工程项目，File&gt;New Project 选择Node.js and NPM<br><img src=\"../images/%E6%9C%AA%E5%91%BD%E5%90%8D/getImage-20220825155544126.png\" alt><br>默认有很多其他的目录，我们删除其他目录，只保留如下的目录：<br><img src=\"../images/%E6%9C%AA%E5%91%BD%E5%90%8D/getImage-20220825155543961.png\" alt><br>或者使用<code>npm init</code>命令初始化一个nodejs工程</p>\n</li>\n<li><p>安装solidity编译器依赖，用于编译Solidity，才能被nodejs使用到</p>\n<pre><code>npm install --save solc</code></pre></li>\n<li><p>安装以太坊的访问SDK web3.js</p>\n<pre><code> npm install --save web3</code></pre><p> 报错解决：</p>\n<blockquote>\n<ol>\n<li>报<code>gyp ERR! configure error\ngyp ERR! stack Error: Command failed: C:\\Users\\yan6\\AppData\\Local\\Programs\\Pytho\nn\\Python37-32\\python.EXE -c import sys; print &quot;%s.%s.%s&quot; % sys.version_info[:3];</code><br>原因：安装脚本中用到了Python2的语法，你的环境变量中配置的Python3所以报这个错<br>解决：修改python的环境变量，将Python3改成Python2，如果没有到官网下载一个Python2</li>\n<li>报<code>error MSB3428: 未能加载 Visual C++ 组件“VCBuild.exe”。要解决此问题，1)</code><pre><code>MSBUILD : error MSB3428: 未能加载 Visual C++ 组件“VCBuild.exe”。要解决此问题，1) 安装 .NET Framework 2.0 SDK；2) 安装 Microsoft Visual\nStudio 2005；或 3) 如果将\n该组件安装到了其他位置，请将其位置添加到系统路径中。 [D:\\workspace\\idea_workspace\\blockchian1\\node_modules\\scrypt\\build\\binding.sln]\nMSBUILD : error MSB3428: 未能加载 Visual C++ 组件“VCBuild.exe”。要解决此问题，1) 安装 .NET Framework 2.0 SDK；2) 安装 Microsoft Visual\nStudio 2005；或 3) 如果将\n该组件安装到了其他位置，请将其位置添加到系统路径中。 [D:\\workspace\\idea_workspace\\blockchian1\\node_modules\\scrypt\\build\\binding.sln]</code></pre>解决办法,按装全局windows相关组件：<pre><code>npm install --global --production windows-build-tools </code></pre></li>\n</ol>\n</blockquote>\n</li>\n<li><p>安装ganache,ganache是用来在本地测试用的测试以太坊网络</p>\n<pre><code> npm install -g ganache-cli</code></pre></li>\n<li><p>新建一个Solidity脚本，<code>Hello.sol</code></p>\n<pre><code> pragma solidity ^0.4.17;\n\n contract Hello {\n     string public name;\n\n     function Hello(string _name) public {\n         name = _name;\n     }\n\n     function setName(string _name) public {\n         name = _name;\n     }\n\n     function getName() public view returns(string ) {\n         return name;\n     }\n }\n</code></pre></li>\n<li><p>编写一个solidity的编译脚本compile.js</p>\n<pre><code> const path = require(&#39;path&#39;);\n const  fs = require(&#39;fs&#39;);\n\n const solc = require(&#39;solc&#39;);\n\n const srcpath = path.resolve(__dirname,&#39;contracts&#39;, &#39;Hello.sol&#39;);\n const source = fs.readFileSync(srcpath, &#39;utf-8&#39;);\n //console.log(source);\n\n const result = solc.compile(source,1);\n //console.log(result);\n module.exports = result.contracts[&#39;:Hello&#39;];</code></pre></li>\n<li><p>在tests下新建一个本地Hello World测试类,<code>Web3Test.test.js</code></p>\n<pre><code> const  assert = require(&#39;assert&#39;);\n //约定规范，如果变量是大写\n const Web3 = require(&#39;web3&#39;);\n //内存里面的以太坊测试环境\n const  ganache = require(&#39;ganache-cli&#39;);\n const web3 = new Web3(ganache.provider());\n\n //执行编译脚本，并将编译结果引入进来\n const {interface,bytecode} = require(&#39;../compile&#39;);\n\n /**\n  * 测试一个Hello World智能合约\n  * @returns {Promise.&lt;void&gt;}\n  */\n testGetSet = async ()=&gt; {\n     let accounts = await web3.eth.getAccounts();\n     //部署也是一个交易命令，所以需要花gas\n     const abi = JSON.parse(interface);\n     const contract = new web3.eth.Contract(abi);\n\n     const result = await contract.deploy({\n         data:bytecode,\n         arguments:[&#39;Hello World&#39;]\n     }).send({\n         from:accounts[0],\n         gas: 1500000,\n         gasPrice: &#39;30000&#39;\n     });\n     console.log(&#39;deploy success:&#39; + result.options.address);\n\n     //测试查询\n     assert.equal(await result.methods.getName().call(),&#39;Hello World&#39;);\n\n     await result.methods.setName(&#39;hahaha&#39;).send({\n         from:accounts[0],\n         gas:100000\n     });\n     assert.equal(await result.methods.getName().call(),&#39;hahaha&#39;);\n     console.log(&#39;测试智能合约成功&#39;);\n }\n\n</code></pre></li>\n</ol>\n<pre><code>/**\n * 测试以太坊转账\n * @returns {Promise.&lt;void&gt;}\n */\ntestTrade = async ()=&gt; {\n    let accounts = await web3.eth.getAccounts();\n    let b0 = await web3.eth.getBalance(accounts[0]);\n    let b1 = await web3.eth.getBalance(accounts[1]);\n    //发送交易\n    console.log(&#39;开始转账：account0:&#39; + b0 + &#39; account1:&#39; + b1);\n    await web3.eth.sendTransaction({\n        from:accounts[0],\n        to:accounts[1],\n        value:&#39;1000000000000000&#39;\n    });\n\n    b0 = await web3.eth.getBalance(accounts[0]);\n    b1 = await web3.eth.getBalance(accounts[1]);\n    //发送交易\n    console.log(&#39;转账成功：account0:&#39; + b0 + &#39; account1:&#39; + b1);\n}\n\ntestGetSet();\ntestTrade();\n\n```</code></pre><blockquote>\n<p>以上代码<code>const {interface,bytecode} = require(&#39;../compile&#39;);</code><br>这句话的意思是将Hello.sol编译后的导入到当前的node上下文，interface就是编译后的一些方法定义，bytecode就是最终部署到以太坊网络的二进制数据</p>\n</blockquote>\n<ol start=\"9\">\n<li>测试运行<pre><code> node `Web3Test.test.js</code></pre> 运行结果：<br> <img src=\"../images/%E6%9C%AA%E5%91%BD%E5%90%8D/getImage-20220825155544126-1414144.png\" alt></li>\n</ol>\n<h1 id=\"将代码提交到以太坊rankeby测试网络\"><a href=\"#将代码提交到以太坊rankeby测试网络\" class=\"headerlink\" title=\"将代码提交到以太坊rankeby测试网络\"></a>将代码提交到以太坊rankeby测试网络</h1><ol>\n<li><p>安装truffle-hdwallet-provider<br>组件官方文档：<a href=\"https://www.npmjs.com/package/truffle-hdwallet-provider\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/truffle-hdwallet-provider</a></p>\n<pre><code>  npm install truffle-hdwallet-provider</code></pre></li>\n<li><p>使用truffle-hdwallet-provider：</p>\n<pre><code> //线上的测试环境\n var HDWalletProvider = require(&quot;truffle-hdwallet-provider&quot;);\n var mnemonic = &quot;这里是你的以太坊钱包私钥助记词&quot;; // 12 word mnemonic\n //使用infura在线的provider\n var provider = new HDWalletProvider(mnemonic, &quot;https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5&quot;);\n const web3 = new Web3(provider);</code></pre><blockquote>\n<p>上面用到的provider_url：<a href=\"https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5是infura的在线url,到https://rinkeby.infura.io注册一个账号并添加一个rinkeby的测试PROJECT就可以得到一个测试provider_url了，网络不好可能需要翻墙\" target=\"_blank\" rel=\"noopener\">https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5是infura的在线url,到https://rinkeby.infura.io注册一个账号并添加一个rinkeby的测试PROJECT就可以得到一个测试provider_url了，网络不好可能需要翻墙</a></p>\n</blockquote>\n</li>\n<li><p>新增一个测试代码进行测试交易,<code>EtherOnlieRinkebyTest.test.js</code></p>\n<pre><code> //约定规范，如果变量是大写\n const Web3 = require(&#39;web3&#39;);\n\n //线上的测试环境\n var HDWalletProvider = require(&quot;truffle-hdwallet-provider&quot;);\n var mnemonic = &quot;这里是你的以太坊钱包私钥助记词&quot;; // 12 word mnemonic\n //使用infura在线的provider\n var provider = new HDWalletProvider(mnemonic, &quot;https://rinkeby.infura.io/v3/02b9371103e54ed6bb4ccb91651497f5&quot;);\n const web3 = new Web3(provider);\n\n /**\n  * 测试web3\n  */\n testSend = async ()=&gt; {\n\n         let accounts = await web3.eth.getAccounts();\n\n         console.log(accounts);\n         let account0 = accounts[0];\n         let account1 = &#39;0x5828eb46D40795Da76429553845DfA622F062CB2&#39;;\n\n         let b0 = await web3.eth.getBalance(account0);\n         let b1 = await web3.eth.getBalance(account1);\n         console.log(&#39;开始转账：address0:&#39; + account0 + &#39; :&#39; + b0 + &#39; address1:&#39;+account1 + &#39; account1:&#39; + b1);\n         const tx = web3.eth.sendTransaction({\n             from:account0,\n             to:account1,\n             value: web3.utils.toWei(&#39;1&#39;, &#39;ether&#39;),\n             data: web3.utils.toHex(&#39;I love you ,xiao man ju&#39;)\n         },async (err,address)=&gt;  {\n             console.log(&quot;转账成功,address:&quot; + address);\n             b0 = await web3.eth.getBalance(account0);\n             b1 = await web3.eth.getBalance(account1);\n\n             let tx = await web3.eth.getTransaction(address);\n             console.log(&#39;tx:&#39;+ JSON.stringify(tx) +&#39; 转账成功：address0:&#39;+account0+&#39;:&#39; + b0 + &#39; address1:&#39;+account1+&#39; account1:&#39; + b1);\n         });\n        }\n\n testSend();\n</code></pre></li>\n<li><p>使用nodejs运行测试代码</p>\n<pre><code> node EtherOnlieRinkebyTest.test.js</code></pre><p> 输出结果如下：<br> <img src=\"../images/%E6%9C%AA%E5%91%BD%E5%90%8D/getImage-20220825155544225.png\" alt></p>\n</li>\n</ol>\n<p>到此从开发到上传到访问以太坊rinkeby测试网络已经完成。</p>\n<h1 id=\"Nodejs测试框架\"><a href=\"#Nodejs测试框架\" class=\"headerlink\" title=\"Nodejs测试框架\"></a>Nodejs测试框架</h1><p>上面我们测试一个node脚本是直接使用node命令直接运行，对于实际开发应用中如果想做到自动化测试用例的运行，需要用到类型java里面Junit测试框架的东西，这个东西在node里面叫Mocha</p>\n<ol>\n<li><p>安装mocha</p>\n<pre><code> npm install --save mocha</code></pre></li>\n<li><p>修改<code>package.json</code>，将scripts.test改成<code>mocha</code></p>\n<pre><code> {\n   &quot;name&quot;: &quot;blockchian1&quot;,\n   &quot;version&quot;: &quot;1.0.0&quot;,\n   &quot;description&quot;: &quot;&quot;,\n   &quot;main&quot;: &quot;app.js&quot;,\n   &quot;directories&quot;: {\n     &quot;test&quot;: &quot;test&quot;\n   },\n   &quot;dependencies&quot;: {\n     &quot;mocha&quot;: &quot;^5.2.0&quot;,\n     &quot;solc&quot;: &quot;^0.4.25&quot;\n   },\n   &quot;devDependencies&quot;: {},\n   &quot;scripts&quot;: {\n     &quot;test&quot;: &quot;mocha&quot;\n   },\n   &quot;author&quot;: &quot;&quot;,\n   &quot;license&quot;: &quot;ISC&quot;\n }</code></pre><blockquote>\n<p>配置了scripts.test 为mocha命令，<code>npm run test</code>访问的就是mocha的测框架</p>\n</blockquote>\n</li>\n<li><p>mocha测试，<code>MochaTest.test.js</code>, describe就是基本的mocha测试骨架，it是测试用例</p>\n<pre><code> const assert = require(&#39;assert&#39;);\n /**\n  * ecs6 mocha测试\n  */\n class Test {\n     say() {\n         return &#39;hello&#39;;\n     }\n\n     happy() {\n         return &#39;haha&#39;;\n     }\n }\n\n //开始写mocha测试框架\n\n let dog;\n beforeEach(()=&gt;{\n     dog = new Test();\n })\n\n describe(&#39;第一个mocha测试用例&#39;,()=&gt; {\n     it(&#39;测试hello()&#39;,()=&gt;{\n         //const  dog = new Test();\n         let say = dog.say();\n         console.log(say);\n         assert.equal(say,&#39;hello&#39;);\n\n     })\n\n     it(&#39;测试happy()&#39;,()=&gt;{\n         let happy = dog.happy();\n         console.log(happy);\n         assert.equal(happy,&#39;haha&#39;);\n     })\n })</code></pre><blockquote>\n<p>以上用到了assert组件，这个类似java里面的Assert断言，默认在node上下文已将安装，直接依赖使用即可</p>\n</blockquote>\n</li>\n<li><p>运行测试用例</p>\n<pre><code> npm run test</code></pre><p> 这个test访问的就是我们之前修改的<code>package.json</code>里面的test命令mocha，类似maven构建时的测试，它将运行项目上下文中的所有实现了mocha的测试用例</p>\n</li>\n</ol>\n"},{"title":"区块链技术之比特币运作原理","date":"2019-08-21T01:25:00.000Z","author":"okeeper","top":true,"toc":true,"_content":"\n# 什么是比特币\n点对点的传输的一个去中心化的电子现金系统。每个节点都共同维护一个区块链形式存储的交易记录，每个比特币节点遵守同一个比特币网络协议，并基于密码学原理加密每一笔交易记录和区块，实现每一笔交易不可逆、防篡改、去中心化的、数据可监管溯源的电子现金交易系统。\n## 比特币特点\n- 比特币最初由中本聪2008年发明\n- 比特币发行和交易不依赖中央机构\n- 比特币的发行总量不会超过2100万个\n- 只要能够联网，安装比特币客户端，任何人都能接入到这个比特币网络\n- 比特币的账户地址是匿名的\n- 任何国家或者机构无法监管或者操纵这个比特币网络\n- 比特币是基于现代密码学实现的点对点交易的分布式超级账本\n\n# 比特币行情\n比特币从诞生以来已经翻了好几万倍了，比特币的第一笔交易是一个程序员用50btc买了披萨，第一批持有比特币的人估计早已经是千万富翁，但是神奇的比特币之父中本聪的创始区块及它的账户的其他比特币都还没有发生转账交易。\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508680.png)\n# 区中心化的比特币网络\n![](../images/区块链技术之比特币运作原理/getImage.png)\n\n这个比特币网络大致是这个样子的，节点分为以下几类：\n- 全数据节点：保存了完整的区块链所有交易信息\n- 矿工节点：负责打包新的交易数据制作新的区块\n- 轻客户端节钱包节点：只保留自己关心交易数据\n\n# 什么是区块链\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508350.png)\n区块链有以下几个特点：\n- 区块链本质是一个分布式的超级账本，整个比特币网络各个节点仅仅认可和维护记录一样且长度最长的区块链\n- 每个区块由区块头（上一个区块的hash值，当前区块的高度，出块的时间等）+ 交易记录列表 组成\n- 所有经过验证符合比特币协议的交易记录都会被“矿工”打包进新的区块，然后广播给所有其它节点。\n\n每一个新的区块的都有一个指向上一个区块的hash值，所以这条链被形象的称之为**区块链**\n\n# 什么是挖矿\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508575.png)\n上图是传统的煤矿挖矿的矿工，比特币的“挖矿”当然不是这个挖矿。\n比特币的挖矿是指：将接收到全网的交易记录打包制作到一个新区块并广播至其它节点的过程，由于这个过程通常不是那么容易，需要不停的hash计算符合标准的随机数才能生效新区块，平均全网每10分钟才能有计算出这样的随机数，所以形象的形容为比特币的“挖矿”\n\n## 挖矿的原理\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508972.png)\n挖矿的过程如下：\n1. 每个矿工节点都共同监听最新的交易数据，并做合法性校验，将符合校验的交易打包进新的区块中\n2. 在新的区块中添加给矿工账户转账的一笔交易，给矿工自己加上相应的比特币奖励和交易记录收取的手续费\n3. 最后一步用新区块的所有内容+一个随机数做SHA-256计算出hash值，使得这个hash值的二进制数符合一定规则，才能向全网广播这个新的区块\n\n那么接下来我们思考下以下三个问题：\n1. 整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？\n2. 这种“苦力活”如果没人做怎么办？\n3. 如果这个矿工“不老实”怎么办？\n\n### 1. 整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508157.png)\n在比特币的协议中规定，给挖矿过程增加了一定的难度，使得矿工挖矿并不是那么容易，一般是全网的所有矿工节点的所有算力一起计算10分钟才能制作出一个合法的新区块。\n有了这个规定，这个比特币网络就有充足的时间让大部分节点同步最新的区块数据，而减少并发问题。这个挖矿的难度在比特币中就叫工作量证明机制（Proof-of-Work，PoW）。\n\n刚刚提到的10分钟，为什么是10分钟，是怎么保证的？\n\n先来回答下为什么是10分钟，而不是15分钟、2分钟、8分钟，中本聪在设计比特币机制时，考虑到新区块数据在全世界节点的广播同步有一定的网络延迟，于是为了尽量避免“矿工A和矿工B在不知道对方都计算出结果的情况下同时发送计算结果”的事情，规定了制作新区款的难度，这个难度难到平均每个矿工需要花10分钟挖出一个区块，于是设计了一个这样的值：理论平均出块时间=10分钟。至于为什么是10分钟，那总得取一个值吧，综合考量就定了10分钟。\n\n是怎么保证全网的平均出块时间一直保证在10分钟，不会随着计算能力的提升，就不需要10分钟了吗？\n\n比特币规定，每挖完2016个区块，数学题的难度会自动的根据这2016个区块的实际挖出时间，动态地做出调整。\n\n也就是说，每2016个区块的难度都是一样的，接下来的2016个区块的难度，根据前2016个区块的难度以及前2016个区块的整体实际挖矿时间综合决定，这里有个计算公式如下：\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508078.png)\n可以看出10分钟不是绝对值，有的矿工可能运气好一些、3分钟、5分钟就能找到符合标准的新区块，有的矿工运气差一些，可能需要20分钟、30分钟才能找到符合标准的新区块，由于有了这个标准的动态调整，总能保证全网的平均出块时间在10分钟左右。\n具体这个难度是什么，我们看下面公式：\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508135.png)\n而上面的这个目标值b就是和挖矿难度系数有关的值，目前的难度就是SHA-256【制作新区款的所有内容+一个随机数】的hash值的二进制值至少前72位为零，也就是最坏的结果是至少需要计算2^72次才能找到这个随机数，你可以认为这个72就是一个难度系数值\n\n\n有了这个工作量证明机制就能保证一定全网在同一时刻只有一个矿工制作成符合标准的新区块吗，答案是否定的，那么如果出现这个情况，比特币网络是怎么处理的？\n\nE矿工和F矿工分别基于d区块制作出了新的区块并广播至其他节点，如下图：\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508546.png)\n\n同时收到e区块和f区块的节点会先同时保留这些区块，直到下一个区块基于其中一个区块制作出更长的区块链\n\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508291.png)\n\n比特币协议规定只保留最长的区块链，较短的支链中的交易记录重新变为待确认交易重新发送至矿工节点作确认\n\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508312.png)\n\n如果下一个区块碰巧又分别有两个新的区块基于e区块和f区块制作新区块，比特币网络的做法和上面的是一样的，先同时保留这些支链，直到最长的区块链出现，较短的区块的交易记录变为待确认交易重新发送至别人矿工节点。\n\n###  2. 这种“苦力活”如果没人做怎么办？\n比特币网络规定每成功生成一个新的区块，给相应的BTC给矿工账号作为奖励，并将新区块中的交易的手续费也归矿工所有，通过这个奖励机制大家就很乐意去干这个“苦力活”了。\n\n这个奖励最初是50比特币，今后每产生21万个区块，比特币数量都会依次减半。直到第33次减半时，每个块产生0.0021个新比特币直接减为0个，最终比特币总量维持在2100万个。我们知道比特币大约每10分钟产生一个区块，而21万个10分钟接近4年。\n最终这个比特币网络的矿工只能通过收取交易的手续费来维持他们的成本和收益\n这个交易的手续费是可以交易方自己定的\n但是矿工有权利优先选择手续费较高的记账或者拒绝，只要矿工们达成共识。\n\n## 挖矿工具——矿机\n挖矿的矿机从最初的使用PC个人电脑挖矿到专业的挖矿矿池，算力变得越来越强，挖矿的成本也越来越高，门槛越来越高。\n**CPU挖矿→GPU挖矿→专业矿机挖矿→矿池挖矿**\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508408.png)\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508413.png)\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508512.png)\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508831.png)\n# 比特币是如何进行交易的\n\n比特币交易符合以下几个特点：\n- 交易数据包含交易输入和交易输出，其中交易输入的金额总和必须>=输出金额总和\n- 挖矿奖励属于一个特殊的交易（称为coinbase交易），可以没有输入。\n- 在比特币没有余额概念，只有分散到区块链里的UTXO（未花费交易记录）\n- UTXO是交易的基本单元，不能在分割。\n\n## 比特币转账\n比特币的交易记录主要由以下几部分组成：\n- 交易的输入，是指向上一笔交易的hash值\n- 交易的输入解锁脚本，能够证明这笔钱你有权动用\n- 交易的输出，交易的输出对方账户\n- 交易输出的加锁脚本，是的对方必须提供证明是转给他的，才有权动用\n\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508663.png)\n上表格中：\n记录1是个特殊的交易记录，是比特币矿工的奖励记录，给A账户转账10BTC，所以没有交易输入，这个交易记录叫coinbase\n记录2:A使用记录1转给他的钱用来支付给B,并加锁这个转账\n记录3：B收到这个转账时，提供自己的签名和公钥，证明确实是转给他的，B再用这笔转账支付10BTC给C\n\n从上面的交易得知，**我们把以上交易记录中可以用来当下一笔交易的未使用记录，称之为未花费记录（UTXO）**\n\n\n我们再来看下面这个记录：\n![](../images/区块链技术之比特币运作原理/getImage-20220824120509067.png)\n\n记录2中A需要支付5BTC给B，但是交易输入记录1是10BTC的，所以将自己的账户添加到交易输出中找回5BTC\n\n记录4由于A需要支付10BTC，所以交易输入是两笔5BTC的交易记录。\n\n从上面的交易可以看出,**比特币系统中没有账户的概念，只有交易记录，一笔未花费交易记录不能拆开使用，如果要只需花费一部分，通过在交易输出添加一笔给自己转账的记录，类似现金找零。**\n\n### 如何防止同一笔前用两次\n\nA账号用【记录1】当做输入支付给10BTC给“B账号”，接着又用【记录1】当做输入支付给10BTC给“C账号”,\n相当于10BTC用了两次。如下图：\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508784.png)\n\n我们分情况来看同一笔交易输入支付给了不同的人：\n**情况1：**两条交易记录打包在同一个区块中：那么以先收到的交易是合法的，后收到的交易是非法的\n**情况2：**两条交易记录先后被打包进不同区块的同一主链中：那么当矿工验证交易合法性时，是从以往合法的所有区块的所有交易中查找验证的，先收到的交易是合法的，后收到的是非法的\n**情况2：**两条交易记录先后被打包进不同区块的不同支链中：\nA矿工在之前主链基础上制作新区款，先收到交易1；\nB矿工在之前主链基础上制作新区款，先收到交易2。\n那么矿工在做合法性验证时都认为是合法的，此时比特币网络发生分叉，随着之后新区款制作，根据比特币协议规定，将保留区块长度最长的链，较短的支链将丢弃，其中的交易记录重新变为未确认交易等待下一个新区块的合法性校验，此时校验不通过的交易将丢弃。\n\n\n## 真实的比特币交易数据的结构\n```\n{\n   \"lock_time\":0,\n   \"size\":259,\n   \"version\":1,\n   \"vin_sz\":1,\n   “hash”:“2514161c059ac18bf2eff1e05c4628e322d846e930fd6dd4b24805ea59dc4913”,//这笔交易的ID\n   \"vout_sz\":2,\n   “inputs”:[//这笔交易的的来源交易，也称输入交易，可能有多个\n      {\n         \"prev_out\":{\n\t\t“hash”:“4f40655c4ab1a029bc41bc547f79556a0dc48d22df7202778fad592791c77fcd”,//上一笔交易的交易ID\n\t\t“index”:0 //在上一笔交易的输出列表的下标位置\n         },\n         “script”:“493046022100cd6795ebcd1b6b87833a4ad812733d3804065d34bafee24da181a770892272b902210088cd2484952ad2572f9bfb2874643dbb4b3c492b749e79d8177a14eb4a3bc61a014104bbf2b84900b6f898548687aefba86cc06da6f4656a71e45fa55128b501455b5486cb09705cfa23c1899fe46d4355c9058bb2de4f1a7f1a01ff27e00b306f7356” //解锁上一笔交易输出的参数\n      }\n   ],\n    “out”:[//这笔交易的交易对手方，也称交易输出，也可以有多个\n      {\n\t   //交易输出的锁定脚本，只有交易对方提供正确的自己的签名及公钥才能证明这笔钱是转给他的，才有资格进行下一次的转账交易\n         “script_string”:“OP_DUP OP_HASH160 f9d49c5cf3e120ad1be60b67d868603a8fc945d2 OP_EQUALVERIFY OP_CHECKSIG”,\n         \"address\":\"1PmyxDv5VvGoSAKMr1DQcWB6sHPx1ZbgWe\",\n         “value”:88994500000,//转多少钱，单位是聪，1亿聪=1BTC\n         \"script\":\"76a914f9d49c5cf3e120ad1be60b67d868603a8fc945d288ac\"\n      },\n      {\n         \"script_string\":\"OP_DUP OP_HASH160 088465c1f0c8b3b3da06f7073a921d6b95b22f49 OP_EQUALVERIFY OP_CHECKSIG\",\n         \"address\":\"1n31g4rKiEeXnZEZR6VZwm3LggLicEqEC\",\n         \"value\":1000000000,\n         \"script\":\"76a914088465c1f0c8b3b3da06f7073a921d6b95b22f4988ac\"\n      }\n   ]\n}\n```\n\n## 比特币的脚本语言\n\n```\nOP_DUP OP_HASH160 f9d49c5cf3e120ad1be60b67d868603a8fc945d2 OP_EQUALVERIFY OP_CHECKSIG\n```\n上面是比特币交易中的交易输入解锁脚本，输入两个参数：<sig> <PubK> 使得<PubK>的HASH160值等于9d49c5cf3e120ad1be60b67d868603a8fc945d2，接着使用<PubK>验证<sig>签名，验证同步则表示该交易输入合法有效，就像用户名密码一样。\n\n比特币脚本语言是非图灵完备脚本语言，就是说它不能实现复杂的逻辑。\n比特币脚本语言的执行是遵循先进后出的原因，即它的变量读取是堆栈式，如下图：\n\n![](../images/区块链技术之比特币运作原理/getImage-20220824120509028.png)\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508906.png)\n## 最终的结构\n比特币就是通过每一个区块都有上一个区块的指正，每个区块中包含通过验证的合法交易组成的链式结构，并让所有节点同步这份数据，形成不可逆，串改成本巨大的分布式超级账本，称之为区块链\n![](../images/区块链技术之比特币运作原理/getImage-20220824120509220.png)\n\n# 比特币的价值及存在问题\n比特币的价值在于，金融危机发生的时候，货币超发，法币贬值，社会财富缩水；\n而比特币不依赖中央机构管理，期价值完全由供给关系决定，\n当旧的法定货币崩溃时，人们便会涌向比特币，把比特币作为新的资产避风港——“21世纪版的黄金”\n比特币是目前区块链技术落地最成功的项目，虽然比特币目前实际用的更多的是黑产（赌博、洗钱、黑客敲诈、传销），但是开创了人们对区块链技术无限探索和想象；\n\n但同样存在着问题：\n- 由于有新区块难度限制，每秒处理交易数不足7/sec，交易确认时间长大几小时甚至几天交易确认时间长大几小时甚至几天\n- 巨大的能源消耗（这也是比特币防篡改的代价）\n- 随着计算机算力的提升，构建数字货币的密码学可能会被攻破\n- 投机性强，泡沫大\n- 算力集中，随着挖矿难度增加，只有少数几个矿池能够维持挖矿成本，失去去中心化初衷\n\n# 区块链的应用\n基于区块链的记录不可逆、去中心化、全民监管的特点来构建一个信任网络，降低\n社会协同合作成本，主要应用如下：\n- 企业融资：企业可以通过发行代币的方式对投资者承诺未来能够通过代币购买\n- 公共实物：居于区块链上的登记的信息不可篡改，能够很方便的证明你的信息合法性\n- 公益：在当前大环境下，听到慈善、公益，心里就不是滋味——信息不透明、 监督困难；利用区块链技术能够追踪每一笔善款的去向\n- 供应链：结合物联网实现对物品信息的区块链管理，做到每个每个商品从生产到消费者的每一个环节，做到正品溯源；\n- 供应链金融：代理商可以低成本的通过货物抵押向供应商赊账，并利用区块链智能合约技术保证物品出售时自动回款给供应商\n- 物流：通过区块链技术做到CP间的信息信任，较少物流环节的信息交换成本，并通过区块链加密技术做到信息的保护。\n\n# 总结\n- 区块链为信息时代的去中心化信息交易提供了良好的解决思路\n- 区块链只是一种解决问题的技术，一定是结合实际场景落地才能有好的未来，否则就是技术人和投机者的一场狂欢。\n- 炒币有风险，入市需谨慎\n\n# 了解区块链的一些网站：\n区块链相关导航：[https://www.feixiaohao.com/daohanglist/](https://www.feixiaohao.com/daohanglist/)\n比特币富豪排行榜：[http://bitop.top/](http://bitop.top/)http://bitop.top/)\n","source":"_posts/区块链/区块链技术之比特币运作原理.md","raw":"---\ntitle: 区块链技术之比特币运作原理\ndate: 2019-08-21 09:25:00\nauthor: okeeper\ntop: true\ntoc: true\ncategories: 区块链\ntags:\n  - 区块链\n---\n\n# 什么是比特币\n点对点的传输的一个去中心化的电子现金系统。每个节点都共同维护一个区块链形式存储的交易记录，每个比特币节点遵守同一个比特币网络协议，并基于密码学原理加密每一笔交易记录和区块，实现每一笔交易不可逆、防篡改、去中心化的、数据可监管溯源的电子现金交易系统。\n## 比特币特点\n- 比特币最初由中本聪2008年发明\n- 比特币发行和交易不依赖中央机构\n- 比特币的发行总量不会超过2100万个\n- 只要能够联网，安装比特币客户端，任何人都能接入到这个比特币网络\n- 比特币的账户地址是匿名的\n- 任何国家或者机构无法监管或者操纵这个比特币网络\n- 比特币是基于现代密码学实现的点对点交易的分布式超级账本\n\n# 比特币行情\n比特币从诞生以来已经翻了好几万倍了，比特币的第一笔交易是一个程序员用50btc买了披萨，第一批持有比特币的人估计早已经是千万富翁，但是神奇的比特币之父中本聪的创始区块及它的账户的其他比特币都还没有发生转账交易。\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508680.png)\n# 区中心化的比特币网络\n![](../images/区块链技术之比特币运作原理/getImage.png)\n\n这个比特币网络大致是这个样子的，节点分为以下几类：\n- 全数据节点：保存了完整的区块链所有交易信息\n- 矿工节点：负责打包新的交易数据制作新的区块\n- 轻客户端节钱包节点：只保留自己关心交易数据\n\n# 什么是区块链\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508350.png)\n区块链有以下几个特点：\n- 区块链本质是一个分布式的超级账本，整个比特币网络各个节点仅仅认可和维护记录一样且长度最长的区块链\n- 每个区块由区块头（上一个区块的hash值，当前区块的高度，出块的时间等）+ 交易记录列表 组成\n- 所有经过验证符合比特币协议的交易记录都会被“矿工”打包进新的区块，然后广播给所有其它节点。\n\n每一个新的区块的都有一个指向上一个区块的hash值，所以这条链被形象的称之为**区块链**\n\n# 什么是挖矿\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508575.png)\n上图是传统的煤矿挖矿的矿工，比特币的“挖矿”当然不是这个挖矿。\n比特币的挖矿是指：将接收到全网的交易记录打包制作到一个新区块并广播至其它节点的过程，由于这个过程通常不是那么容易，需要不停的hash计算符合标准的随机数才能生效新区块，平均全网每10分钟才能有计算出这样的随机数，所以形象的形容为比特币的“挖矿”\n\n## 挖矿的原理\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508972.png)\n挖矿的过程如下：\n1. 每个矿工节点都共同监听最新的交易数据，并做合法性校验，将符合校验的交易打包进新的区块中\n2. 在新的区块中添加给矿工账户转账的一笔交易，给矿工自己加上相应的比特币奖励和交易记录收取的手续费\n3. 最后一步用新区块的所有内容+一个随机数做SHA-256计算出hash值，使得这个hash值的二进制数符合一定规则，才能向全网广播这个新的区块\n\n那么接下来我们思考下以下三个问题：\n1. 整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？\n2. 这种“苦力活”如果没人做怎么办？\n3. 如果这个矿工“不老实”怎么办？\n\n### 1. 整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508157.png)\n在比特币的协议中规定，给挖矿过程增加了一定的难度，使得矿工挖矿并不是那么容易，一般是全网的所有矿工节点的所有算力一起计算10分钟才能制作出一个合法的新区块。\n有了这个规定，这个比特币网络就有充足的时间让大部分节点同步最新的区块数据，而减少并发问题。这个挖矿的难度在比特币中就叫工作量证明机制（Proof-of-Work，PoW）。\n\n刚刚提到的10分钟，为什么是10分钟，是怎么保证的？\n\n先来回答下为什么是10分钟，而不是15分钟、2分钟、8分钟，中本聪在设计比特币机制时，考虑到新区块数据在全世界节点的广播同步有一定的网络延迟，于是为了尽量避免“矿工A和矿工B在不知道对方都计算出结果的情况下同时发送计算结果”的事情，规定了制作新区款的难度，这个难度难到平均每个矿工需要花10分钟挖出一个区块，于是设计了一个这样的值：理论平均出块时间=10分钟。至于为什么是10分钟，那总得取一个值吧，综合考量就定了10分钟。\n\n是怎么保证全网的平均出块时间一直保证在10分钟，不会随着计算能力的提升，就不需要10分钟了吗？\n\n比特币规定，每挖完2016个区块，数学题的难度会自动的根据这2016个区块的实际挖出时间，动态地做出调整。\n\n也就是说，每2016个区块的难度都是一样的，接下来的2016个区块的难度，根据前2016个区块的难度以及前2016个区块的整体实际挖矿时间综合决定，这里有个计算公式如下：\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508078.png)\n可以看出10分钟不是绝对值，有的矿工可能运气好一些、3分钟、5分钟就能找到符合标准的新区块，有的矿工运气差一些，可能需要20分钟、30分钟才能找到符合标准的新区块，由于有了这个标准的动态调整，总能保证全网的平均出块时间在10分钟左右。\n具体这个难度是什么，我们看下面公式：\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508135.png)\n而上面的这个目标值b就是和挖矿难度系数有关的值，目前的难度就是SHA-256【制作新区款的所有内容+一个随机数】的hash值的二进制值至少前72位为零，也就是最坏的结果是至少需要计算2^72次才能找到这个随机数，你可以认为这个72就是一个难度系数值\n\n\n有了这个工作量证明机制就能保证一定全网在同一时刻只有一个矿工制作成符合标准的新区块吗，答案是否定的，那么如果出现这个情况，比特币网络是怎么处理的？\n\nE矿工和F矿工分别基于d区块制作出了新的区块并广播至其他节点，如下图：\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508546.png)\n\n同时收到e区块和f区块的节点会先同时保留这些区块，直到下一个区块基于其中一个区块制作出更长的区块链\n\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508291.png)\n\n比特币协议规定只保留最长的区块链，较短的支链中的交易记录重新变为待确认交易重新发送至矿工节点作确认\n\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508312.png)\n\n如果下一个区块碰巧又分别有两个新的区块基于e区块和f区块制作新区块，比特币网络的做法和上面的是一样的，先同时保留这些支链，直到最长的区块链出现，较短的区块的交易记录变为待确认交易重新发送至别人矿工节点。\n\n###  2. 这种“苦力活”如果没人做怎么办？\n比特币网络规定每成功生成一个新的区块，给相应的BTC给矿工账号作为奖励，并将新区块中的交易的手续费也归矿工所有，通过这个奖励机制大家就很乐意去干这个“苦力活”了。\n\n这个奖励最初是50比特币，今后每产生21万个区块，比特币数量都会依次减半。直到第33次减半时，每个块产生0.0021个新比特币直接减为0个，最终比特币总量维持在2100万个。我们知道比特币大约每10分钟产生一个区块，而21万个10分钟接近4年。\n最终这个比特币网络的矿工只能通过收取交易的手续费来维持他们的成本和收益\n这个交易的手续费是可以交易方自己定的\n但是矿工有权利优先选择手续费较高的记账或者拒绝，只要矿工们达成共识。\n\n## 挖矿工具——矿机\n挖矿的矿机从最初的使用PC个人电脑挖矿到专业的挖矿矿池，算力变得越来越强，挖矿的成本也越来越高，门槛越来越高。\n**CPU挖矿→GPU挖矿→专业矿机挖矿→矿池挖矿**\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508408.png)\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508413.png)\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508512.png)\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508831.png)\n# 比特币是如何进行交易的\n\n比特币交易符合以下几个特点：\n- 交易数据包含交易输入和交易输出，其中交易输入的金额总和必须>=输出金额总和\n- 挖矿奖励属于一个特殊的交易（称为coinbase交易），可以没有输入。\n- 在比特币没有余额概念，只有分散到区块链里的UTXO（未花费交易记录）\n- UTXO是交易的基本单元，不能在分割。\n\n## 比特币转账\n比特币的交易记录主要由以下几部分组成：\n- 交易的输入，是指向上一笔交易的hash值\n- 交易的输入解锁脚本，能够证明这笔钱你有权动用\n- 交易的输出，交易的输出对方账户\n- 交易输出的加锁脚本，是的对方必须提供证明是转给他的，才有权动用\n\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508663.png)\n上表格中：\n记录1是个特殊的交易记录，是比特币矿工的奖励记录，给A账户转账10BTC，所以没有交易输入，这个交易记录叫coinbase\n记录2:A使用记录1转给他的钱用来支付给B,并加锁这个转账\n记录3：B收到这个转账时，提供自己的签名和公钥，证明确实是转给他的，B再用这笔转账支付10BTC给C\n\n从上面的交易得知，**我们把以上交易记录中可以用来当下一笔交易的未使用记录，称之为未花费记录（UTXO）**\n\n\n我们再来看下面这个记录：\n![](../images/区块链技术之比特币运作原理/getImage-20220824120509067.png)\n\n记录2中A需要支付5BTC给B，但是交易输入记录1是10BTC的，所以将自己的账户添加到交易输出中找回5BTC\n\n记录4由于A需要支付10BTC，所以交易输入是两笔5BTC的交易记录。\n\n从上面的交易可以看出,**比特币系统中没有账户的概念，只有交易记录，一笔未花费交易记录不能拆开使用，如果要只需花费一部分，通过在交易输出添加一笔给自己转账的记录，类似现金找零。**\n\n### 如何防止同一笔前用两次\n\nA账号用【记录1】当做输入支付给10BTC给“B账号”，接着又用【记录1】当做输入支付给10BTC给“C账号”,\n相当于10BTC用了两次。如下图：\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508784.png)\n\n我们分情况来看同一笔交易输入支付给了不同的人：\n**情况1：**两条交易记录打包在同一个区块中：那么以先收到的交易是合法的，后收到的交易是非法的\n**情况2：**两条交易记录先后被打包进不同区块的同一主链中：那么当矿工验证交易合法性时，是从以往合法的所有区块的所有交易中查找验证的，先收到的交易是合法的，后收到的是非法的\n**情况2：**两条交易记录先后被打包进不同区块的不同支链中：\nA矿工在之前主链基础上制作新区款，先收到交易1；\nB矿工在之前主链基础上制作新区款，先收到交易2。\n那么矿工在做合法性验证时都认为是合法的，此时比特币网络发生分叉，随着之后新区款制作，根据比特币协议规定，将保留区块长度最长的链，较短的支链将丢弃，其中的交易记录重新变为未确认交易等待下一个新区块的合法性校验，此时校验不通过的交易将丢弃。\n\n\n## 真实的比特币交易数据的结构\n```\n{\n   \"lock_time\":0,\n   \"size\":259,\n   \"version\":1,\n   \"vin_sz\":1,\n   “hash”:“2514161c059ac18bf2eff1e05c4628e322d846e930fd6dd4b24805ea59dc4913”,//这笔交易的ID\n   \"vout_sz\":2,\n   “inputs”:[//这笔交易的的来源交易，也称输入交易，可能有多个\n      {\n         \"prev_out\":{\n\t\t“hash”:“4f40655c4ab1a029bc41bc547f79556a0dc48d22df7202778fad592791c77fcd”,//上一笔交易的交易ID\n\t\t“index”:0 //在上一笔交易的输出列表的下标位置\n         },\n         “script”:“493046022100cd6795ebcd1b6b87833a4ad812733d3804065d34bafee24da181a770892272b902210088cd2484952ad2572f9bfb2874643dbb4b3c492b749e79d8177a14eb4a3bc61a014104bbf2b84900b6f898548687aefba86cc06da6f4656a71e45fa55128b501455b5486cb09705cfa23c1899fe46d4355c9058bb2de4f1a7f1a01ff27e00b306f7356” //解锁上一笔交易输出的参数\n      }\n   ],\n    “out”:[//这笔交易的交易对手方，也称交易输出，也可以有多个\n      {\n\t   //交易输出的锁定脚本，只有交易对方提供正确的自己的签名及公钥才能证明这笔钱是转给他的，才有资格进行下一次的转账交易\n         “script_string”:“OP_DUP OP_HASH160 f9d49c5cf3e120ad1be60b67d868603a8fc945d2 OP_EQUALVERIFY OP_CHECKSIG”,\n         \"address\":\"1PmyxDv5VvGoSAKMr1DQcWB6sHPx1ZbgWe\",\n         “value”:88994500000,//转多少钱，单位是聪，1亿聪=1BTC\n         \"script\":\"76a914f9d49c5cf3e120ad1be60b67d868603a8fc945d288ac\"\n      },\n      {\n         \"script_string\":\"OP_DUP OP_HASH160 088465c1f0c8b3b3da06f7073a921d6b95b22f49 OP_EQUALVERIFY OP_CHECKSIG\",\n         \"address\":\"1n31g4rKiEeXnZEZR6VZwm3LggLicEqEC\",\n         \"value\":1000000000,\n         \"script\":\"76a914088465c1f0c8b3b3da06f7073a921d6b95b22f4988ac\"\n      }\n   ]\n}\n```\n\n## 比特币的脚本语言\n\n```\nOP_DUP OP_HASH160 f9d49c5cf3e120ad1be60b67d868603a8fc945d2 OP_EQUALVERIFY OP_CHECKSIG\n```\n上面是比特币交易中的交易输入解锁脚本，输入两个参数：<sig> <PubK> 使得<PubK>的HASH160值等于9d49c5cf3e120ad1be60b67d868603a8fc945d2，接着使用<PubK>验证<sig>签名，验证同步则表示该交易输入合法有效，就像用户名密码一样。\n\n比特币脚本语言是非图灵完备脚本语言，就是说它不能实现复杂的逻辑。\n比特币脚本语言的执行是遵循先进后出的原因，即它的变量读取是堆栈式，如下图：\n\n![](../images/区块链技术之比特币运作原理/getImage-20220824120509028.png)\n![](../images/区块链技术之比特币运作原理/getImage-20220824120508906.png)\n## 最终的结构\n比特币就是通过每一个区块都有上一个区块的指正，每个区块中包含通过验证的合法交易组成的链式结构，并让所有节点同步这份数据，形成不可逆，串改成本巨大的分布式超级账本，称之为区块链\n![](../images/区块链技术之比特币运作原理/getImage-20220824120509220.png)\n\n# 比特币的价值及存在问题\n比特币的价值在于，金融危机发生的时候，货币超发，法币贬值，社会财富缩水；\n而比特币不依赖中央机构管理，期价值完全由供给关系决定，\n当旧的法定货币崩溃时，人们便会涌向比特币，把比特币作为新的资产避风港——“21世纪版的黄金”\n比特币是目前区块链技术落地最成功的项目，虽然比特币目前实际用的更多的是黑产（赌博、洗钱、黑客敲诈、传销），但是开创了人们对区块链技术无限探索和想象；\n\n但同样存在着问题：\n- 由于有新区块难度限制，每秒处理交易数不足7/sec，交易确认时间长大几小时甚至几天交易确认时间长大几小时甚至几天\n- 巨大的能源消耗（这也是比特币防篡改的代价）\n- 随着计算机算力的提升，构建数字货币的密码学可能会被攻破\n- 投机性强，泡沫大\n- 算力集中，随着挖矿难度增加，只有少数几个矿池能够维持挖矿成本，失去去中心化初衷\n\n# 区块链的应用\n基于区块链的记录不可逆、去中心化、全民监管的特点来构建一个信任网络，降低\n社会协同合作成本，主要应用如下：\n- 企业融资：企业可以通过发行代币的方式对投资者承诺未来能够通过代币购买\n- 公共实物：居于区块链上的登记的信息不可篡改，能够很方便的证明你的信息合法性\n- 公益：在当前大环境下，听到慈善、公益，心里就不是滋味——信息不透明、 监督困难；利用区块链技术能够追踪每一笔善款的去向\n- 供应链：结合物联网实现对物品信息的区块链管理，做到每个每个商品从生产到消费者的每一个环节，做到正品溯源；\n- 供应链金融：代理商可以低成本的通过货物抵押向供应商赊账，并利用区块链智能合约技术保证物品出售时自动回款给供应商\n- 物流：通过区块链技术做到CP间的信息信任，较少物流环节的信息交换成本，并通过区块链加密技术做到信息的保护。\n\n# 总结\n- 区块链为信息时代的去中心化信息交易提供了良好的解决思路\n- 区块链只是一种解决问题的技术，一定是结合实际场景落地才能有好的未来，否则就是技术人和投机者的一场狂欢。\n- 炒币有风险，入市需谨慎\n\n# 了解区块链的一些网站：\n区块链相关导航：[https://www.feixiaohao.com/daohanglist/](https://www.feixiaohao.com/daohanglist/)\n比特币富豪排行榜：[http://bitop.top/](http://bitop.top/)http://bitop.top/)\n","slug":"区块链/区块链技术之比特币运作原理","published":1,"updated":"2022-08-25T11:05:39.780Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczip0010vwm1u8e482qi","content":"<h1 id=\"什么是比特币\"><a href=\"#什么是比特币\" class=\"headerlink\" title=\"什么是比特币\"></a>什么是比特币</h1><p>点对点的传输的一个去中心化的电子现金系统。每个节点都共同维护一个区块链形式存储的交易记录，每个比特币节点遵守同一个比特币网络协议，并基于密码学原理加密每一笔交易记录和区块，实现每一笔交易不可逆、防篡改、去中心化的、数据可监管溯源的电子现金交易系统。</p>\n<h2 id=\"比特币特点\"><a href=\"#比特币特点\" class=\"headerlink\" title=\"比特币特点\"></a>比特币特点</h2><ul>\n<li>比特币最初由中本聪2008年发明</li>\n<li>比特币发行和交易不依赖中央机构</li>\n<li>比特币的发行总量不会超过2100万个</li>\n<li>只要能够联网，安装比特币客户端，任何人都能接入到这个比特币网络</li>\n<li>比特币的账户地址是匿名的</li>\n<li>任何国家或者机构无法监管或者操纵这个比特币网络</li>\n<li>比特币是基于现代密码学实现的点对点交易的分布式超级账本</li>\n</ul>\n<h1 id=\"比特币行情\"><a href=\"#比特币行情\" class=\"headerlink\" title=\"比特币行情\"></a>比特币行情</h1><p>比特币从诞生以来已经翻了好几万倍了，比特币的第一笔交易是一个程序员用50btc买了披萨，第一批持有比特币的人估计早已经是千万富翁，但是神奇的比特币之父中本聪的创始区块及它的账户的其他比特币都还没有发生转账交易。<br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508680.png\" alt></p>\n<h1 id=\"区中心化的比特币网络\"><a href=\"#区中心化的比特币网络\" class=\"headerlink\" title=\"区中心化的比特币网络\"></a>区中心化的比特币网络</h1><p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage.png\" alt></p>\n<p>这个比特币网络大致是这个样子的，节点分为以下几类：</p>\n<ul>\n<li>全数据节点：保存了完整的区块链所有交易信息</li>\n<li>矿工节点：负责打包新的交易数据制作新的区块</li>\n<li>轻客户端节钱包节点：只保留自己关心交易数据</li>\n</ul>\n<h1 id=\"什么是区块链\"><a href=\"#什么是区块链\" class=\"headerlink\" title=\"什么是区块链\"></a>什么是区块链</h1><p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508350.png\" alt><br>区块链有以下几个特点：</p>\n<ul>\n<li>区块链本质是一个分布式的超级账本，整个比特币网络各个节点仅仅认可和维护记录一样且长度最长的区块链</li>\n<li>每个区块由区块头（上一个区块的hash值，当前区块的高度，出块的时间等）+ 交易记录列表 组成</li>\n<li>所有经过验证符合比特币协议的交易记录都会被“矿工”打包进新的区块，然后广播给所有其它节点。</li>\n</ul>\n<p>每一个新的区块的都有一个指向上一个区块的hash值，所以这条链被形象的称之为<strong>区块链</strong></p>\n<h1 id=\"什么是挖矿\"><a href=\"#什么是挖矿\" class=\"headerlink\" title=\"什么是挖矿\"></a>什么是挖矿</h1><p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508575.png\" alt><br>上图是传统的煤矿挖矿的矿工，比特币的“挖矿”当然不是这个挖矿。<br>比特币的挖矿是指：将接收到全网的交易记录打包制作到一个新区块并广播至其它节点的过程，由于这个过程通常不是那么容易，需要不停的hash计算符合标准的随机数才能生效新区块，平均全网每10分钟才能有计算出这样的随机数，所以形象的形容为比特币的“挖矿”</p>\n<h2 id=\"挖矿的原理\"><a href=\"#挖矿的原理\" class=\"headerlink\" title=\"挖矿的原理\"></a>挖矿的原理</h2><p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508972.png\" alt><br>挖矿的过程如下：</p>\n<ol>\n<li>每个矿工节点都共同监听最新的交易数据，并做合法性校验，将符合校验的交易打包进新的区块中</li>\n<li>在新的区块中添加给矿工账户转账的一笔交易，给矿工自己加上相应的比特币奖励和交易记录收取的手续费</li>\n<li>最后一步用新区块的所有内容+一个随机数做SHA-256计算出hash值，使得这个hash值的二进制数符合一定规则，才能向全网广播这个新的区块</li>\n</ol>\n<p>那么接下来我们思考下以下三个问题：</p>\n<ol>\n<li>整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？</li>\n<li>这种“苦力活”如果没人做怎么办？</li>\n<li>如果这个矿工“不老实”怎么办？</li>\n</ol>\n<h3 id=\"1-整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？\"><a href=\"#1-整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？\" class=\"headerlink\" title=\"1. 整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？\"></a>1. 整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？</h3><p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508157.png\" alt><br>在比特币的协议中规定，给挖矿过程增加了一定的难度，使得矿工挖矿并不是那么容易，一般是全网的所有矿工节点的所有算力一起计算10分钟才能制作出一个合法的新区块。<br>有了这个规定，这个比特币网络就有充足的时间让大部分节点同步最新的区块数据，而减少并发问题。这个挖矿的难度在比特币中就叫工作量证明机制（Proof-of-Work，PoW）。</p>\n<p>刚刚提到的10分钟，为什么是10分钟，是怎么保证的？</p>\n<p>先来回答下为什么是10分钟，而不是15分钟、2分钟、8分钟，中本聪在设计比特币机制时，考虑到新区块数据在全世界节点的广播同步有一定的网络延迟，于是为了尽量避免“矿工A和矿工B在不知道对方都计算出结果的情况下同时发送计算结果”的事情，规定了制作新区款的难度，这个难度难到平均每个矿工需要花10分钟挖出一个区块，于是设计了一个这样的值：理论平均出块时间=10分钟。至于为什么是10分钟，那总得取一个值吧，综合考量就定了10分钟。</p>\n<p>是怎么保证全网的平均出块时间一直保证在10分钟，不会随着计算能力的提升，就不需要10分钟了吗？</p>\n<p>比特币规定，每挖完2016个区块，数学题的难度会自动的根据这2016个区块的实际挖出时间，动态地做出调整。</p>\n<p>也就是说，每2016个区块的难度都是一样的，接下来的2016个区块的难度，根据前2016个区块的难度以及前2016个区块的整体实际挖矿时间综合决定，这里有个计算公式如下：<br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508078.png\" alt><br>可以看出10分钟不是绝对值，有的矿工可能运气好一些、3分钟、5分钟就能找到符合标准的新区块，有的矿工运气差一些，可能需要20分钟、30分钟才能找到符合标准的新区块，由于有了这个标准的动态调整，总能保证全网的平均出块时间在10分钟左右。<br>具体这个难度是什么，我们看下面公式：<br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508135.png\" alt><br>而上面的这个目标值b就是和挖矿难度系数有关的值，目前的难度就是SHA-256【制作新区款的所有内容+一个随机数】的hash值的二进制值至少前72位为零，也就是最坏的结果是至少需要计算2^72次才能找到这个随机数，你可以认为这个72就是一个难度系数值</p>\n<p>有了这个工作量证明机制就能保证一定全网在同一时刻只有一个矿工制作成符合标准的新区块吗，答案是否定的，那么如果出现这个情况，比特币网络是怎么处理的？</p>\n<p>E矿工和F矿工分别基于d区块制作出了新的区块并广播至其他节点，如下图：<br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508546.png\" alt></p>\n<p>同时收到e区块和f区块的节点会先同时保留这些区块，直到下一个区块基于其中一个区块制作出更长的区块链</p>\n<p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508291.png\" alt></p>\n<p>比特币协议规定只保留最长的区块链，较短的支链中的交易记录重新变为待确认交易重新发送至矿工节点作确认</p>\n<p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508312.png\" alt></p>\n<p>如果下一个区块碰巧又分别有两个新的区块基于e区块和f区块制作新区块，比特币网络的做法和上面的是一样的，先同时保留这些支链，直到最长的区块链出现，较短的区块的交易记录变为待确认交易重新发送至别人矿工节点。</p>\n<h3 id=\"2-这种“苦力活”如果没人做怎么办？\"><a href=\"#2-这种“苦力活”如果没人做怎么办？\" class=\"headerlink\" title=\"2. 这种“苦力活”如果没人做怎么办？\"></a>2. 这种“苦力活”如果没人做怎么办？</h3><p>比特币网络规定每成功生成一个新的区块，给相应的BTC给矿工账号作为奖励，并将新区块中的交易的手续费也归矿工所有，通过这个奖励机制大家就很乐意去干这个“苦力活”了。</p>\n<p>这个奖励最初是50比特币，今后每产生21万个区块，比特币数量都会依次减半。直到第33次减半时，每个块产生0.0021个新比特币直接减为0个，最终比特币总量维持在2100万个。我们知道比特币大约每10分钟产生一个区块，而21万个10分钟接近4年。<br>最终这个比特币网络的矿工只能通过收取交易的手续费来维持他们的成本和收益<br>这个交易的手续费是可以交易方自己定的<br>但是矿工有权利优先选择手续费较高的记账或者拒绝，只要矿工们达成共识。</p>\n<h2 id=\"挖矿工具——矿机\"><a href=\"#挖矿工具——矿机\" class=\"headerlink\" title=\"挖矿工具——矿机\"></a>挖矿工具——矿机</h2><p>挖矿的矿机从最初的使用PC个人电脑挖矿到专业的挖矿矿池，算力变得越来越强，挖矿的成本也越来越高，门槛越来越高。<br><strong>CPU挖矿→GPU挖矿→专业矿机挖矿→矿池挖矿</strong><br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508408.png\" alt><br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508413.png\" alt><br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508512.png\" alt><br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508831.png\" alt></p>\n<h1 id=\"比特币是如何进行交易的\"><a href=\"#比特币是如何进行交易的\" class=\"headerlink\" title=\"比特币是如何进行交易的\"></a>比特币是如何进行交易的</h1><p>比特币交易符合以下几个特点：</p>\n<ul>\n<li>交易数据包含交易输入和交易输出，其中交易输入的金额总和必须&gt;=输出金额总和</li>\n<li>挖矿奖励属于一个特殊的交易（称为coinbase交易），可以没有输入。</li>\n<li>在比特币没有余额概念，只有分散到区块链里的UTXO（未花费交易记录）</li>\n<li>UTXO是交易的基本单元，不能在分割。</li>\n</ul>\n<h2 id=\"比特币转账\"><a href=\"#比特币转账\" class=\"headerlink\" title=\"比特币转账\"></a>比特币转账</h2><p>比特币的交易记录主要由以下几部分组成：</p>\n<ul>\n<li>交易的输入，是指向上一笔交易的hash值</li>\n<li>交易的输入解锁脚本，能够证明这笔钱你有权动用</li>\n<li>交易的输出，交易的输出对方账户</li>\n<li>交易输出的加锁脚本，是的对方必须提供证明是转给他的，才有权动用</li>\n</ul>\n<p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508663.png\" alt><br>上表格中：<br>记录1是个特殊的交易记录，是比特币矿工的奖励记录，给A账户转账10BTC，所以没有交易输入，这个交易记录叫coinbase<br>记录2:A使用记录1转给他的钱用来支付给B,并加锁这个转账<br>记录3：B收到这个转账时，提供自己的签名和公钥，证明确实是转给他的，B再用这笔转账支付10BTC给C</p>\n<p>从上面的交易得知，<strong>我们把以上交易记录中可以用来当下一笔交易的未使用记录，称之为未花费记录（UTXO）</strong></p>\n<p>我们再来看下面这个记录：<br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120509067.png\" alt></p>\n<p>记录2中A需要支付5BTC给B，但是交易输入记录1是10BTC的，所以将自己的账户添加到交易输出中找回5BTC</p>\n<p>记录4由于A需要支付10BTC，所以交易输入是两笔5BTC的交易记录。</p>\n<p>从上面的交易可以看出,<strong>比特币系统中没有账户的概念，只有交易记录，一笔未花费交易记录不能拆开使用，如果要只需花费一部分，通过在交易输出添加一笔给自己转账的记录，类似现金找零。</strong></p>\n<h3 id=\"如何防止同一笔前用两次\"><a href=\"#如何防止同一笔前用两次\" class=\"headerlink\" title=\"如何防止同一笔前用两次\"></a>如何防止同一笔前用两次</h3><p>A账号用【记录1】当做输入支付给10BTC给“B账号”，接着又用【记录1】当做输入支付给10BTC给“C账号”,<br>相当于10BTC用了两次。如下图：<br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508784.png\" alt></p>\n<p>我们分情况来看同一笔交易输入支付给了不同的人：<br><strong>情况1：</strong>两条交易记录打包在同一个区块中：那么以先收到的交易是合法的，后收到的交易是非法的<br><strong>情况2：</strong>两条交易记录先后被打包进不同区块的同一主链中：那么当矿工验证交易合法性时，是从以往合法的所有区块的所有交易中查找验证的，先收到的交易是合法的，后收到的是非法的<br><strong>情况2：</strong>两条交易记录先后被打包进不同区块的不同支链中：<br>A矿工在之前主链基础上制作新区款，先收到交易1；<br>B矿工在之前主链基础上制作新区款，先收到交易2。<br>那么矿工在做合法性验证时都认为是合法的，此时比特币网络发生分叉，随着之后新区款制作，根据比特币协议规定，将保留区块长度最长的链，较短的支链将丢弃，其中的交易记录重新变为未确认交易等待下一个新区块的合法性校验，此时校验不通过的交易将丢弃。</p>\n<h2 id=\"真实的比特币交易数据的结构\"><a href=\"#真实的比特币交易数据的结构\" class=\"headerlink\" title=\"真实的比特币交易数据的结构\"></a>真实的比特币交易数据的结构</h2><pre><code>{\n   &quot;lock_time&quot;:0,\n   &quot;size&quot;:259,\n   &quot;version&quot;:1,\n   &quot;vin_sz&quot;:1,\n   “hash”:“2514161c059ac18bf2eff1e05c4628e322d846e930fd6dd4b24805ea59dc4913”,//这笔交易的ID\n   &quot;vout_sz&quot;:2,\n   “inputs”:[//这笔交易的的来源交易，也称输入交易，可能有多个\n      {\n         &quot;prev_out&quot;:{\n        “hash”:“4f40655c4ab1a029bc41bc547f79556a0dc48d22df7202778fad592791c77fcd”,//上一笔交易的交易ID\n        “index”:0 //在上一笔交易的输出列表的下标位置\n         },\n         “script”:“493046022100cd6795ebcd1b6b87833a4ad812733d3804065d34bafee24da181a770892272b902210088cd2484952ad2572f9bfb2874643dbb4b3c492b749e79d8177a14eb4a3bc61a014104bbf2b84900b6f898548687aefba86cc06da6f4656a71e45fa55128b501455b5486cb09705cfa23c1899fe46d4355c9058bb2de4f1a7f1a01ff27e00b306f7356” //解锁上一笔交易输出的参数\n      }\n   ],\n    “out”:[//这笔交易的交易对手方，也称交易输出，也可以有多个\n      {\n       //交易输出的锁定脚本，只有交易对方提供正确的自己的签名及公钥才能证明这笔钱是转给他的，才有资格进行下一次的转账交易\n         “script_string”:“OP_DUP OP_HASH160 f9d49c5cf3e120ad1be60b67d868603a8fc945d2 OP_EQUALVERIFY OP_CHECKSIG”,\n         &quot;address&quot;:&quot;1PmyxDv5VvGoSAKMr1DQcWB6sHPx1ZbgWe&quot;,\n         “value”:88994500000,//转多少钱，单位是聪，1亿聪=1BTC\n         &quot;script&quot;:&quot;76a914f9d49c5cf3e120ad1be60b67d868603a8fc945d288ac&quot;\n      },\n      {\n         &quot;script_string&quot;:&quot;OP_DUP OP_HASH160 088465c1f0c8b3b3da06f7073a921d6b95b22f49 OP_EQUALVERIFY OP_CHECKSIG&quot;,\n         &quot;address&quot;:&quot;1n31g4rKiEeXnZEZR6VZwm3LggLicEqEC&quot;,\n         &quot;value&quot;:1000000000,\n         &quot;script&quot;:&quot;76a914088465c1f0c8b3b3da06f7073a921d6b95b22f4988ac&quot;\n      }\n   ]\n}</code></pre><h2 id=\"比特币的脚本语言\"><a href=\"#比特币的脚本语言\" class=\"headerlink\" title=\"比特币的脚本语言\"></a>比特币的脚本语言</h2><pre><code>OP_DUP OP_HASH160 f9d49c5cf3e120ad1be60b67d868603a8fc945d2 OP_EQUALVERIFY OP_CHECKSIG</code></pre><p>上面是比特币交易中的交易输入解锁脚本，输入两个参数：<sig> <pubk> 使得<pubk>的HASH160值等于9d49c5cf3e120ad1be60b67d868603a8fc945d2，接着使用<pubk>验证<sig>签名，验证同步则表示该交易输入合法有效，就像用户名密码一样。</sig></pubk></pubk></pubk></sig></p>\n<p>比特币脚本语言是非图灵完备脚本语言，就是说它不能实现复杂的逻辑。<br>比特币脚本语言的执行是遵循先进后出的原因，即它的变量读取是堆栈式，如下图：</p>\n<p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120509028.png\" alt><br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508906.png\" alt></p>\n<h2 id=\"最终的结构\"><a href=\"#最终的结构\" class=\"headerlink\" title=\"最终的结构\"></a>最终的结构</h2><p>比特币就是通过每一个区块都有上一个区块的指正，每个区块中包含通过验证的合法交易组成的链式结构，并让所有节点同步这份数据，形成不可逆，串改成本巨大的分布式超级账本，称之为区块链<br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120509220.png\" alt></p>\n<h1 id=\"比特币的价值及存在问题\"><a href=\"#比特币的价值及存在问题\" class=\"headerlink\" title=\"比特币的价值及存在问题\"></a>比特币的价值及存在问题</h1><p>比特币的价值在于，金融危机发生的时候，货币超发，法币贬值，社会财富缩水；<br>而比特币不依赖中央机构管理，期价值完全由供给关系决定，<br>当旧的法定货币崩溃时，人们便会涌向比特币，把比特币作为新的资产避风港——“21世纪版的黄金”<br>比特币是目前区块链技术落地最成功的项目，虽然比特币目前实际用的更多的是黑产（赌博、洗钱、黑客敲诈、传销），但是开创了人们对区块链技术无限探索和想象；</p>\n<p>但同样存在着问题：</p>\n<ul>\n<li>由于有新区块难度限制，每秒处理交易数不足7/sec，交易确认时间长大几小时甚至几天交易确认时间长大几小时甚至几天</li>\n<li>巨大的能源消耗（这也是比特币防篡改的代价）</li>\n<li>随着计算机算力的提升，构建数字货币的密码学可能会被攻破</li>\n<li>投机性强，泡沫大</li>\n<li>算力集中，随着挖矿难度增加，只有少数几个矿池能够维持挖矿成本，失去去中心化初衷</li>\n</ul>\n<h1 id=\"区块链的应用\"><a href=\"#区块链的应用\" class=\"headerlink\" title=\"区块链的应用\"></a>区块链的应用</h1><p>基于区块链的记录不可逆、去中心化、全民监管的特点来构建一个信任网络，降低<br>社会协同合作成本，主要应用如下：</p>\n<ul>\n<li>企业融资：企业可以通过发行代币的方式对投资者承诺未来能够通过代币购买</li>\n<li>公共实物：居于区块链上的登记的信息不可篡改，能够很方便的证明你的信息合法性</li>\n<li>公益：在当前大环境下，听到慈善、公益，心里就不是滋味——信息不透明、 监督困难；利用区块链技术能够追踪每一笔善款的去向</li>\n<li>供应链：结合物联网实现对物品信息的区块链管理，做到每个每个商品从生产到消费者的每一个环节，做到正品溯源；</li>\n<li>供应链金融：代理商可以低成本的通过货物抵押向供应商赊账，并利用区块链智能合约技术保证物品出售时自动回款给供应商</li>\n<li>物流：通过区块链技术做到CP间的信息信任，较少物流环节的信息交换成本，并通过区块链加密技术做到信息的保护。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>区块链为信息时代的去中心化信息交易提供了良好的解决思路</li>\n<li>区块链只是一种解决问题的技术，一定是结合实际场景落地才能有好的未来，否则就是技术人和投机者的一场狂欢。</li>\n<li>炒币有风险，入市需谨慎</li>\n</ul>\n<h1 id=\"了解区块链的一些网站：\"><a href=\"#了解区块链的一些网站：\" class=\"headerlink\" title=\"了解区块链的一些网站：\"></a>了解区块链的一些网站：</h1><p>区块链相关导航：<a href=\"https://www.feixiaohao.com/daohanglist/\" target=\"_blank\" rel=\"noopener\">https://www.feixiaohao.com/daohanglist/</a><br>比特币富豪排行榜：<a href=\"http://bitop.top/\" target=\"_blank\" rel=\"noopener\">http://bitop.top/</a><a href=\"http://bitop.top/\" target=\"_blank\" rel=\"noopener\">http://bitop.top/</a>)</p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"什么是比特币\"><a href=\"#什么是比特币\" class=\"headerlink\" title=\"什么是比特币\"></a>什么是比特币</h1><p>点对点的传输的一个去中心化的电子现金系统。每个节点都共同维护一个区块链形式存储的交易记录，每个比特币节点遵守同一个比特币网络协议，并基于密码学原理加密每一笔交易记录和区块，实现每一笔交易不可逆、防篡改、去中心化的、数据可监管溯源的电子现金交易系统。</p>\n<h2 id=\"比特币特点\"><a href=\"#比特币特点\" class=\"headerlink\" title=\"比特币特点\"></a>比特币特点</h2><ul>\n<li>比特币最初由中本聪2008年发明</li>\n<li>比特币发行和交易不依赖中央机构</li>\n<li>比特币的发行总量不会超过2100万个</li>\n<li>只要能够联网，安装比特币客户端，任何人都能接入到这个比特币网络</li>\n<li>比特币的账户地址是匿名的</li>\n<li>任何国家或者机构无法监管或者操纵这个比特币网络</li>\n<li>比特币是基于现代密码学实现的点对点交易的分布式超级账本</li>\n</ul>\n<h1 id=\"比特币行情\"><a href=\"#比特币行情\" class=\"headerlink\" title=\"比特币行情\"></a>比特币行情</h1><p>比特币从诞生以来已经翻了好几万倍了，比特币的第一笔交易是一个程序员用50btc买了披萨，第一批持有比特币的人估计早已经是千万富翁，但是神奇的比特币之父中本聪的创始区块及它的账户的其他比特币都还没有发生转账交易。<br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508680.png\" alt></p>\n<h1 id=\"区中心化的比特币网络\"><a href=\"#区中心化的比特币网络\" class=\"headerlink\" title=\"区中心化的比特币网络\"></a>区中心化的比特币网络</h1><p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage.png\" alt></p>\n<p>这个比特币网络大致是这个样子的，节点分为以下几类：</p>\n<ul>\n<li>全数据节点：保存了完整的区块链所有交易信息</li>\n<li>矿工节点：负责打包新的交易数据制作新的区块</li>\n<li>轻客户端节钱包节点：只保留自己关心交易数据</li>\n</ul>\n<h1 id=\"什么是区块链\"><a href=\"#什么是区块链\" class=\"headerlink\" title=\"什么是区块链\"></a>什么是区块链</h1><p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508350.png\" alt><br>区块链有以下几个特点：</p>\n<ul>\n<li>区块链本质是一个分布式的超级账本，整个比特币网络各个节点仅仅认可和维护记录一样且长度最长的区块链</li>\n<li>每个区块由区块头（上一个区块的hash值，当前区块的高度，出块的时间等）+ 交易记录列表 组成</li>\n<li>所有经过验证符合比特币协议的交易记录都会被“矿工”打包进新的区块，然后广播给所有其它节点。</li>\n</ul>\n<p>每一个新的区块的都有一个指向上一个区块的hash值，所以这条链被形象的称之为<strong>区块链</strong></p>\n<h1 id=\"什么是挖矿\"><a href=\"#什么是挖矿\" class=\"headerlink\" title=\"什么是挖矿\"></a>什么是挖矿</h1><p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508575.png\" alt><br>上图是传统的煤矿挖矿的矿工，比特币的“挖矿”当然不是这个挖矿。<br>比特币的挖矿是指：将接收到全网的交易记录打包制作到一个新区块并广播至其它节点的过程，由于这个过程通常不是那么容易，需要不停的hash计算符合标准的随机数才能生效新区块，平均全网每10分钟才能有计算出这样的随机数，所以形象的形容为比特币的“挖矿”</p>\n<h2 id=\"挖矿的原理\"><a href=\"#挖矿的原理\" class=\"headerlink\" title=\"挖矿的原理\"></a>挖矿的原理</h2><p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508972.png\" alt><br>挖矿的过程如下：</p>\n<ol>\n<li>每个矿工节点都共同监听最新的交易数据，并做合法性校验，将符合校验的交易打包进新的区块中</li>\n<li>在新的区块中添加给矿工账户转账的一笔交易，给矿工自己加上相应的比特币奖励和交易记录收取的手续费</li>\n<li>最后一步用新区块的所有内容+一个随机数做SHA-256计算出hash值，使得这个hash值的二进制数符合一定规则，才能向全网广播这个新的区块</li>\n</ol>\n<p>那么接下来我们思考下以下三个问题：</p>\n<ol>\n<li>整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？</li>\n<li>这种“苦力活”如果没人做怎么办？</li>\n<li>如果这个矿工“不老实”怎么办？</li>\n</ol>\n<h3 id=\"1-整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？\"><a href=\"#1-整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？\" class=\"headerlink\" title=\"1. 整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？\"></a>1. 整个网络那么多矿工谁都有打包制作的权利，怎么解决并发问题？</h3><p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508157.png\" alt><br>在比特币的协议中规定，给挖矿过程增加了一定的难度，使得矿工挖矿并不是那么容易，一般是全网的所有矿工节点的所有算力一起计算10分钟才能制作出一个合法的新区块。<br>有了这个规定，这个比特币网络就有充足的时间让大部分节点同步最新的区块数据，而减少并发问题。这个挖矿的难度在比特币中就叫工作量证明机制（Proof-of-Work，PoW）。</p>\n<p>刚刚提到的10分钟，为什么是10分钟，是怎么保证的？</p>\n<p>先来回答下为什么是10分钟，而不是15分钟、2分钟、8分钟，中本聪在设计比特币机制时，考虑到新区块数据在全世界节点的广播同步有一定的网络延迟，于是为了尽量避免“矿工A和矿工B在不知道对方都计算出结果的情况下同时发送计算结果”的事情，规定了制作新区款的难度，这个难度难到平均每个矿工需要花10分钟挖出一个区块，于是设计了一个这样的值：理论平均出块时间=10分钟。至于为什么是10分钟，那总得取一个值吧，综合考量就定了10分钟。</p>\n<p>是怎么保证全网的平均出块时间一直保证在10分钟，不会随着计算能力的提升，就不需要10分钟了吗？</p>\n<p>比特币规定，每挖完2016个区块，数学题的难度会自动的根据这2016个区块的实际挖出时间，动态地做出调整。</p>\n<p>也就是说，每2016个区块的难度都是一样的，接下来的2016个区块的难度，根据前2016个区块的难度以及前2016个区块的整体实际挖矿时间综合决定，这里有个计算公式如下：<br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508078.png\" alt><br>可以看出10分钟不是绝对值，有的矿工可能运气好一些、3分钟、5分钟就能找到符合标准的新区块，有的矿工运气差一些，可能需要20分钟、30分钟才能找到符合标准的新区块，由于有了这个标准的动态调整，总能保证全网的平均出块时间在10分钟左右。<br>具体这个难度是什么，我们看下面公式：<br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508135.png\" alt><br>而上面的这个目标值b就是和挖矿难度系数有关的值，目前的难度就是SHA-256【制作新区款的所有内容+一个随机数】的hash值的二进制值至少前72位为零，也就是最坏的结果是至少需要计算2^72次才能找到这个随机数，你可以认为这个72就是一个难度系数值</p>\n<p>有了这个工作量证明机制就能保证一定全网在同一时刻只有一个矿工制作成符合标准的新区块吗，答案是否定的，那么如果出现这个情况，比特币网络是怎么处理的？</p>\n<p>E矿工和F矿工分别基于d区块制作出了新的区块并广播至其他节点，如下图：<br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508546.png\" alt></p>\n<p>同时收到e区块和f区块的节点会先同时保留这些区块，直到下一个区块基于其中一个区块制作出更长的区块链</p>\n<p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508291.png\" alt></p>\n<p>比特币协议规定只保留最长的区块链，较短的支链中的交易记录重新变为待确认交易重新发送至矿工节点作确认</p>\n<p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508312.png\" alt></p>\n<p>如果下一个区块碰巧又分别有两个新的区块基于e区块和f区块制作新区块，比特币网络的做法和上面的是一样的，先同时保留这些支链，直到最长的区块链出现，较短的区块的交易记录变为待确认交易重新发送至别人矿工节点。</p>\n<h3 id=\"2-这种“苦力活”如果没人做怎么办？\"><a href=\"#2-这种“苦力活”如果没人做怎么办？\" class=\"headerlink\" title=\"2. 这种“苦力活”如果没人做怎么办？\"></a>2. 这种“苦力活”如果没人做怎么办？</h3><p>比特币网络规定每成功生成一个新的区块，给相应的BTC给矿工账号作为奖励，并将新区块中的交易的手续费也归矿工所有，通过这个奖励机制大家就很乐意去干这个“苦力活”了。</p>\n<p>这个奖励最初是50比特币，今后每产生21万个区块，比特币数量都会依次减半。直到第33次减半时，每个块产生0.0021个新比特币直接减为0个，最终比特币总量维持在2100万个。我们知道比特币大约每10分钟产生一个区块，而21万个10分钟接近4年。<br>最终这个比特币网络的矿工只能通过收取交易的手续费来维持他们的成本和收益<br>这个交易的手续费是可以交易方自己定的<br>但是矿工有权利优先选择手续费较高的记账或者拒绝，只要矿工们达成共识。</p>\n<h2 id=\"挖矿工具——矿机\"><a href=\"#挖矿工具——矿机\" class=\"headerlink\" title=\"挖矿工具——矿机\"></a>挖矿工具——矿机</h2><p>挖矿的矿机从最初的使用PC个人电脑挖矿到专业的挖矿矿池，算力变得越来越强，挖矿的成本也越来越高，门槛越来越高。<br><strong>CPU挖矿→GPU挖矿→专业矿机挖矿→矿池挖矿</strong><br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508408.png\" alt><br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508413.png\" alt><br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508512.png\" alt><br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508831.png\" alt></p>\n<h1 id=\"比特币是如何进行交易的\"><a href=\"#比特币是如何进行交易的\" class=\"headerlink\" title=\"比特币是如何进行交易的\"></a>比特币是如何进行交易的</h1><p>比特币交易符合以下几个特点：</p>\n<ul>\n<li>交易数据包含交易输入和交易输出，其中交易输入的金额总和必须&gt;=输出金额总和</li>\n<li>挖矿奖励属于一个特殊的交易（称为coinbase交易），可以没有输入。</li>\n<li>在比特币没有余额概念，只有分散到区块链里的UTXO（未花费交易记录）</li>\n<li>UTXO是交易的基本单元，不能在分割。</li>\n</ul>\n<h2 id=\"比特币转账\"><a href=\"#比特币转账\" class=\"headerlink\" title=\"比特币转账\"></a>比特币转账</h2><p>比特币的交易记录主要由以下几部分组成：</p>\n<ul>\n<li>交易的输入，是指向上一笔交易的hash值</li>\n<li>交易的输入解锁脚本，能够证明这笔钱你有权动用</li>\n<li>交易的输出，交易的输出对方账户</li>\n<li>交易输出的加锁脚本，是的对方必须提供证明是转给他的，才有权动用</li>\n</ul>\n<p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508663.png\" alt><br>上表格中：<br>记录1是个特殊的交易记录，是比特币矿工的奖励记录，给A账户转账10BTC，所以没有交易输入，这个交易记录叫coinbase<br>记录2:A使用记录1转给他的钱用来支付给B,并加锁这个转账<br>记录3：B收到这个转账时，提供自己的签名和公钥，证明确实是转给他的，B再用这笔转账支付10BTC给C</p>\n<p>从上面的交易得知，<strong>我们把以上交易记录中可以用来当下一笔交易的未使用记录，称之为未花费记录（UTXO）</strong></p>\n<p>我们再来看下面这个记录：<br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120509067.png\" alt></p>\n<p>记录2中A需要支付5BTC给B，但是交易输入记录1是10BTC的，所以将自己的账户添加到交易输出中找回5BTC</p>\n<p>记录4由于A需要支付10BTC，所以交易输入是两笔5BTC的交易记录。</p>\n<p>从上面的交易可以看出,<strong>比特币系统中没有账户的概念，只有交易记录，一笔未花费交易记录不能拆开使用，如果要只需花费一部分，通过在交易输出添加一笔给自己转账的记录，类似现金找零。</strong></p>\n<h3 id=\"如何防止同一笔前用两次\"><a href=\"#如何防止同一笔前用两次\" class=\"headerlink\" title=\"如何防止同一笔前用两次\"></a>如何防止同一笔前用两次</h3><p>A账号用【记录1】当做输入支付给10BTC给“B账号”，接着又用【记录1】当做输入支付给10BTC给“C账号”,<br>相当于10BTC用了两次。如下图：<br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508784.png\" alt></p>\n<p>我们分情况来看同一笔交易输入支付给了不同的人：<br><strong>情况1：</strong>两条交易记录打包在同一个区块中：那么以先收到的交易是合法的，后收到的交易是非法的<br><strong>情况2：</strong>两条交易记录先后被打包进不同区块的同一主链中：那么当矿工验证交易合法性时，是从以往合法的所有区块的所有交易中查找验证的，先收到的交易是合法的，后收到的是非法的<br><strong>情况2：</strong>两条交易记录先后被打包进不同区块的不同支链中：<br>A矿工在之前主链基础上制作新区款，先收到交易1；<br>B矿工在之前主链基础上制作新区款，先收到交易2。<br>那么矿工在做合法性验证时都认为是合法的，此时比特币网络发生分叉，随着之后新区款制作，根据比特币协议规定，将保留区块长度最长的链，较短的支链将丢弃，其中的交易记录重新变为未确认交易等待下一个新区块的合法性校验，此时校验不通过的交易将丢弃。</p>\n<h2 id=\"真实的比特币交易数据的结构\"><a href=\"#真实的比特币交易数据的结构\" class=\"headerlink\" title=\"真实的比特币交易数据的结构\"></a>真实的比特币交易数据的结构</h2><pre><code>{\n   &quot;lock_time&quot;:0,\n   &quot;size&quot;:259,\n   &quot;version&quot;:1,\n   &quot;vin_sz&quot;:1,\n   “hash”:“2514161c059ac18bf2eff1e05c4628e322d846e930fd6dd4b24805ea59dc4913”,//这笔交易的ID\n   &quot;vout_sz&quot;:2,\n   “inputs”:[//这笔交易的的来源交易，也称输入交易，可能有多个\n      {\n         &quot;prev_out&quot;:{\n        “hash”:“4f40655c4ab1a029bc41bc547f79556a0dc48d22df7202778fad592791c77fcd”,//上一笔交易的交易ID\n        “index”:0 //在上一笔交易的输出列表的下标位置\n         },\n         “script”:“493046022100cd6795ebcd1b6b87833a4ad812733d3804065d34bafee24da181a770892272b902210088cd2484952ad2572f9bfb2874643dbb4b3c492b749e79d8177a14eb4a3bc61a014104bbf2b84900b6f898548687aefba86cc06da6f4656a71e45fa55128b501455b5486cb09705cfa23c1899fe46d4355c9058bb2de4f1a7f1a01ff27e00b306f7356” //解锁上一笔交易输出的参数\n      }\n   ],\n    “out”:[//这笔交易的交易对手方，也称交易输出，也可以有多个\n      {\n       //交易输出的锁定脚本，只有交易对方提供正确的自己的签名及公钥才能证明这笔钱是转给他的，才有资格进行下一次的转账交易\n         “script_string”:“OP_DUP OP_HASH160 f9d49c5cf3e120ad1be60b67d868603a8fc945d2 OP_EQUALVERIFY OP_CHECKSIG”,\n         &quot;address&quot;:&quot;1PmyxDv5VvGoSAKMr1DQcWB6sHPx1ZbgWe&quot;,\n         “value”:88994500000,//转多少钱，单位是聪，1亿聪=1BTC\n         &quot;script&quot;:&quot;76a914f9d49c5cf3e120ad1be60b67d868603a8fc945d288ac&quot;\n      },\n      {\n         &quot;script_string&quot;:&quot;OP_DUP OP_HASH160 088465c1f0c8b3b3da06f7073a921d6b95b22f49 OP_EQUALVERIFY OP_CHECKSIG&quot;,\n         &quot;address&quot;:&quot;1n31g4rKiEeXnZEZR6VZwm3LggLicEqEC&quot;,\n         &quot;value&quot;:1000000000,\n         &quot;script&quot;:&quot;76a914088465c1f0c8b3b3da06f7073a921d6b95b22f4988ac&quot;\n      }\n   ]\n}</code></pre><h2 id=\"比特币的脚本语言\"><a href=\"#比特币的脚本语言\" class=\"headerlink\" title=\"比特币的脚本语言\"></a>比特币的脚本语言</h2><pre><code>OP_DUP OP_HASH160 f9d49c5cf3e120ad1be60b67d868603a8fc945d2 OP_EQUALVERIFY OP_CHECKSIG</code></pre><p>上面是比特币交易中的交易输入解锁脚本，输入两个参数：<sig> <pubk> 使得<pubk>的HASH160值等于9d49c5cf3e120ad1be60b67d868603a8fc945d2，接着使用<pubk>验证<sig>签名，验证同步则表示该交易输入合法有效，就像用户名密码一样。</sig></pubk></pubk></pubk></sig></p>\n<p>比特币脚本语言是非图灵完备脚本语言，就是说它不能实现复杂的逻辑。<br>比特币脚本语言的执行是遵循先进后出的原因，即它的变量读取是堆栈式，如下图：</p>\n<p><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120509028.png\" alt><br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120508906.png\" alt></p>\n<h2 id=\"最终的结构\"><a href=\"#最终的结构\" class=\"headerlink\" title=\"最终的结构\"></a>最终的结构</h2><p>比特币就是通过每一个区块都有上一个区块的指正，每个区块中包含通过验证的合法交易组成的链式结构，并让所有节点同步这份数据，形成不可逆，串改成本巨大的分布式超级账本，称之为区块链<br><img src=\"../images/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/getImage-20220824120509220.png\" alt></p>\n<h1 id=\"比特币的价值及存在问题\"><a href=\"#比特币的价值及存在问题\" class=\"headerlink\" title=\"比特币的价值及存在问题\"></a>比特币的价值及存在问题</h1><p>比特币的价值在于，金融危机发生的时候，货币超发，法币贬值，社会财富缩水；<br>而比特币不依赖中央机构管理，期价值完全由供给关系决定，<br>当旧的法定货币崩溃时，人们便会涌向比特币，把比特币作为新的资产避风港——“21世纪版的黄金”<br>比特币是目前区块链技术落地最成功的项目，虽然比特币目前实际用的更多的是黑产（赌博、洗钱、黑客敲诈、传销），但是开创了人们对区块链技术无限探索和想象；</p>\n<p>但同样存在着问题：</p>\n<ul>\n<li>由于有新区块难度限制，每秒处理交易数不足7/sec，交易确认时间长大几小时甚至几天交易确认时间长大几小时甚至几天</li>\n<li>巨大的能源消耗（这也是比特币防篡改的代价）</li>\n<li>随着计算机算力的提升，构建数字货币的密码学可能会被攻破</li>\n<li>投机性强，泡沫大</li>\n<li>算力集中，随着挖矿难度增加，只有少数几个矿池能够维持挖矿成本，失去去中心化初衷</li>\n</ul>\n<h1 id=\"区块链的应用\"><a href=\"#区块链的应用\" class=\"headerlink\" title=\"区块链的应用\"></a>区块链的应用</h1><p>基于区块链的记录不可逆、去中心化、全民监管的特点来构建一个信任网络，降低<br>社会协同合作成本，主要应用如下：</p>\n<ul>\n<li>企业融资：企业可以通过发行代币的方式对投资者承诺未来能够通过代币购买</li>\n<li>公共实物：居于区块链上的登记的信息不可篡改，能够很方便的证明你的信息合法性</li>\n<li>公益：在当前大环境下，听到慈善、公益，心里就不是滋味——信息不透明、 监督困难；利用区块链技术能够追踪每一笔善款的去向</li>\n<li>供应链：结合物联网实现对物品信息的区块链管理，做到每个每个商品从生产到消费者的每一个环节，做到正品溯源；</li>\n<li>供应链金融：代理商可以低成本的通过货物抵押向供应商赊账，并利用区块链智能合约技术保证物品出售时自动回款给供应商</li>\n<li>物流：通过区块链技术做到CP间的信息信任，较少物流环节的信息交换成本，并通过区块链加密技术做到信息的保护。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>区块链为信息时代的去中心化信息交易提供了良好的解决思路</li>\n<li>区块链只是一种解决问题的技术，一定是结合实际场景落地才能有好的未来，否则就是技术人和投机者的一场狂欢。</li>\n<li>炒币有风险，入市需谨慎</li>\n</ul>\n<h1 id=\"了解区块链的一些网站：\"><a href=\"#了解区块链的一些网站：\" class=\"headerlink\" title=\"了解区块链的一些网站：\"></a>了解区块链的一些网站：</h1><p>区块链相关导航：<a href=\"https://www.feixiaohao.com/daohanglist/\" target=\"_blank\" rel=\"noopener\">https://www.feixiaohao.com/daohanglist/</a><br>比特币富豪排行榜：<a href=\"http://bitop.top/\" target=\"_blank\" rel=\"noopener\">http://bitop.top/</a><a href=\"http://bitop.top/\" target=\"_blank\" rel=\"noopener\">http://bitop.top/</a>)</p>\n"},{"_content":"任何学习都要有目标有规划，这是整个Java知识体系大纲，根据自己的知识体系认知画出来的，有很多还没有细化，也还有很多没有涉猎，比如大数据，列出这些好让自己学的有目标一些吧，也算是一个总结。\n\n在线预览地址：[http://naotu.baidu.com/file/a94181bfafe64d39874b524ce8df18c1?token=a8efb35e029a526f](http://naotu.baidu.com/file/a94181bfafe64d39874b524ce8df18c1?token=a8efb35e029a526f)\n\n![](../images/Java学习大纲/getImage-20220825184207294.png)\n\n\n来自网络的架构师大纲图：\n\n----------\n[Java架构VIP课程大纲5.1.png](https://leanote.com/api/file/getAttach?fileId=5d2c29a6ab64416644002311)","source":"_posts/后端&架构/Java学习大纲.md","raw":"任何学习都要有目标有规划，这是整个Java知识体系大纲，根据自己的知识体系认知画出来的，有很多还没有细化，也还有很多没有涉猎，比如大数据，列出这些好让自己学的有目标一些吧，也算是一个总结。\n\n在线预览地址：[http://naotu.baidu.com/file/a94181bfafe64d39874b524ce8df18c1?token=a8efb35e029a526f](http://naotu.baidu.com/file/a94181bfafe64d39874b524ce8df18c1?token=a8efb35e029a526f)\n\n![](../images/Java学习大纲/getImage-20220825184207294.png)\n\n\n来自网络的架构师大纲图：\n\n----------\n[Java架构VIP课程大纲5.1.png](https://leanote.com/api/file/getAttach?fileId=5d2c29a6ab64416644002311)","slug":"后端&架构/Java学习大纲","published":1,"date":"2022-08-25T10:41:57.938Z","updated":"2022-08-25T10:42:08.427Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78ycziq0013vwm1x4bwomwp","content":"<p>任何学习都要有目标有规划，这是整个Java知识体系大纲，根据自己的知识体系认知画出来的，有很多还没有细化，也还有很多没有涉猎，比如大数据，列出这些好让自己学的有目标一些吧，也算是一个总结。</p>\n<p>在线预览地址：<a href=\"http://naotu.baidu.com/file/a94181bfafe64d39874b524ce8df18c1?token=a8efb35e029a526f\" target=\"_blank\" rel=\"noopener\">http://naotu.baidu.com/file/a94181bfafe64d39874b524ce8df18c1?token=a8efb35e029a526f</a></p>\n<p><img src=\"../images/Java%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/getImage-20220825184207294.png\" alt></p>\n<p>来自网络的架构师大纲图：</p>\n<hr>\n<p><a href=\"https://leanote.com/api/file/getAttach?fileId=5d2c29a6ab64416644002311\" target=\"_blank\" rel=\"noopener\">Java架构VIP课程大纲5.1.png</a></p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<p>任何学习都要有目标有规划，这是整个Java知识体系大纲，根据自己的知识体系认知画出来的，有很多还没有细化，也还有很多没有涉猎，比如大数据，列出这些好让自己学的有目标一些吧，也算是一个总结。</p>\n<p>在线预览地址：<a href=\"http://naotu.baidu.com/file/a94181bfafe64d39874b524ce8df18c1?token=a8efb35e029a526f\" target=\"_blank\" rel=\"noopener\">http://naotu.baidu.com/file/a94181bfafe64d39874b524ce8df18c1?token=a8efb35e029a526f</a></p>\n<p><img src=\"../images/Java%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/getImage-20220825184207294.png\" alt></p>\n<p>来自网络的架构师大纲图：</p>\n<hr>\n<p><a href=\"https://leanote.com/api/file/getAttach?fileId=5d2c29a6ab64416644002311\" target=\"_blank\" rel=\"noopener\">Java架构VIP课程大纲5.1.png</a></p>\n"},{"title":"Dubbo源码学习","date":"2020-04-30T03:25:00.000Z","author":"okeeper","_content":"\n# Dubbo Provider暴露源码分析\nDubbo服务端的服务暴露及初始化\n\n1. `org.apache.dubbo.config.spring.ServiceBean#afterPropertiesSet` 开始spring 容器初始化好属性后，回调这个方法开始初始化Provider\n2. 前面一堆是初始化`ApplicationConfig`、`Module`、`Registry`(注册中心)、`ConfigCenter`(配置中心)、`Monitor`（监控中心）、`Metrics`(监控项)、`Service`(服务bean)\n3. 接着找到`org.apache.dubbo.config.ServiceConfig#doExportUrls;`\n    1. 主要看 `org.apache.dubbo.config.ServiceConfig#doExportUrlsFor1Protocol`\n    2. 这个方法主要是构建Invoker代理，然后用`Exporter<?> exporter = protocol.export(wrapperInvoker);` 通过SPI加载默认`DubboProtocol`.\n    3. 进入`org.apache.dubbo.rpc.DubboProtocol#export`之后我们看到一个`openServer`调用,初始化一个Server\n    4. 进入`org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#openServer`，主要调用`createServer`\n    5. 进入`org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#createServer`,调用了一个静态方法`Exchangers#bind()`\n    6. 进入`org.apache.dubbo.remoting.exchange.Exchangers#bind`,入参是当前要暴露服务的URL和一个`requestHandler`, requestHandler实现在 `org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#requestHandler`里\n     1. 进入`Exchangers#bind`,调用了 `org.apache.dubbo.remoting.exchange.Exchangers#getExchanger(org.apache.dubbo.common.URL)`获取当前暴露服务URL的个性化`Exchanger`配置，默认加载`org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger`\n     2. 进入`HeaderExchanger`,有两个方法实现分别为`bind`和 `connect`,看样子一个事用于Server端暴露服务，一个事用于Client来请求服务\n     3. 主要看`org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger#bind`,调用了`Transporters#bind()`，这里吧requestHandler进行包装成了一个`org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#HeaderExchangeHandler`\n     4. 进入`org.apache.dubbo.remoting.Transporters#bind()`，看到默认加载的是nett4的`org.apache.dubbo.remoting.transport.netty4.NettyTransporter#bind()`,而这个实现主要是new了一个`org.apache.dubbo.remoting.transport.netty4.NettyServer#NettyServer`,到此一个Provider的Invoker代理就绑定到NettyServer里可以对外提供服务了\n     5. 在`NettyServer`的构造方法中，调用了`org.apache.dubbo.remoting.transport.dispatcher.ChannelHandlers#wrap`,将HeaderExchangeHandler进行一个`Dispatcher`的分发，默认实现是`org.apache.dubbo.remoting.transport.dispatcher.all.AllDispatcher`,除此之外还有`ConnectionOrderedDispatcher`、`DirectDispatcher`、`ExecutionDispatcher`、`MessageOnlyDispatcher`，这里不做展开\n     6. 在AllDispatcher中的dispatch实现是`AllChannelHandler`,所有类型的请求都可以接受处理\n     7. 进入`org.apache.dubbo.remoting.transport.dispatcher.all.AllChannelHandler#received`,我们看到它将接收到的请求丢到一个`ExecutorService`线程池中异步处理，这里就是Dubbo线程处理的核心了\n    7. 我们回到第6步，这里说到默认的handler是`org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#requestHandler`, 这个requestHandler被6.3包装成了`org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#HeaderExchangeHandler`\n    8. 进入`org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#HeaderExchangeHandler`,这是NIO请求的处理handler,我们了解NIO的Channel是双向通信的，所以当接收到请求时和响应时都会进入到`received`,当出现异常时进入`caught`\n        1. 我们先来看`org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#received`,主要判断是请求还是响应，如果是请求判断是否是否有响应，如果是`towWay`通信，即有响应结果的请求，进入`org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#handleRequest`\n        2. 在这里调用了一开始传入的requestHandler#reply,实在在`org.apache.dubbo.remoting.exchange.support.ExchangeHandlerAdapter`，这里就是具体调用找到具体要请求的Provider的Invoker，异步请求并返回一个Feature，然后在当前received方法中进行异步等待，等待响应结果完成send进channel进行响应\n4. 发布到注册中心","source":"_posts/学习/Dubbo源码学习.md","raw":"---\ntitle: Dubbo源码学习\ndate: 2020-4-30 11:25:00\nauthor: okeeper\ncategories: 学习\ntags:\n  - Dubbo\n  - 学习\n---\n\n# Dubbo Provider暴露源码分析\nDubbo服务端的服务暴露及初始化\n\n1. `org.apache.dubbo.config.spring.ServiceBean#afterPropertiesSet` 开始spring 容器初始化好属性后，回调这个方法开始初始化Provider\n2. 前面一堆是初始化`ApplicationConfig`、`Module`、`Registry`(注册中心)、`ConfigCenter`(配置中心)、`Monitor`（监控中心）、`Metrics`(监控项)、`Service`(服务bean)\n3. 接着找到`org.apache.dubbo.config.ServiceConfig#doExportUrls;`\n    1. 主要看 `org.apache.dubbo.config.ServiceConfig#doExportUrlsFor1Protocol`\n    2. 这个方法主要是构建Invoker代理，然后用`Exporter<?> exporter = protocol.export(wrapperInvoker);` 通过SPI加载默认`DubboProtocol`.\n    3. 进入`org.apache.dubbo.rpc.DubboProtocol#export`之后我们看到一个`openServer`调用,初始化一个Server\n    4. 进入`org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#openServer`，主要调用`createServer`\n    5. 进入`org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#createServer`,调用了一个静态方法`Exchangers#bind()`\n    6. 进入`org.apache.dubbo.remoting.exchange.Exchangers#bind`,入参是当前要暴露服务的URL和一个`requestHandler`, requestHandler实现在 `org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#requestHandler`里\n     1. 进入`Exchangers#bind`,调用了 `org.apache.dubbo.remoting.exchange.Exchangers#getExchanger(org.apache.dubbo.common.URL)`获取当前暴露服务URL的个性化`Exchanger`配置，默认加载`org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger`\n     2. 进入`HeaderExchanger`,有两个方法实现分别为`bind`和 `connect`,看样子一个事用于Server端暴露服务，一个事用于Client来请求服务\n     3. 主要看`org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger#bind`,调用了`Transporters#bind()`，这里吧requestHandler进行包装成了一个`org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#HeaderExchangeHandler`\n     4. 进入`org.apache.dubbo.remoting.Transporters#bind()`，看到默认加载的是nett4的`org.apache.dubbo.remoting.transport.netty4.NettyTransporter#bind()`,而这个实现主要是new了一个`org.apache.dubbo.remoting.transport.netty4.NettyServer#NettyServer`,到此一个Provider的Invoker代理就绑定到NettyServer里可以对外提供服务了\n     5. 在`NettyServer`的构造方法中，调用了`org.apache.dubbo.remoting.transport.dispatcher.ChannelHandlers#wrap`,将HeaderExchangeHandler进行一个`Dispatcher`的分发，默认实现是`org.apache.dubbo.remoting.transport.dispatcher.all.AllDispatcher`,除此之外还有`ConnectionOrderedDispatcher`、`DirectDispatcher`、`ExecutionDispatcher`、`MessageOnlyDispatcher`，这里不做展开\n     6. 在AllDispatcher中的dispatch实现是`AllChannelHandler`,所有类型的请求都可以接受处理\n     7. 进入`org.apache.dubbo.remoting.transport.dispatcher.all.AllChannelHandler#received`,我们看到它将接收到的请求丢到一个`ExecutorService`线程池中异步处理，这里就是Dubbo线程处理的核心了\n    7. 我们回到第6步，这里说到默认的handler是`org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#requestHandler`, 这个requestHandler被6.3包装成了`org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#HeaderExchangeHandler`\n    8. 进入`org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#HeaderExchangeHandler`,这是NIO请求的处理handler,我们了解NIO的Channel是双向通信的，所以当接收到请求时和响应时都会进入到`received`,当出现异常时进入`caught`\n        1. 我们先来看`org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#received`,主要判断是请求还是响应，如果是请求判断是否是否有响应，如果是`towWay`通信，即有响应结果的请求，进入`org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#handleRequest`\n        2. 在这里调用了一开始传入的requestHandler#reply,实在在`org.apache.dubbo.remoting.exchange.support.ExchangeHandlerAdapter`，这里就是具体调用找到具体要请求的Provider的Invoker，异步请求并返回一个Feature，然后在当前received方法中进行异步等待，等待响应结果完成send进channel进行响应\n4. 发布到注册中心","slug":"学习/Dubbo源码学习","published":1,"updated":"2022-08-25T10:52:25.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczis0014vwm1vwt1q90f","content":"<h1 id=\"Dubbo-Provider暴露源码分析\"><a href=\"#Dubbo-Provider暴露源码分析\" class=\"headerlink\" title=\"Dubbo Provider暴露源码分析\"></a>Dubbo Provider暴露源码分析</h1><p>Dubbo服务端的服务暴露及初始化</p>\n<ol>\n<li><code>org.apache.dubbo.config.spring.ServiceBean#afterPropertiesSet</code> 开始spring 容器初始化好属性后，回调这个方法开始初始化Provider</li>\n<li>前面一堆是初始化<code>ApplicationConfig</code>、<code>Module</code>、<code>Registry</code>(注册中心)、<code>ConfigCenter</code>(配置中心)、<code>Monitor</code>（监控中心）、<code>Metrics</code>(监控项)、<code>Service</code>(服务bean)</li>\n<li>接着找到<code>org.apache.dubbo.config.ServiceConfig#doExportUrls;</code><ol>\n<li>主要看 <code>org.apache.dubbo.config.ServiceConfig#doExportUrlsFor1Protocol</code></li>\n<li>这个方法主要是构建Invoker代理，然后用<code>Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</code> 通过SPI加载默认<code>DubboProtocol</code>.</li>\n<li>进入<code>org.apache.dubbo.rpc.DubboProtocol#export</code>之后我们看到一个<code>openServer</code>调用,初始化一个Server</li>\n<li>进入<code>org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#openServer</code>，主要调用<code>createServer</code></li>\n<li>进入<code>org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#createServer</code>,调用了一个静态方法<code>Exchangers#bind()</code></li>\n<li>进入<code>org.apache.dubbo.remoting.exchange.Exchangers#bind</code>,入参是当前要暴露服务的URL和一个<code>requestHandler</code>, requestHandler实现在 <code>org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#requestHandler</code>里<ol>\n<li>进入<code>Exchangers#bind</code>,调用了 <code>org.apache.dubbo.remoting.exchange.Exchangers#getExchanger(org.apache.dubbo.common.URL)</code>获取当前暴露服务URL的个性化<code>Exchanger</code>配置，默认加载<code>org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger</code></li>\n<li>进入<code>HeaderExchanger</code>,有两个方法实现分别为<code>bind</code>和 <code>connect</code>,看样子一个事用于Server端暴露服务，一个事用于Client来请求服务</li>\n<li>主要看<code>org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger#bind</code>,调用了<code>Transporters#bind()</code>，这里吧requestHandler进行包装成了一个<code>org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#HeaderExchangeHandler</code></li>\n<li>进入<code>org.apache.dubbo.remoting.Transporters#bind()</code>，看到默认加载的是nett4的<code>org.apache.dubbo.remoting.transport.netty4.NettyTransporter#bind()</code>,而这个实现主要是new了一个<code>org.apache.dubbo.remoting.transport.netty4.NettyServer#NettyServer</code>,到此一个Provider的Invoker代理就绑定到NettyServer里可以对外提供服务了</li>\n<li>在<code>NettyServer</code>的构造方法中，调用了<code>org.apache.dubbo.remoting.transport.dispatcher.ChannelHandlers#wrap</code>,将HeaderExchangeHandler进行一个<code>Dispatcher</code>的分发，默认实现是<code>org.apache.dubbo.remoting.transport.dispatcher.all.AllDispatcher</code>,除此之外还有<code>ConnectionOrderedDispatcher</code>、<code>DirectDispatcher</code>、<code>ExecutionDispatcher</code>、<code>MessageOnlyDispatcher</code>，这里不做展开</li>\n<li>在AllDispatcher中的dispatch实现是<code>AllChannelHandler</code>,所有类型的请求都可以接受处理</li>\n<li>进入<code>org.apache.dubbo.remoting.transport.dispatcher.all.AllChannelHandler#received</code>,我们看到它将接收到的请求丢到一个<code>ExecutorService</code>线程池中异步处理，这里就是Dubbo线程处理的核心了</li>\n</ol>\n</li>\n<li>我们回到第6步，这里说到默认的handler是<code>org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#requestHandler</code>, 这个requestHandler被6.3包装成了<code>org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#HeaderExchangeHandler</code></li>\n<li>进入<code>org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#HeaderExchangeHandler</code>,这是NIO请求的处理handler,我们了解NIO的Channel是双向通信的，所以当接收到请求时和响应时都会进入到<code>received</code>,当出现异常时进入<code>caught</code><ol>\n<li>我们先来看<code>org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#received</code>,主要判断是请求还是响应，如果是请求判断是否是否有响应，如果是<code>towWay</code>通信，即有响应结果的请求，进入<code>org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#handleRequest</code></li>\n<li>在这里调用了一开始传入的requestHandler#reply,实在在<code>org.apache.dubbo.remoting.exchange.support.ExchangeHandlerAdapter</code>，这里就是具体调用找到具体要请求的Provider的Invoker，异步请求并返回一个Feature，然后在当前received方法中进行异步等待，等待响应结果完成send进channel进行响应</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>发布到注册中心</li>\n</ol>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"Dubbo-Provider暴露源码分析\"><a href=\"#Dubbo-Provider暴露源码分析\" class=\"headerlink\" title=\"Dubbo Provider暴露源码分析\"></a>Dubbo Provider暴露源码分析</h1><p>Dubbo服务端的服务暴露及初始化</p>\n<ol>\n<li><code>org.apache.dubbo.config.spring.ServiceBean#afterPropertiesSet</code> 开始spring 容器初始化好属性后，回调这个方法开始初始化Provider</li>\n<li>前面一堆是初始化<code>ApplicationConfig</code>、<code>Module</code>、<code>Registry</code>(注册中心)、<code>ConfigCenter</code>(配置中心)、<code>Monitor</code>（监控中心）、<code>Metrics</code>(监控项)、<code>Service</code>(服务bean)</li>\n<li>接着找到<code>org.apache.dubbo.config.ServiceConfig#doExportUrls;</code><ol>\n<li>主要看 <code>org.apache.dubbo.config.ServiceConfig#doExportUrlsFor1Protocol</code></li>\n<li>这个方法主要是构建Invoker代理，然后用<code>Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</code> 通过SPI加载默认<code>DubboProtocol</code>.</li>\n<li>进入<code>org.apache.dubbo.rpc.DubboProtocol#export</code>之后我们看到一个<code>openServer</code>调用,初始化一个Server</li>\n<li>进入<code>org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#openServer</code>，主要调用<code>createServer</code></li>\n<li>进入<code>org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#createServer</code>,调用了一个静态方法<code>Exchangers#bind()</code></li>\n<li>进入<code>org.apache.dubbo.remoting.exchange.Exchangers#bind</code>,入参是当前要暴露服务的URL和一个<code>requestHandler</code>, requestHandler实现在 <code>org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#requestHandler</code>里<ol>\n<li>进入<code>Exchangers#bind</code>,调用了 <code>org.apache.dubbo.remoting.exchange.Exchangers#getExchanger(org.apache.dubbo.common.URL)</code>获取当前暴露服务URL的个性化<code>Exchanger</code>配置，默认加载<code>org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger</code></li>\n<li>进入<code>HeaderExchanger</code>,有两个方法实现分别为<code>bind</code>和 <code>connect</code>,看样子一个事用于Server端暴露服务，一个事用于Client来请求服务</li>\n<li>主要看<code>org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger#bind</code>,调用了<code>Transporters#bind()</code>，这里吧requestHandler进行包装成了一个<code>org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#HeaderExchangeHandler</code></li>\n<li>进入<code>org.apache.dubbo.remoting.Transporters#bind()</code>，看到默认加载的是nett4的<code>org.apache.dubbo.remoting.transport.netty4.NettyTransporter#bind()</code>,而这个实现主要是new了一个<code>org.apache.dubbo.remoting.transport.netty4.NettyServer#NettyServer</code>,到此一个Provider的Invoker代理就绑定到NettyServer里可以对外提供服务了</li>\n<li>在<code>NettyServer</code>的构造方法中，调用了<code>org.apache.dubbo.remoting.transport.dispatcher.ChannelHandlers#wrap</code>,将HeaderExchangeHandler进行一个<code>Dispatcher</code>的分发，默认实现是<code>org.apache.dubbo.remoting.transport.dispatcher.all.AllDispatcher</code>,除此之外还有<code>ConnectionOrderedDispatcher</code>、<code>DirectDispatcher</code>、<code>ExecutionDispatcher</code>、<code>MessageOnlyDispatcher</code>，这里不做展开</li>\n<li>在AllDispatcher中的dispatch实现是<code>AllChannelHandler</code>,所有类型的请求都可以接受处理</li>\n<li>进入<code>org.apache.dubbo.remoting.transport.dispatcher.all.AllChannelHandler#received</code>,我们看到它将接收到的请求丢到一个<code>ExecutorService</code>线程池中异步处理，这里就是Dubbo线程处理的核心了</li>\n</ol>\n</li>\n<li>我们回到第6步，这里说到默认的handler是<code>org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#requestHandler</code>, 这个requestHandler被6.3包装成了<code>org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#HeaderExchangeHandler</code></li>\n<li>进入<code>org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#HeaderExchangeHandler</code>,这是NIO请求的处理handler,我们了解NIO的Channel是双向通信的，所以当接收到请求时和响应时都会进入到<code>received</code>,当出现异常时进入<code>caught</code><ol>\n<li>我们先来看<code>org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#received</code>,主要判断是请求还是响应，如果是请求判断是否是否有响应，如果是<code>towWay</code>通信，即有响应结果的请求，进入<code>org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#handleRequest</code></li>\n<li>在这里调用了一开始传入的requestHandler#reply,实在在<code>org.apache.dubbo.remoting.exchange.support.ExchangeHandlerAdapter</code>，这里就是具体调用找到具体要请求的Provider的Invoker，异步请求并返回一个Feature，然后在当前received方法中进行异步等待，等待响应结果完成send进channel进行响应</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>发布到注册中心</li>\n</ol>\n"},{"title":"操作系统原理——进程管理","date":"2021-07-10T06:25:00.000Z","author":"okeeper","_content":"# 一、进程的概念\n1. 进程是允许并发的程序在某个数据集合上运行的过程\n2. 进程是**正文段**、**用户数据段**和**进程控制块**共同组成的执行环境。\n\n# 二、进程与程序的区别\n1. 程序是静态的，进程是动态的\n2. 程序是永久的，进程是暂时存在的\n3. 程序和进程存在的实体不同。程序是指令的集合，进程是由正文段、用户数据段、进程控制块组成\n\n# 三、进程与程序的关系\n进程是程序的一次执行，进程总是对于一个特定的程序，一个程序可以对于多个进程\n\n# 四、进程的组成部分\n## 正文段\n正文段存放被执行的激情指令\n## 用户数据\n用户数据段存放进程在执行时要操作的用户数据\n## 进程控制块\n是操作系统管理进程所使用的数据结构\n进程控制块是实体的一部分，是操作系统重要的数据结构，进程控制块中记录了操作系统所需要的，用户描述进程情况以及控制运行所需要的全部信息，进程控制块是操作系统感知进程存在的唯一标志。\n\n# 五、进程管理\n1. 进程的状态信息：就绪态、执行态、阻塞态\n2. 进程的组织方式：链接方式、索引方式、进程队列\n3. 进程的控制：进程的创建---阻塞---唤醒---终止\n4. 进程的创建条件：1) 用户登录 2)作业调度 3)提供服务 4)应用请求\n5. 阻塞条件： 1)请求系统服务 2)数据尚未到达 3)无工作可做 4)启动某种操作\n\n## 操作系统内核\n操作系统内核是指系统与硬件密切相关、执行频率高的模块，一般常驻内存。\n\n### 操作系统内核的功能\n1. 支持功能\n支撑功能包括：中断处理、时钟管理和原语操作，其中原语操作是一组在执行过程中不能中断的操作\n\n2. 资源管理功能\n资源管理功能包括：进程的管理、存储器管理和设备管理\n\n####中断\n\n中断时改变计算机执行指令的顺序的一种事件，这种事件与cpu芯片内外部硬件电路参数的电信号对应。\n\n**中断的目的**：能够有效提高cpu的利用率，改善系统性能，支持系统的异步性。例如在引用中断机制之前，采用的是发福轮询的方式来检测本次I/O是否结束。\n\n**中断的类型**：\n1. 同步中断：当指令执行时由cpu控制段元产生的，如除法出错，调试、溢出、浮点出错等\n2. 异步中断（外部中断）：是由其他硬件设备随机产生的，可分为外部可屏蔽中断（I/O设备产生）和外部不可屏蔽中断(紧急事件产生，硬件故障等)\n\n**引起中断的原因**：1)人为设置中断 2)程序性事故 3)I/O设备 4)硬件故障 5)外部事件\n\n## 时钟管理\n计算机很多活动都是有定时测量来控制的，两种定时测量 1) 保存当前的系统事件和日期 2)维持定时器，操作系统依靠时钟硬件和时钟驱动程序完成上述两种测量\n\n**时钟硬件**：按照指定时间间隔产生时钟中断，测量逝去的时间，并触发与时间有关的操作\n**时钟软件**：维护日期和时间，递减当前进程在一个时间片内的剩余执行时间，对cpu的使用情况记账，递减报警计算器\n\n**时钟源**：实时时钟（RTC/CMOS）/OS时钟\n\n## 系统调用与一般函数\n系统调用是一群实现定义好的模块，他们提供一条管道让应用程序或用户能由此得到核心程序的服务。系统调用时系统程序与用户程序之间的接口。\n\n系统调用与一般函数的区别：\n1) 系统调用运行在系统态，一般函数运行在用户态\n2) 系统调用与一般函数的执行过程不同，系统调用中断时，有系统找到对于的系统调用子程序\n3) 系统调用要进行[中断处理],比一般函数多一些系统开销\n\n## 进程同步：\n操作系统同步机制的主要任务就是保证在多任务共享系统资源的情况下，程序能够得到正确的结果。同时，同步机制需要解决进程执行的协调问题。\n\n进程同步有两个作用\n1. 对具有共享资源的进程，保住以互斥的方式访问临界资源。临界资源必须以互斥的方式访问共享资源\n2. 对具有相互合作关系的进程，要保证相互合作的各个进程协调执行\n\n**同步机制遵循的准则**： 1)空闲让进 2)忙则等待 3)有限等待 4) 让权等待\n\n## 信号量机制\n信号量机制对不同共享资源设置称之为信号量的变量，用信号量的取值标识资源的使用情况，或某种事件的发生\n\n### 整形信号量机制\n用整形来标记资源的使用情况。若整形量>0,说明有资源可用；若整形量<=0，说明资源忙，进程必须等待。\n\n### 记录型信号量机制\n除了用整形来标记资源的使用情况外，额外使用一个记录进程队列来存储等待资源的进程。这样就不存在“忙等”，而是通过有可用资源时的回调触发\n\n### AND型信号量的机制\n基本思想是将进程在整个运行过程中所需要的所有资源一次性的全部分配给进程，待进程使用完后再一起释放。\n\n# 六、线程\n在操作系统中，进程是进行资源分配和独立执行的基本单位，为了进一步提高程序的并发性，减少系统的开销，在操作系统中引入了线程的概念。\n线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程在运行中断性，也有就绪、执行、阻塞三种状态。","source":"_posts/操作系统原理/操作系统原理——进程管理.md","raw":"---\ntitle: 操作系统原理——进程管理\ndate: 2021-07-10 14:25:00\nauthor: okeeper\ncategories: 操作系统原理\ntags:\n  - 操作系统原理\n---\n# 一、进程的概念\n1. 进程是允许并发的程序在某个数据集合上运行的过程\n2. 进程是**正文段**、**用户数据段**和**进程控制块**共同组成的执行环境。\n\n# 二、进程与程序的区别\n1. 程序是静态的，进程是动态的\n2. 程序是永久的，进程是暂时存在的\n3. 程序和进程存在的实体不同。程序是指令的集合，进程是由正文段、用户数据段、进程控制块组成\n\n# 三、进程与程序的关系\n进程是程序的一次执行，进程总是对于一个特定的程序，一个程序可以对于多个进程\n\n# 四、进程的组成部分\n## 正文段\n正文段存放被执行的激情指令\n## 用户数据\n用户数据段存放进程在执行时要操作的用户数据\n## 进程控制块\n是操作系统管理进程所使用的数据结构\n进程控制块是实体的一部分，是操作系统重要的数据结构，进程控制块中记录了操作系统所需要的，用户描述进程情况以及控制运行所需要的全部信息，进程控制块是操作系统感知进程存在的唯一标志。\n\n# 五、进程管理\n1. 进程的状态信息：就绪态、执行态、阻塞态\n2. 进程的组织方式：链接方式、索引方式、进程队列\n3. 进程的控制：进程的创建---阻塞---唤醒---终止\n4. 进程的创建条件：1) 用户登录 2)作业调度 3)提供服务 4)应用请求\n5. 阻塞条件： 1)请求系统服务 2)数据尚未到达 3)无工作可做 4)启动某种操作\n\n## 操作系统内核\n操作系统内核是指系统与硬件密切相关、执行频率高的模块，一般常驻内存。\n\n### 操作系统内核的功能\n1. 支持功能\n支撑功能包括：中断处理、时钟管理和原语操作，其中原语操作是一组在执行过程中不能中断的操作\n\n2. 资源管理功能\n资源管理功能包括：进程的管理、存储器管理和设备管理\n\n####中断\n\n中断时改变计算机执行指令的顺序的一种事件，这种事件与cpu芯片内外部硬件电路参数的电信号对应。\n\n**中断的目的**：能够有效提高cpu的利用率，改善系统性能，支持系统的异步性。例如在引用中断机制之前，采用的是发福轮询的方式来检测本次I/O是否结束。\n\n**中断的类型**：\n1. 同步中断：当指令执行时由cpu控制段元产生的，如除法出错，调试、溢出、浮点出错等\n2. 异步中断（外部中断）：是由其他硬件设备随机产生的，可分为外部可屏蔽中断（I/O设备产生）和外部不可屏蔽中断(紧急事件产生，硬件故障等)\n\n**引起中断的原因**：1)人为设置中断 2)程序性事故 3)I/O设备 4)硬件故障 5)外部事件\n\n## 时钟管理\n计算机很多活动都是有定时测量来控制的，两种定时测量 1) 保存当前的系统事件和日期 2)维持定时器，操作系统依靠时钟硬件和时钟驱动程序完成上述两种测量\n\n**时钟硬件**：按照指定时间间隔产生时钟中断，测量逝去的时间，并触发与时间有关的操作\n**时钟软件**：维护日期和时间，递减当前进程在一个时间片内的剩余执行时间，对cpu的使用情况记账，递减报警计算器\n\n**时钟源**：实时时钟（RTC/CMOS）/OS时钟\n\n## 系统调用与一般函数\n系统调用是一群实现定义好的模块，他们提供一条管道让应用程序或用户能由此得到核心程序的服务。系统调用时系统程序与用户程序之间的接口。\n\n系统调用与一般函数的区别：\n1) 系统调用运行在系统态，一般函数运行在用户态\n2) 系统调用与一般函数的执行过程不同，系统调用中断时，有系统找到对于的系统调用子程序\n3) 系统调用要进行[中断处理],比一般函数多一些系统开销\n\n## 进程同步：\n操作系统同步机制的主要任务就是保证在多任务共享系统资源的情况下，程序能够得到正确的结果。同时，同步机制需要解决进程执行的协调问题。\n\n进程同步有两个作用\n1. 对具有共享资源的进程，保住以互斥的方式访问临界资源。临界资源必须以互斥的方式访问共享资源\n2. 对具有相互合作关系的进程，要保证相互合作的各个进程协调执行\n\n**同步机制遵循的准则**： 1)空闲让进 2)忙则等待 3)有限等待 4) 让权等待\n\n## 信号量机制\n信号量机制对不同共享资源设置称之为信号量的变量，用信号量的取值标识资源的使用情况，或某种事件的发生\n\n### 整形信号量机制\n用整形来标记资源的使用情况。若整形量>0,说明有资源可用；若整形量<=0，说明资源忙，进程必须等待。\n\n### 记录型信号量机制\n除了用整形来标记资源的使用情况外，额外使用一个记录进程队列来存储等待资源的进程。这样就不存在“忙等”，而是通过有可用资源时的回调触发\n\n### AND型信号量的机制\n基本思想是将进程在整个运行过程中所需要的所有资源一次性的全部分配给进程，待进程使用完后再一起释放。\n\n# 六、线程\n在操作系统中，进程是进行资源分配和独立执行的基本单位，为了进一步提高程序的并发性，减少系统的开销，在操作系统中引入了线程的概念。\n线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程在运行中断性，也有就绪、执行、阻塞三种状态。","slug":"操作系统原理/操作系统原理——进程管理","published":1,"updated":"2022-08-25T09:12:12.942Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczit0015vwm18822ynaz","content":"<h1 id=\"一、进程的概念\"><a href=\"#一、进程的概念\" class=\"headerlink\" title=\"一、进程的概念\"></a>一、进程的概念</h1><ol>\n<li>进程是允许并发的程序在某个数据集合上运行的过程</li>\n<li>进程是<strong>正文段</strong>、<strong>用户数据段</strong>和<strong>进程控制块</strong>共同组成的执行环境。</li>\n</ol>\n<h1 id=\"二、进程与程序的区别\"><a href=\"#二、进程与程序的区别\" class=\"headerlink\" title=\"二、进程与程序的区别\"></a>二、进程与程序的区别</h1><ol>\n<li>程序是静态的，进程是动态的</li>\n<li>程序是永久的，进程是暂时存在的</li>\n<li>程序和进程存在的实体不同。程序是指令的集合，进程是由正文段、用户数据段、进程控制块组成</li>\n</ol>\n<h1 id=\"三、进程与程序的关系\"><a href=\"#三、进程与程序的关系\" class=\"headerlink\" title=\"三、进程与程序的关系\"></a>三、进程与程序的关系</h1><p>进程是程序的一次执行，进程总是对于一个特定的程序，一个程序可以对于多个进程</p>\n<h1 id=\"四、进程的组成部分\"><a href=\"#四、进程的组成部分\" class=\"headerlink\" title=\"四、进程的组成部分\"></a>四、进程的组成部分</h1><h2 id=\"正文段\"><a href=\"#正文段\" class=\"headerlink\" title=\"正文段\"></a>正文段</h2><p>正文段存放被执行的激情指令</p>\n<h2 id=\"用户数据\"><a href=\"#用户数据\" class=\"headerlink\" title=\"用户数据\"></a>用户数据</h2><p>用户数据段存放进程在执行时要操作的用户数据</p>\n<h2 id=\"进程控制块\"><a href=\"#进程控制块\" class=\"headerlink\" title=\"进程控制块\"></a>进程控制块</h2><p>是操作系统管理进程所使用的数据结构<br>进程控制块是实体的一部分，是操作系统重要的数据结构，进程控制块中记录了操作系统所需要的，用户描述进程情况以及控制运行所需要的全部信息，进程控制块是操作系统感知进程存在的唯一标志。</p>\n<h1 id=\"五、进程管理\"><a href=\"#五、进程管理\" class=\"headerlink\" title=\"五、进程管理\"></a>五、进程管理</h1><ol>\n<li>进程的状态信息：就绪态、执行态、阻塞态</li>\n<li>进程的组织方式：链接方式、索引方式、进程队列</li>\n<li>进程的控制：进程的创建—阻塞—唤醒—终止</li>\n<li>进程的创建条件：1) 用户登录 2)作业调度 3)提供服务 4)应用请求</li>\n<li>阻塞条件： 1)请求系统服务 2)数据尚未到达 3)无工作可做 4)启动某种操作</li>\n</ol>\n<h2 id=\"操作系统内核\"><a href=\"#操作系统内核\" class=\"headerlink\" title=\"操作系统内核\"></a>操作系统内核</h2><p>操作系统内核是指系统与硬件密切相关、执行频率高的模块，一般常驻内存。</p>\n<h3 id=\"操作系统内核的功能\"><a href=\"#操作系统内核的功能\" class=\"headerlink\" title=\"操作系统内核的功能\"></a>操作系统内核的功能</h3><ol>\n<li><p>支持功能<br>支撑功能包括：中断处理、时钟管理和原语操作，其中原语操作是一组在执行过程中不能中断的操作</p>\n</li>\n<li><p>资源管理功能<br>资源管理功能包括：进程的管理、存储器管理和设备管理</p>\n</li>\n</ol>\n<p>####中断</p>\n<p>中断时改变计算机执行指令的顺序的一种事件，这种事件与cpu芯片内外部硬件电路参数的电信号对应。</p>\n<p><strong>中断的目的</strong>：能够有效提高cpu的利用率，改善系统性能，支持系统的异步性。例如在引用中断机制之前，采用的是发福轮询的方式来检测本次I/O是否结束。</p>\n<p><strong>中断的类型</strong>：</p>\n<ol>\n<li>同步中断：当指令执行时由cpu控制段元产生的，如除法出错，调试、溢出、浮点出错等</li>\n<li>异步中断（外部中断）：是由其他硬件设备随机产生的，可分为外部可屏蔽中断（I/O设备产生）和外部不可屏蔽中断(紧急事件产生，硬件故障等)</li>\n</ol>\n<p><strong>引起中断的原因</strong>：1)人为设置中断 2)程序性事故 3)I/O设备 4)硬件故障 5)外部事件</p>\n<h2 id=\"时钟管理\"><a href=\"#时钟管理\" class=\"headerlink\" title=\"时钟管理\"></a>时钟管理</h2><p>计算机很多活动都是有定时测量来控制的，两种定时测量 1) 保存当前的系统事件和日期 2)维持定时器，操作系统依靠时钟硬件和时钟驱动程序完成上述两种测量</p>\n<p><strong>时钟硬件</strong>：按照指定时间间隔产生时钟中断，测量逝去的时间，并触发与时间有关的操作<br><strong>时钟软件</strong>：维护日期和时间，递减当前进程在一个时间片内的剩余执行时间，对cpu的使用情况记账，递减报警计算器</p>\n<p><strong>时钟源</strong>：实时时钟（RTC/CMOS）/OS时钟</p>\n<h2 id=\"系统调用与一般函数\"><a href=\"#系统调用与一般函数\" class=\"headerlink\" title=\"系统调用与一般函数\"></a>系统调用与一般函数</h2><p>系统调用是一群实现定义好的模块，他们提供一条管道让应用程序或用户能由此得到核心程序的服务。系统调用时系统程序与用户程序之间的接口。</p>\n<p>系统调用与一般函数的区别：<br>1) 系统调用运行在系统态，一般函数运行在用户态<br>2) 系统调用与一般函数的执行过程不同，系统调用中断时，有系统找到对于的系统调用子程序<br>3) 系统调用要进行[中断处理],比一般函数多一些系统开销</p>\n<h2 id=\"进程同步：\"><a href=\"#进程同步：\" class=\"headerlink\" title=\"进程同步：\"></a>进程同步：</h2><p>操作系统同步机制的主要任务就是保证在多任务共享系统资源的情况下，程序能够得到正确的结果。同时，同步机制需要解决进程执行的协调问题。</p>\n<p>进程同步有两个作用</p>\n<ol>\n<li>对具有共享资源的进程，保住以互斥的方式访问临界资源。临界资源必须以互斥的方式访问共享资源</li>\n<li>对具有相互合作关系的进程，要保证相互合作的各个进程协调执行</li>\n</ol>\n<p><strong>同步机制遵循的准则</strong>： 1)空闲让进 2)忙则等待 3)有限等待 4) 让权等待</p>\n<h2 id=\"信号量机制\"><a href=\"#信号量机制\" class=\"headerlink\" title=\"信号量机制\"></a>信号量机制</h2><p>信号量机制对不同共享资源设置称之为信号量的变量，用信号量的取值标识资源的使用情况，或某种事件的发生</p>\n<h3 id=\"整形信号量机制\"><a href=\"#整形信号量机制\" class=\"headerlink\" title=\"整形信号量机制\"></a>整形信号量机制</h3><p>用整形来标记资源的使用情况。若整形量&gt;0,说明有资源可用；若整形量&lt;=0，说明资源忙，进程必须等待。</p>\n<h3 id=\"记录型信号量机制\"><a href=\"#记录型信号量机制\" class=\"headerlink\" title=\"记录型信号量机制\"></a>记录型信号量机制</h3><p>除了用整形来标记资源的使用情况外，额外使用一个记录进程队列来存储等待资源的进程。这样就不存在“忙等”，而是通过有可用资源时的回调触发</p>\n<h3 id=\"AND型信号量的机制\"><a href=\"#AND型信号量的机制\" class=\"headerlink\" title=\"AND型信号量的机制\"></a>AND型信号量的机制</h3><p>基本思想是将进程在整个运行过程中所需要的所有资源一次性的全部分配给进程，待进程使用完后再一起释放。</p>\n<h1 id=\"六、线程\"><a href=\"#六、线程\" class=\"headerlink\" title=\"六、线程\"></a>六、线程</h1><p>在操作系统中，进程是进行资源分配和独立执行的基本单位，为了进一步提高程序的并发性，减少系统的开销，在操作系统中引入了线程的概念。<br>线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程在运行中断性，也有就绪、执行、阻塞三种状态。</p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"一、进程的概念\"><a href=\"#一、进程的概念\" class=\"headerlink\" title=\"一、进程的概念\"></a>一、进程的概念</h1><ol>\n<li>进程是允许并发的程序在某个数据集合上运行的过程</li>\n<li>进程是<strong>正文段</strong>、<strong>用户数据段</strong>和<strong>进程控制块</strong>共同组成的执行环境。</li>\n</ol>\n<h1 id=\"二、进程与程序的区别\"><a href=\"#二、进程与程序的区别\" class=\"headerlink\" title=\"二、进程与程序的区别\"></a>二、进程与程序的区别</h1><ol>\n<li>程序是静态的，进程是动态的</li>\n<li>程序是永久的，进程是暂时存在的</li>\n<li>程序和进程存在的实体不同。程序是指令的集合，进程是由正文段、用户数据段、进程控制块组成</li>\n</ol>\n<h1 id=\"三、进程与程序的关系\"><a href=\"#三、进程与程序的关系\" class=\"headerlink\" title=\"三、进程与程序的关系\"></a>三、进程与程序的关系</h1><p>进程是程序的一次执行，进程总是对于一个特定的程序，一个程序可以对于多个进程</p>\n<h1 id=\"四、进程的组成部分\"><a href=\"#四、进程的组成部分\" class=\"headerlink\" title=\"四、进程的组成部分\"></a>四、进程的组成部分</h1><h2 id=\"正文段\"><a href=\"#正文段\" class=\"headerlink\" title=\"正文段\"></a>正文段</h2><p>正文段存放被执行的激情指令</p>\n<h2 id=\"用户数据\"><a href=\"#用户数据\" class=\"headerlink\" title=\"用户数据\"></a>用户数据</h2><p>用户数据段存放进程在执行时要操作的用户数据</p>\n<h2 id=\"进程控制块\"><a href=\"#进程控制块\" class=\"headerlink\" title=\"进程控制块\"></a>进程控制块</h2><p>是操作系统管理进程所使用的数据结构<br>进程控制块是实体的一部分，是操作系统重要的数据结构，进程控制块中记录了操作系统所需要的，用户描述进程情况以及控制运行所需要的全部信息，进程控制块是操作系统感知进程存在的唯一标志。</p>\n<h1 id=\"五、进程管理\"><a href=\"#五、进程管理\" class=\"headerlink\" title=\"五、进程管理\"></a>五、进程管理</h1><ol>\n<li>进程的状态信息：就绪态、执行态、阻塞态</li>\n<li>进程的组织方式：链接方式、索引方式、进程队列</li>\n<li>进程的控制：进程的创建—阻塞—唤醒—终止</li>\n<li>进程的创建条件：1) 用户登录 2)作业调度 3)提供服务 4)应用请求</li>\n<li>阻塞条件： 1)请求系统服务 2)数据尚未到达 3)无工作可做 4)启动某种操作</li>\n</ol>\n<h2 id=\"操作系统内核\"><a href=\"#操作系统内核\" class=\"headerlink\" title=\"操作系统内核\"></a>操作系统内核</h2><p>操作系统内核是指系统与硬件密切相关、执行频率高的模块，一般常驻内存。</p>\n<h3 id=\"操作系统内核的功能\"><a href=\"#操作系统内核的功能\" class=\"headerlink\" title=\"操作系统内核的功能\"></a>操作系统内核的功能</h3><ol>\n<li><p>支持功能<br>支撑功能包括：中断处理、时钟管理和原语操作，其中原语操作是一组在执行过程中不能中断的操作</p>\n</li>\n<li><p>资源管理功能<br>资源管理功能包括：进程的管理、存储器管理和设备管理</p>\n</li>\n</ol>\n<p>####中断</p>\n<p>中断时改变计算机执行指令的顺序的一种事件，这种事件与cpu芯片内外部硬件电路参数的电信号对应。</p>\n<p><strong>中断的目的</strong>：能够有效提高cpu的利用率，改善系统性能，支持系统的异步性。例如在引用中断机制之前，采用的是发福轮询的方式来检测本次I/O是否结束。</p>\n<p><strong>中断的类型</strong>：</p>\n<ol>\n<li>同步中断：当指令执行时由cpu控制段元产生的，如除法出错，调试、溢出、浮点出错等</li>\n<li>异步中断（外部中断）：是由其他硬件设备随机产生的，可分为外部可屏蔽中断（I/O设备产生）和外部不可屏蔽中断(紧急事件产生，硬件故障等)</li>\n</ol>\n<p><strong>引起中断的原因</strong>：1)人为设置中断 2)程序性事故 3)I/O设备 4)硬件故障 5)外部事件</p>\n<h2 id=\"时钟管理\"><a href=\"#时钟管理\" class=\"headerlink\" title=\"时钟管理\"></a>时钟管理</h2><p>计算机很多活动都是有定时测量来控制的，两种定时测量 1) 保存当前的系统事件和日期 2)维持定时器，操作系统依靠时钟硬件和时钟驱动程序完成上述两种测量</p>\n<p><strong>时钟硬件</strong>：按照指定时间间隔产生时钟中断，测量逝去的时间，并触发与时间有关的操作<br><strong>时钟软件</strong>：维护日期和时间，递减当前进程在一个时间片内的剩余执行时间，对cpu的使用情况记账，递减报警计算器</p>\n<p><strong>时钟源</strong>：实时时钟（RTC/CMOS）/OS时钟</p>\n<h2 id=\"系统调用与一般函数\"><a href=\"#系统调用与一般函数\" class=\"headerlink\" title=\"系统调用与一般函数\"></a>系统调用与一般函数</h2><p>系统调用是一群实现定义好的模块，他们提供一条管道让应用程序或用户能由此得到核心程序的服务。系统调用时系统程序与用户程序之间的接口。</p>\n<p>系统调用与一般函数的区别：<br>1) 系统调用运行在系统态，一般函数运行在用户态<br>2) 系统调用与一般函数的执行过程不同，系统调用中断时，有系统找到对于的系统调用子程序<br>3) 系统调用要进行[中断处理],比一般函数多一些系统开销</p>\n<h2 id=\"进程同步：\"><a href=\"#进程同步：\" class=\"headerlink\" title=\"进程同步：\"></a>进程同步：</h2><p>操作系统同步机制的主要任务就是保证在多任务共享系统资源的情况下，程序能够得到正确的结果。同时，同步机制需要解决进程执行的协调问题。</p>\n<p>进程同步有两个作用</p>\n<ol>\n<li>对具有共享资源的进程，保住以互斥的方式访问临界资源。临界资源必须以互斥的方式访问共享资源</li>\n<li>对具有相互合作关系的进程，要保证相互合作的各个进程协调执行</li>\n</ol>\n<p><strong>同步机制遵循的准则</strong>： 1)空闲让进 2)忙则等待 3)有限等待 4) 让权等待</p>\n<h2 id=\"信号量机制\"><a href=\"#信号量机制\" class=\"headerlink\" title=\"信号量机制\"></a>信号量机制</h2><p>信号量机制对不同共享资源设置称之为信号量的变量，用信号量的取值标识资源的使用情况，或某种事件的发生</p>\n<h3 id=\"整形信号量机制\"><a href=\"#整形信号量机制\" class=\"headerlink\" title=\"整形信号量机制\"></a>整形信号量机制</h3><p>用整形来标记资源的使用情况。若整形量&gt;0,说明有资源可用；若整形量&lt;=0，说明资源忙，进程必须等待。</p>\n<h3 id=\"记录型信号量机制\"><a href=\"#记录型信号量机制\" class=\"headerlink\" title=\"记录型信号量机制\"></a>记录型信号量机制</h3><p>除了用整形来标记资源的使用情况外，额外使用一个记录进程队列来存储等待资源的进程。这样就不存在“忙等”，而是通过有可用资源时的回调触发</p>\n<h3 id=\"AND型信号量的机制\"><a href=\"#AND型信号量的机制\" class=\"headerlink\" title=\"AND型信号量的机制\"></a>AND型信号量的机制</h3><p>基本思想是将进程在整个运行过程中所需要的所有资源一次性的全部分配给进程，待进程使用完后再一起释放。</p>\n<h1 id=\"六、线程\"><a href=\"#六、线程\" class=\"headerlink\" title=\"六、线程\"></a>六、线程</h1><p>在操作系统中，进程是进行资源分配和独立执行的基本单位，为了进一步提高程序的并发性，减少系统的开销，在操作系统中引入了线程的概念。<br>线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程在运行中断性，也有就绪、执行、阻塞三种状态。</p>\n"},{"_content":"# 问题的提出\n\n我们知道，当我们的数据量达到一定数量时，需要将数据表进行水平拆分，从而满足大量数据的存储和查询，保证系统的可用性，但同时会出现另外一个问题就是，如果业务要查询“最近注册的第3页用户”，该如何实现呢？单库上，可以通过简单的sql实现分页查询\n```\nselect * from t_user order by time limit 200,100\n```\n\n分库分表后变成两个库后，分库依据是user_id，排序依据是time，单个分数据库层失去了time排序的全局视野，如果同样需要实现分页查询时该怎么办呢？\n\n# 全局视野法\n![](../images/分库分表的分页查询/getImage-20220825184040381.png)\n\n正常来讲，不管哪一个分库的第3页都不一定有全局第3页的所有数据，例如一下三种情况：\n\n情况一：两个分库按照时间排序，数据各占一半，则每页取offset和limit的一般数据回来合并就可以了\n![](../images/分库分表的分页查询/getImage-20220825184040402.png)\n情况二：所有数据都在一个库上，则取一个库的所有数据回来就可以了\n![](../images/分库分表的分页查询/getImage-20220825184040384.png)\n情况三，那么一般情况是，每个分库的数据数据是随机的，但是一定是在全局offset=600之内\n![](../images/分库分表的分页查询/getImage-20220825184040393.png)\n\n由于不清楚到底是哪种情况，所以必须每个库都返回3页数据，所得到的6页数据在服务层进行内存排序，得到数据全局视野，再取第3页数据，便能够得到想要的全局分页数据。\n\n这种方法缺点是：当查询的页数增大时，每个分库所需返回的数据也越来成倍增加，降低了查询的性能\n\n# 业务折中\n## 第一种折中的方案是\n对全局视野法的一种优化，即禁用制定页数的分页查询，必须通过下一页来实现分页查询的页数跳转，并且在每次查询下一页时将上一页的最大排序字段的值带上（这里就是时间time）,这样在每个分库查询数据时待上这个条件，可以优化查询速率。\n\n## 第二种折中的方案是\n数据库分库-数据均衡原理\n\n使用patition key进行分库，在数据量较大，数据分布足够随机的情况下，各分库所有非patition key属性，在各个分库上的数据分布，统计概率情况是一致的。\n\n例如，在uid随机的情况下，使用uid取模分两库，db0和db1：\n\n（1）性别属性，如果db0库上的男性用户占比70%，则db1上男性用户占比也应为70%\n\n（2）年龄属性，如果db0库上18-28岁少女用户比例占比15%，则db1上少女用户比例也应为15%\n\n（3）时间属性，如果db0库上每天10:00之前登录的用户占比为20%，则db1上应该是相同的统计规律\n\n\n利用这一原理，要查询全局100页数据，offset 9900 limit 100改写为offset 4950 limit 50，每个分库偏移4950（一半），获取50条数据（半页），得到的数据集的并集，基本能够认为，是全局数据的offset 9900 limit 100的数据，当然，这一页数据的精度，并不是精准的。\n\n根据实际业务经验，用户都要查询第100页网页、帖子、邮件的数据了，这一页数据的精准性损失，业务上往往是可以接受的，但此时技术方案的复杂度便大大降低了，既不需要返回更多的数据，也不需要进行服务内存排序了。\n\n# 二次查找法\n\n有没有一种方法既能满足业务要求，并且不需要折中，性能还高的方法呢？\n接下来介绍一种“二次查找法”，不知道能不能讲的明白，我尽量吧。\n\n为了方便举例，假设一页只有5条数据，查询第200页的SQL语句为select * from T order by time offset 1000 limit 5;\n\n分五步：\n### 1. 将`select * from T order by time offset 1000 limit 5;` 优化成`select * from T order by time offset 500 limit 5`,注意这里的500=1000/分表数量，并将这个sql下发至每个分库分表中执行，每个分库返回这个sql执行的结果。\n### 2. 找到所有分库返回结果的time的最小值\n\n![](../images/分库分表的分页查询/getImage-20220825184040369.png)\n第一个库，5条数据的time最小值是1487501123\n第二个库，5条数据的time最小值是1487501223\n\n故，三页数据中，time最小值来自第一个库，time_min=1487501123，这个过程只需要比较各个分库第一条数据，时间复杂度很低\n\n### 3. 查询二次改写\n第一次改写的SQL语句是select * from T order by time offset 500 limit 5\n\n第二次要改写成一个between语句，between的起点是time_min，between的终点是原来每个分库各自返回数据的最大值：\n\n第一个分库，第一次返回数据的最大值是1487501523\n所以查询改写为select * from T order by time where time between time_min and 1487501523\n\n第二个分库，第一次返回数据的最大值是1487501699\n所以查询改写为select * from T order by time where time between time_min and 1487501699\n\n![](../images/分库分表的分页查询/getImage-20220825184040363.png)\n\n从上面图片可以看出，DB1比第一次查出来的数据多了两行，应为查询的范围扩大了\n\n### 4. 计算time_min这条记录在全局的offset\n根据第一步查询的sql`select * from T order by time offset 500 limit` ,我们知道每个库的offset值了，将DB0中的最小time的数据虚拟到DB1中推算在DB1中的offset值=497\n![](../images/分库分表的分页查询/getImage-20220825184040525.png)\n从而我们得知time_min这条记录在全局的offset值=500+497=997\n\n### 5. 根据第二次查询出来的结果集，在内存中作排序，已知time_min在全局中的offset=997,那么结果集排序之后也能推算出offset=1000所在的记录，从而获得sql`select * from T order by time offset 1000 limit 5`的分页查询记录（图片黄色部分）\n![](../images/分库分表的分页查询/getImage-20220825184040515.png)\n\n总结：可以精确的返回业务所需数据，每次返回的数据量都非常小，不会随着翻页增加数据的返回量。","source":"_posts/后端&架构/分库分表的分页查询.md","raw":"# 问题的提出\n\n我们知道，当我们的数据量达到一定数量时，需要将数据表进行水平拆分，从而满足大量数据的存储和查询，保证系统的可用性，但同时会出现另外一个问题就是，如果业务要查询“最近注册的第3页用户”，该如何实现呢？单库上，可以通过简单的sql实现分页查询\n```\nselect * from t_user order by time limit 200,100\n```\n\n分库分表后变成两个库后，分库依据是user_id，排序依据是time，单个分数据库层失去了time排序的全局视野，如果同样需要实现分页查询时该怎么办呢？\n\n# 全局视野法\n![](../images/分库分表的分页查询/getImage-20220825184040381.png)\n\n正常来讲，不管哪一个分库的第3页都不一定有全局第3页的所有数据，例如一下三种情况：\n\n情况一：两个分库按照时间排序，数据各占一半，则每页取offset和limit的一般数据回来合并就可以了\n![](../images/分库分表的分页查询/getImage-20220825184040402.png)\n情况二：所有数据都在一个库上，则取一个库的所有数据回来就可以了\n![](../images/分库分表的分页查询/getImage-20220825184040384.png)\n情况三，那么一般情况是，每个分库的数据数据是随机的，但是一定是在全局offset=600之内\n![](../images/分库分表的分页查询/getImage-20220825184040393.png)\n\n由于不清楚到底是哪种情况，所以必须每个库都返回3页数据，所得到的6页数据在服务层进行内存排序，得到数据全局视野，再取第3页数据，便能够得到想要的全局分页数据。\n\n这种方法缺点是：当查询的页数增大时，每个分库所需返回的数据也越来成倍增加，降低了查询的性能\n\n# 业务折中\n## 第一种折中的方案是\n对全局视野法的一种优化，即禁用制定页数的分页查询，必须通过下一页来实现分页查询的页数跳转，并且在每次查询下一页时将上一页的最大排序字段的值带上（这里就是时间time）,这样在每个分库查询数据时待上这个条件，可以优化查询速率。\n\n## 第二种折中的方案是\n数据库分库-数据均衡原理\n\n使用patition key进行分库，在数据量较大，数据分布足够随机的情况下，各分库所有非patition key属性，在各个分库上的数据分布，统计概率情况是一致的。\n\n例如，在uid随机的情况下，使用uid取模分两库，db0和db1：\n\n（1）性别属性，如果db0库上的男性用户占比70%，则db1上男性用户占比也应为70%\n\n（2）年龄属性，如果db0库上18-28岁少女用户比例占比15%，则db1上少女用户比例也应为15%\n\n（3）时间属性，如果db0库上每天10:00之前登录的用户占比为20%，则db1上应该是相同的统计规律\n\n\n利用这一原理，要查询全局100页数据，offset 9900 limit 100改写为offset 4950 limit 50，每个分库偏移4950（一半），获取50条数据（半页），得到的数据集的并集，基本能够认为，是全局数据的offset 9900 limit 100的数据，当然，这一页数据的精度，并不是精准的。\n\n根据实际业务经验，用户都要查询第100页网页、帖子、邮件的数据了，这一页数据的精准性损失，业务上往往是可以接受的，但此时技术方案的复杂度便大大降低了，既不需要返回更多的数据，也不需要进行服务内存排序了。\n\n# 二次查找法\n\n有没有一种方法既能满足业务要求，并且不需要折中，性能还高的方法呢？\n接下来介绍一种“二次查找法”，不知道能不能讲的明白，我尽量吧。\n\n为了方便举例，假设一页只有5条数据，查询第200页的SQL语句为select * from T order by time offset 1000 limit 5;\n\n分五步：\n### 1. 将`select * from T order by time offset 1000 limit 5;` 优化成`select * from T order by time offset 500 limit 5`,注意这里的500=1000/分表数量，并将这个sql下发至每个分库分表中执行，每个分库返回这个sql执行的结果。\n### 2. 找到所有分库返回结果的time的最小值\n\n![](../images/分库分表的分页查询/getImage-20220825184040369.png)\n第一个库，5条数据的time最小值是1487501123\n第二个库，5条数据的time最小值是1487501223\n\n故，三页数据中，time最小值来自第一个库，time_min=1487501123，这个过程只需要比较各个分库第一条数据，时间复杂度很低\n\n### 3. 查询二次改写\n第一次改写的SQL语句是select * from T order by time offset 500 limit 5\n\n第二次要改写成一个between语句，between的起点是time_min，between的终点是原来每个分库各自返回数据的最大值：\n\n第一个分库，第一次返回数据的最大值是1487501523\n所以查询改写为select * from T order by time where time between time_min and 1487501523\n\n第二个分库，第一次返回数据的最大值是1487501699\n所以查询改写为select * from T order by time where time between time_min and 1487501699\n\n![](../images/分库分表的分页查询/getImage-20220825184040363.png)\n\n从上面图片可以看出，DB1比第一次查出来的数据多了两行，应为查询的范围扩大了\n\n### 4. 计算time_min这条记录在全局的offset\n根据第一步查询的sql`select * from T order by time offset 500 limit` ,我们知道每个库的offset值了，将DB0中的最小time的数据虚拟到DB1中推算在DB1中的offset值=497\n![](../images/分库分表的分页查询/getImage-20220825184040525.png)\n从而我们得知time_min这条记录在全局的offset值=500+497=997\n\n### 5. 根据第二次查询出来的结果集，在内存中作排序，已知time_min在全局中的offset=997,那么结果集排序之后也能推算出offset=1000所在的记录，从而获得sql`select * from T order by time offset 1000 limit 5`的分页查询记录（图片黄色部分）\n![](../images/分库分表的分页查询/getImage-20220825184040515.png)\n\n总结：可以精确的返回业务所需数据，每次返回的数据量都非常小，不会随着翻页增加数据的返回量。","slug":"后端&架构/分库分表的分页查询","published":1,"date":"2022-08-25T10:40:29.078Z","updated":"2022-08-25T10:40:42.344Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78ycziv0019vwm1eqbwq5kr","content":"<h1 id=\"问题的提出\"><a href=\"#问题的提出\" class=\"headerlink\" title=\"问题的提出\"></a>问题的提出</h1><p>我们知道，当我们的数据量达到一定数量时，需要将数据表进行水平拆分，从而满足大量数据的存储和查询，保证系统的可用性，但同时会出现另外一个问题就是，如果业务要查询“最近注册的第3页用户”，该如何实现呢？单库上，可以通过简单的sql实现分页查询</p>\n<pre><code>select * from t_user order by time limit 200,100</code></pre><p>分库分表后变成两个库后，分库依据是user_id，排序依据是time，单个分数据库层失去了time排序的全局视野，如果同样需要实现分页查询时该怎么办呢？</p>\n<h1 id=\"全局视野法\"><a href=\"#全局视野法\" class=\"headerlink\" title=\"全局视野法\"></a>全局视野法</h1><p><img src=\"../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/getImage-20220825184040381.png\" alt></p>\n<p>正常来讲，不管哪一个分库的第3页都不一定有全局第3页的所有数据，例如一下三种情况：</p>\n<p>情况一：两个分库按照时间排序，数据各占一半，则每页取offset和limit的一般数据回来合并就可以了<br><img src=\"../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/getImage-20220825184040402.png\" alt><br>情况二：所有数据都在一个库上，则取一个库的所有数据回来就可以了<br><img src=\"../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/getImage-20220825184040384.png\" alt><br>情况三，那么一般情况是，每个分库的数据数据是随机的，但是一定是在全局offset=600之内<br><img src=\"../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/getImage-20220825184040393.png\" alt></p>\n<p>由于不清楚到底是哪种情况，所以必须每个库都返回3页数据，所得到的6页数据在服务层进行内存排序，得到数据全局视野，再取第3页数据，便能够得到想要的全局分页数据。</p>\n<p>这种方法缺点是：当查询的页数增大时，每个分库所需返回的数据也越来成倍增加，降低了查询的性能</p>\n<h1 id=\"业务折中\"><a href=\"#业务折中\" class=\"headerlink\" title=\"业务折中\"></a>业务折中</h1><h2 id=\"第一种折中的方案是\"><a href=\"#第一种折中的方案是\" class=\"headerlink\" title=\"第一种折中的方案是\"></a>第一种折中的方案是</h2><p>对全局视野法的一种优化，即禁用制定页数的分页查询，必须通过下一页来实现分页查询的页数跳转，并且在每次查询下一页时将上一页的最大排序字段的值带上（这里就是时间time）,这样在每个分库查询数据时待上这个条件，可以优化查询速率。</p>\n<h2 id=\"第二种折中的方案是\"><a href=\"#第二种折中的方案是\" class=\"headerlink\" title=\"第二种折中的方案是\"></a>第二种折中的方案是</h2><p>数据库分库-数据均衡原理</p>\n<p>使用patition key进行分库，在数据量较大，数据分布足够随机的情况下，各分库所有非patition key属性，在各个分库上的数据分布，统计概率情况是一致的。</p>\n<p>例如，在uid随机的情况下，使用uid取模分两库，db0和db1：</p>\n<p>（1）性别属性，如果db0库上的男性用户占比70%，则db1上男性用户占比也应为70%</p>\n<p>（2）年龄属性，如果db0库上18-28岁少女用户比例占比15%，则db1上少女用户比例也应为15%</p>\n<p>（3）时间属性，如果db0库上每天10:00之前登录的用户占比为20%，则db1上应该是相同的统计规律</p>\n<p>利用这一原理，要查询全局100页数据，offset 9900 limit 100改写为offset 4950 limit 50，每个分库偏移4950（一半），获取50条数据（半页），得到的数据集的并集，基本能够认为，是全局数据的offset 9900 limit 100的数据，当然，这一页数据的精度，并不是精准的。</p>\n<p>根据实际业务经验，用户都要查询第100页网页、帖子、邮件的数据了，这一页数据的精准性损失，业务上往往是可以接受的，但此时技术方案的复杂度便大大降低了，既不需要返回更多的数据，也不需要进行服务内存排序了。</p>\n<h1 id=\"二次查找法\"><a href=\"#二次查找法\" class=\"headerlink\" title=\"二次查找法\"></a>二次查找法</h1><p>有没有一种方法既能满足业务要求，并且不需要折中，性能还高的方法呢？<br>接下来介绍一种“二次查找法”，不知道能不能讲的明白，我尽量吧。</p>\n<p>为了方便举例，假设一页只有5条数据，查询第200页的SQL语句为select * from T order by time offset 1000 limit 5;</p>\n<p>分五步：</p>\n<h3 id=\"1-将select-from-T-order-by-time-offset-1000-limit-5-优化成select-from-T-order-by-time-offset-500-limit-5-注意这里的500-1000-分表数量，并将这个sql下发至每个分库分表中执行，每个分库返回这个sql执行的结果。\"><a href=\"#1-将select-from-T-order-by-time-offset-1000-limit-5-优化成select-from-T-order-by-time-offset-500-limit-5-注意这里的500-1000-分表数量，并将这个sql下发至每个分库分表中执行，每个分库返回这个sql执行的结果。\" class=\"headerlink\" title=\"1. 将select * from T order by time offset 1000 limit 5; 优化成select * from T order by time offset 500 limit 5,注意这里的500=1000/分表数量，并将这个sql下发至每个分库分表中执行，每个分库返回这个sql执行的结果。\"></a>1. 将<code>select * from T order by time offset 1000 limit 5;</code> 优化成<code>select * from T order by time offset 500 limit 5</code>,注意这里的500=1000/分表数量，并将这个sql下发至每个分库分表中执行，每个分库返回这个sql执行的结果。</h3><h3 id=\"2-找到所有分库返回结果的time的最小值\"><a href=\"#2-找到所有分库返回结果的time的最小值\" class=\"headerlink\" title=\"2. 找到所有分库返回结果的time的最小值\"></a>2. 找到所有分库返回结果的time的最小值</h3><p><img src=\"../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/getImage-20220825184040369.png\" alt><br>第一个库，5条数据的time最小值是1487501123<br>第二个库，5条数据的time最小值是1487501223</p>\n<p>故，三页数据中，time最小值来自第一个库，time_min=1487501123，这个过程只需要比较各个分库第一条数据，时间复杂度很低</p>\n<h3 id=\"3-查询二次改写\"><a href=\"#3-查询二次改写\" class=\"headerlink\" title=\"3. 查询二次改写\"></a>3. 查询二次改写</h3><p>第一次改写的SQL语句是select * from T order by time offset 500 limit 5</p>\n<p>第二次要改写成一个between语句，between的起点是time_min，between的终点是原来每个分库各自返回数据的最大值：</p>\n<p>第一个分库，第一次返回数据的最大值是1487501523<br>所以查询改写为select * from T order by time where time between time_min and 1487501523</p>\n<p>第二个分库，第一次返回数据的最大值是1487501699<br>所以查询改写为select * from T order by time where time between time_min and 1487501699</p>\n<p><img src=\"../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/getImage-20220825184040363.png\" alt></p>\n<p>从上面图片可以看出，DB1比第一次查出来的数据多了两行，应为查询的范围扩大了</p>\n<h3 id=\"4-计算time-min这条记录在全局的offset\"><a href=\"#4-计算time-min这条记录在全局的offset\" class=\"headerlink\" title=\"4. 计算time_min这条记录在全局的offset\"></a>4. 计算time_min这条记录在全局的offset</h3><p>根据第一步查询的sql<code>select * from T order by time offset 500 limit</code> ,我们知道每个库的offset值了，将DB0中的最小time的数据虚拟到DB1中推算在DB1中的offset值=497<br><img src=\"../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/getImage-20220825184040525.png\" alt><br>从而我们得知time_min这条记录在全局的offset值=500+497=997</p>\n<h3 id=\"5-根据第二次查询出来的结果集，在内存中作排序，已知time-min在全局中的offset-997-那么结果集排序之后也能推算出offset-1000所在的记录，从而获得sqlselect-from-T-order-by-time-offset-1000-limit-5的分页查询记录（图片黄色部分）\"><a href=\"#5-根据第二次查询出来的结果集，在内存中作排序，已知time-min在全局中的offset-997-那么结果集排序之后也能推算出offset-1000所在的记录，从而获得sqlselect-from-T-order-by-time-offset-1000-limit-5的分页查询记录（图片黄色部分）\" class=\"headerlink\" title=\"5. 根据第二次查询出来的结果集，在内存中作排序，已知time_min在全局中的offset=997,那么结果集排序之后也能推算出offset=1000所在的记录，从而获得sqlselect * from T order by time offset 1000 limit 5的分页查询记录（图片黄色部分）\"></a>5. 根据第二次查询出来的结果集，在内存中作排序，已知time_min在全局中的offset=997,那么结果集排序之后也能推算出offset=1000所在的记录，从而获得sql<code>select * from T order by time offset 1000 limit 5</code>的分页查询记录（图片黄色部分）</h3><p><img src=\"../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/getImage-20220825184040515.png\" alt></p>\n<p>总结：可以精确的返回业务所需数据，每次返回的数据量都非常小，不会随着翻页增加数据的返回量。</p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"问题的提出\"><a href=\"#问题的提出\" class=\"headerlink\" title=\"问题的提出\"></a>问题的提出</h1><p>我们知道，当我们的数据量达到一定数量时，需要将数据表进行水平拆分，从而满足大量数据的存储和查询，保证系统的可用性，但同时会出现另外一个问题就是，如果业务要查询“最近注册的第3页用户”，该如何实现呢？单库上，可以通过简单的sql实现分页查询</p>\n<pre><code>select * from t_user order by time limit 200,100</code></pre><p>分库分表后变成两个库后，分库依据是user_id，排序依据是time，单个分数据库层失去了time排序的全局视野，如果同样需要实现分页查询时该怎么办呢？</p>\n<h1 id=\"全局视野法\"><a href=\"#全局视野法\" class=\"headerlink\" title=\"全局视野法\"></a>全局视野法</h1><p><img src=\"../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/getImage-20220825184040381.png\" alt></p>\n<p>正常来讲，不管哪一个分库的第3页都不一定有全局第3页的所有数据，例如一下三种情况：</p>\n<p>情况一：两个分库按照时间排序，数据各占一半，则每页取offset和limit的一般数据回来合并就可以了<br><img src=\"../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/getImage-20220825184040402.png\" alt><br>情况二：所有数据都在一个库上，则取一个库的所有数据回来就可以了<br><img src=\"../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/getImage-20220825184040384.png\" alt><br>情况三，那么一般情况是，每个分库的数据数据是随机的，但是一定是在全局offset=600之内<br><img src=\"../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/getImage-20220825184040393.png\" alt></p>\n<p>由于不清楚到底是哪种情况，所以必须每个库都返回3页数据，所得到的6页数据在服务层进行内存排序，得到数据全局视野，再取第3页数据，便能够得到想要的全局分页数据。</p>\n<p>这种方法缺点是：当查询的页数增大时，每个分库所需返回的数据也越来成倍增加，降低了查询的性能</p>\n<h1 id=\"业务折中\"><a href=\"#业务折中\" class=\"headerlink\" title=\"业务折中\"></a>业务折中</h1><h2 id=\"第一种折中的方案是\"><a href=\"#第一种折中的方案是\" class=\"headerlink\" title=\"第一种折中的方案是\"></a>第一种折中的方案是</h2><p>对全局视野法的一种优化，即禁用制定页数的分页查询，必须通过下一页来实现分页查询的页数跳转，并且在每次查询下一页时将上一页的最大排序字段的值带上（这里就是时间time）,这样在每个分库查询数据时待上这个条件，可以优化查询速率。</p>\n<h2 id=\"第二种折中的方案是\"><a href=\"#第二种折中的方案是\" class=\"headerlink\" title=\"第二种折中的方案是\"></a>第二种折中的方案是</h2><p>数据库分库-数据均衡原理</p>\n<p>使用patition key进行分库，在数据量较大，数据分布足够随机的情况下，各分库所有非patition key属性，在各个分库上的数据分布，统计概率情况是一致的。</p>\n<p>例如，在uid随机的情况下，使用uid取模分两库，db0和db1：</p>\n<p>（1）性别属性，如果db0库上的男性用户占比70%，则db1上男性用户占比也应为70%</p>\n<p>（2）年龄属性，如果db0库上18-28岁少女用户比例占比15%，则db1上少女用户比例也应为15%</p>\n<p>（3）时间属性，如果db0库上每天10:00之前登录的用户占比为20%，则db1上应该是相同的统计规律</p>\n<p>利用这一原理，要查询全局100页数据，offset 9900 limit 100改写为offset 4950 limit 50，每个分库偏移4950（一半），获取50条数据（半页），得到的数据集的并集，基本能够认为，是全局数据的offset 9900 limit 100的数据，当然，这一页数据的精度，并不是精准的。</p>\n<p>根据实际业务经验，用户都要查询第100页网页、帖子、邮件的数据了，这一页数据的精准性损失，业务上往往是可以接受的，但此时技术方案的复杂度便大大降低了，既不需要返回更多的数据，也不需要进行服务内存排序了。</p>\n<h1 id=\"二次查找法\"><a href=\"#二次查找法\" class=\"headerlink\" title=\"二次查找法\"></a>二次查找法</h1><p>有没有一种方法既能满足业务要求，并且不需要折中，性能还高的方法呢？<br>接下来介绍一种“二次查找法”，不知道能不能讲的明白，我尽量吧。</p>\n<p>为了方便举例，假设一页只有5条数据，查询第200页的SQL语句为select * from T order by time offset 1000 limit 5;</p>\n<p>分五步：</p>\n<h3 id=\"1-将select-from-T-order-by-time-offset-1000-limit-5-优化成select-from-T-order-by-time-offset-500-limit-5-注意这里的500-1000-分表数量，并将这个sql下发至每个分库分表中执行，每个分库返回这个sql执行的结果。\"><a href=\"#1-将select-from-T-order-by-time-offset-1000-limit-5-优化成select-from-T-order-by-time-offset-500-limit-5-注意这里的500-1000-分表数量，并将这个sql下发至每个分库分表中执行，每个分库返回这个sql执行的结果。\" class=\"headerlink\" title=\"1. 将select * from T order by time offset 1000 limit 5; 优化成select * from T order by time offset 500 limit 5,注意这里的500=1000/分表数量，并将这个sql下发至每个分库分表中执行，每个分库返回这个sql执行的结果。\"></a>1. 将<code>select * from T order by time offset 1000 limit 5;</code> 优化成<code>select * from T order by time offset 500 limit 5</code>,注意这里的500=1000/分表数量，并将这个sql下发至每个分库分表中执行，每个分库返回这个sql执行的结果。</h3><h3 id=\"2-找到所有分库返回结果的time的最小值\"><a href=\"#2-找到所有分库返回结果的time的最小值\" class=\"headerlink\" title=\"2. 找到所有分库返回结果的time的最小值\"></a>2. 找到所有分库返回结果的time的最小值</h3><p><img src=\"../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/getImage-20220825184040369.png\" alt><br>第一个库，5条数据的time最小值是1487501123<br>第二个库，5条数据的time最小值是1487501223</p>\n<p>故，三页数据中，time最小值来自第一个库，time_min=1487501123，这个过程只需要比较各个分库第一条数据，时间复杂度很低</p>\n<h3 id=\"3-查询二次改写\"><a href=\"#3-查询二次改写\" class=\"headerlink\" title=\"3. 查询二次改写\"></a>3. 查询二次改写</h3><p>第一次改写的SQL语句是select * from T order by time offset 500 limit 5</p>\n<p>第二次要改写成一个between语句，between的起点是time_min，between的终点是原来每个分库各自返回数据的最大值：</p>\n<p>第一个分库，第一次返回数据的最大值是1487501523<br>所以查询改写为select * from T order by time where time between time_min and 1487501523</p>\n<p>第二个分库，第一次返回数据的最大值是1487501699<br>所以查询改写为select * from T order by time where time between time_min and 1487501699</p>\n<p><img src=\"../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/getImage-20220825184040363.png\" alt></p>\n<p>从上面图片可以看出，DB1比第一次查出来的数据多了两行，应为查询的范围扩大了</p>\n<h3 id=\"4-计算time-min这条记录在全局的offset\"><a href=\"#4-计算time-min这条记录在全局的offset\" class=\"headerlink\" title=\"4. 计算time_min这条记录在全局的offset\"></a>4. 计算time_min这条记录在全局的offset</h3><p>根据第一步查询的sql<code>select * from T order by time offset 500 limit</code> ,我们知道每个库的offset值了，将DB0中的最小time的数据虚拟到DB1中推算在DB1中的offset值=497<br><img src=\"../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/getImage-20220825184040525.png\" alt><br>从而我们得知time_min这条记录在全局的offset值=500+497=997</p>\n<h3 id=\"5-根据第二次查询出来的结果集，在内存中作排序，已知time-min在全局中的offset-997-那么结果集排序之后也能推算出offset-1000所在的记录，从而获得sqlselect-from-T-order-by-time-offset-1000-limit-5的分页查询记录（图片黄色部分）\"><a href=\"#5-根据第二次查询出来的结果集，在内存中作排序，已知time-min在全局中的offset-997-那么结果集排序之后也能推算出offset-1000所在的记录，从而获得sqlselect-from-T-order-by-time-offset-1000-limit-5的分页查询记录（图片黄色部分）\" class=\"headerlink\" title=\"5. 根据第二次查询出来的结果集，在内存中作排序，已知time_min在全局中的offset=997,那么结果集排序之后也能推算出offset=1000所在的记录，从而获得sqlselect * from T order by time offset 1000 limit 5的分页查询记录（图片黄色部分）\"></a>5. 根据第二次查询出来的结果集，在内存中作排序，已知time_min在全局中的offset=997,那么结果集排序之后也能推算出offset=1000所在的记录，从而获得sql<code>select * from T order by time offset 1000 limit 5</code>的分页查询记录（图片黄色部分）</h3><p><img src=\"../images/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/getImage-20220825184040515.png\" alt></p>\n<p>总结：可以精确的返回业务所需数据，每次返回的数据量都非常小，不会随着翻页增加数据的返回量。</p>\n"},{"title":"操作系统原理——内存","date":"2021-10-08T05:58:00.000Z","author":"okeeper","_content":"\n# 内存管理的目标\n1) 实现内存分配、内存回收等操作\n2) 提高内存的利用率和内存的访问速度\n即充分利用现有的内存资源，为应用程序提供方便的内存使用方式和一个快速、安全且充分大的存储器\n\n# 程序的链接和装入\n链接要解决的问题是将编译后的目标模块装配成一个可执行的程序，分为静态链接和动态链接\n\n### 1. 程序链接\n**静态链接**：在程序运行之前，用链接程序将目标模块连接成一个完整的转入模块，任务：一是对逻辑地址进行修改，二是转换外部调用符号\n优点：运行速度快 缺点：可执行文件较大，占用空间大，系统开销大，程序开发不够灵活，修改一个模块会导致整个程序重新连接\n\n**动态链接**\n可将某些目标模块的链接推迟到这些模块中的函数要被调用时再进行。\n优点：节省内存和外存空间，方便程序开发\n缺点：增加了运行时的开销，是程序运行时速度变慢\n\n### 2.程序的装入\n装入方式：绝对装入方式、可重定位装入（静态装入方式）和动态运行时装入方式\n\n**绝对装入方式**：编译程序已知程序在内存中的位置，编译时产生物理地址的目标代码，转入程序按照装入模块的物理地址将程序和数据装入内存\n**可重定位装入方式**：编译时不知道程序在内存中的位置，那么编译时就必须生成可重定位的代码，其中的地址都是逻辑地址，在程序转入内存时，再把逻辑地址映射为物理地址。程序装入时对目标称重的指令和数据地址修改的过程称之为重定位转入\n\n静态装入方式的特点：1)编译程序使目标模块的地址从0开始\n2) 程序装入时，装入程序根据内存的使用情况将装入模块的装入内存的某个位置，并对模块进行重定位。物理地址=有效的逻辑地址+程序在内存中的其实位置\n\n动态运行时装入：当一个进程在被换出之前的内存地址与后来被从外存调入时的位置不同，这是地址映射延迟到进程执行时再进行。\n\n## 3.连续分配的存储管理方式\n1. 单一连续去分配方式\n适合于单用户单任务系统，内存分为系统区和用户区\n2. 固定分区分配\n将用户内存空间分配成若干固定大小的区域，每个区域运行一道用户程序；分区的数量固定的，大小也是固定的\n每个分区大小相等的分配方式缺点是：内存利用率低，主要用于一个计算机去控制多个相同对象的场合，如冶炼炉\n在一些实时系统中，固定分区的分配方式还是简单而有效的\n3. 动态分区分配方式\n用户分区的数量和大小都是动态变化的\n分配原理：系统初始只有一个大的空闲分区，当进程请求内存资源时，系统根据请求资源的大小分配一片空闲区域给进程，当运行一段时间后，空闲分区可能散布在不连续的区域，这时候系统会维护一个记录当前空闲分区的数据接口，当进程请求内存时，系统从所有空闲分区中找到一个合适大小的空间给进程。\n数据结构：空闲分区表和空闲分区链\n空闲分区链可以动态为每个分区建立一个节点，每个节点包括分区大小、分区起始地址、指向前一个空闲分区节点的指针、指向后一个空闲分区节点的指针。每一个节点占用的内存动态分配、动态回收。\n\n**动态分区分配算法**\n1) 首次适应算法FF\n要求空闲分区链以地址递增的顺序进行连接，每次从链首开始查找，低地址空间可能会被反复划分 缺点：造成空间浪费，内存碎片\n2) 循环首次适应算法NF\n不在每次从链首开始查找，而是从上一次查找的空闲分区的下一个分区开始查找，每次应设置一个起始查找指针，指示下一次查找的分区\n3) 最佳适应算法BF\n为了方便查找，把所有空闲区，按照空闲大小递增的顺序进行排列，总是把大小和进程请求的内存空间大小接近的空间分配给进程。\n优点：避免了大材小用，提高了内存的利用率\n缺点：容易留下难以使用的小空闲区\n\n## 4. 基于分页存储的管理方式\n把进程的存储在内存中的物理地址不连续的区域，这种内存管理方式称为离散内存管理方式。\n离散内存管理分配内存空间的管理方式有：**分页存储管理，分段存储管理、段也式存储管理**\n\n**页**：将一个进程的逻辑地址空间分为若干个大小相等的片，，称之为页\n**页框**：将物理内存地址分成与页大小相同的若干个存储块，称之为页框\n\n**业内碎片**：进程的最后一页一般装不满一个叶框，而形成了不可利用的碎片称为页内碎片。\n\n**页表**：实现页号到页框的映射，在基本的分页制度中，每个进程有一个页表，进程的每一页在页表中有一个对应的页表项，页表在内存中连续存放。\n\n**分页管理方式的地址结构**\n页的存储结构：\n页号P   页内偏移量W\n若用m位标识逻辑地址，页大小为2的n次方，则用低n位表示页内偏移量w,用高位m-n位表示P\n\n分页地址变换：实现逻辑地址到物理地址的转换\n公式:物理地址=页框号x页框大小 + 页内偏移量\n\n为了减少cpu在有效访问内存时间上的开销，提高内存的速度，引入了快表机制\n**快表**:也称转换后的缓冲是为了提高访问内存速度而采用的专用缓存，存放最近访问过的页表项。\n\n## 4. 基于两级页表和多级页表的管理方式\n页表再分页，就形成了两级或者多级页表\n两级页表：将页表再分页，使得每个页表分页的大小与内存页框的大小相同\n页目录号实际是一个索引值，根据p1从也木勒表项中找到页表所在的页框号，页号p2是页表中的偏移量，根据p2可以知道应该从也飙中的第p2项找到进程页所在的页框号。\n## 5. 基于分页虚拟存储的系统\n虚拟存储技术实现的基本思想是：只把进程的一部分装入内存，在进程执行的过程中，cpu访问内存如果发现所访问的内容不再内存中，则通过异常处理将所需的内容从外存调入内存。\n虚拟存储技术的好处：\n1) 提高内存的利用率\n2) 提高多道程序度\n3) 把逻辑地址空间和物理地址空间分开，程序员不用关心物理内存的容量对编程的限制。\n\n**虚拟存储技术的特征**\n1) 离散性\n2) 多次性\n3) 对换性\n\n## 6. 页的分配策略\n最少页框数：是指保证进程正常运行所需的最少页框数。操作系统为进程分配的页应该大于或者等于最少页框数\n\n页分配策略：固定分配策略和可变分配策略\n页置换策略：局部置换和全局置换。1)局部置换发生置换时，只从请求置换的进程本身的内存页中选择淘汰页，腾出内存空间 2)全局置换是指发生置换时，从所有进程的内存页中选择淘汰的页。\n也有局部置换和全局置换组合的策略：1)固定分配局部置换 2可变分配局部置换 3)可变分配全局置换\n\n**分配算法**\n1) 平均分配算法n进程m页框，则分配INT[m/n]个页框，余数放入缓冲\n2) 按比例分配算法，为进程分配的页框数=进程页数/所有进程页数总和 * 总页框数\n3) 优先权的分配算法\n\n## 7.页调入策略\n1) 系统可以在进程需要时将页调入内存，有利于内存的使用率，但是对系统的时间性能不利\n2) 采用预先调入页的策略，将预计不久后会被访问的页预先调入内存\n\n## 8.页置换算法\n1) 最佳置换算法ORA:该算法选择以后永远不会被访问的页或者长时间不会被访问的页作为换出页\n2) 先进先出置换算法FIFO：最简单。当选择换出页时，选择进入内存时间最早的页（用指针指示当前调入新页时，应当淘汰的那个也在队列中的位置，换出后，指针指向下一个应该淘汰的页）\n3) 最久未使用的LRU置换算法：性能较好的算法，该算法是选择最久未使用的页换出。\n4) 其他置换算法：附件引用位算法、简单clock算法、改进型clock算法、最少使用置换算法、页缓冲算法\n\n## 9.分段存储管理\n引入分段机制的优点是方便编程、分段共享、分段保护、动态链接以及存储空间的动态增长","source":"_posts/操作系统原理/操作系统原理——内存管理.md","raw":"---\ntitle: 操作系统原理——内存\ndate: 2021-10-08 13:58:00\nauthor: okeeper\ncategories: 操作系统原理\ntags:\n  - 操作系统原理\n---\n\n# 内存管理的目标\n1) 实现内存分配、内存回收等操作\n2) 提高内存的利用率和内存的访问速度\n即充分利用现有的内存资源，为应用程序提供方便的内存使用方式和一个快速、安全且充分大的存储器\n\n# 程序的链接和装入\n链接要解决的问题是将编译后的目标模块装配成一个可执行的程序，分为静态链接和动态链接\n\n### 1. 程序链接\n**静态链接**：在程序运行之前，用链接程序将目标模块连接成一个完整的转入模块，任务：一是对逻辑地址进行修改，二是转换外部调用符号\n优点：运行速度快 缺点：可执行文件较大，占用空间大，系统开销大，程序开发不够灵活，修改一个模块会导致整个程序重新连接\n\n**动态链接**\n可将某些目标模块的链接推迟到这些模块中的函数要被调用时再进行。\n优点：节省内存和外存空间，方便程序开发\n缺点：增加了运行时的开销，是程序运行时速度变慢\n\n### 2.程序的装入\n装入方式：绝对装入方式、可重定位装入（静态装入方式）和动态运行时装入方式\n\n**绝对装入方式**：编译程序已知程序在内存中的位置，编译时产生物理地址的目标代码，转入程序按照装入模块的物理地址将程序和数据装入内存\n**可重定位装入方式**：编译时不知道程序在内存中的位置，那么编译时就必须生成可重定位的代码，其中的地址都是逻辑地址，在程序转入内存时，再把逻辑地址映射为物理地址。程序装入时对目标称重的指令和数据地址修改的过程称之为重定位转入\n\n静态装入方式的特点：1)编译程序使目标模块的地址从0开始\n2) 程序装入时，装入程序根据内存的使用情况将装入模块的装入内存的某个位置，并对模块进行重定位。物理地址=有效的逻辑地址+程序在内存中的其实位置\n\n动态运行时装入：当一个进程在被换出之前的内存地址与后来被从外存调入时的位置不同，这是地址映射延迟到进程执行时再进行。\n\n## 3.连续分配的存储管理方式\n1. 单一连续去分配方式\n适合于单用户单任务系统，内存分为系统区和用户区\n2. 固定分区分配\n将用户内存空间分配成若干固定大小的区域，每个区域运行一道用户程序；分区的数量固定的，大小也是固定的\n每个分区大小相等的分配方式缺点是：内存利用率低，主要用于一个计算机去控制多个相同对象的场合，如冶炼炉\n在一些实时系统中，固定分区的分配方式还是简单而有效的\n3. 动态分区分配方式\n用户分区的数量和大小都是动态变化的\n分配原理：系统初始只有一个大的空闲分区，当进程请求内存资源时，系统根据请求资源的大小分配一片空闲区域给进程，当运行一段时间后，空闲分区可能散布在不连续的区域，这时候系统会维护一个记录当前空闲分区的数据接口，当进程请求内存时，系统从所有空闲分区中找到一个合适大小的空间给进程。\n数据结构：空闲分区表和空闲分区链\n空闲分区链可以动态为每个分区建立一个节点，每个节点包括分区大小、分区起始地址、指向前一个空闲分区节点的指针、指向后一个空闲分区节点的指针。每一个节点占用的内存动态分配、动态回收。\n\n**动态分区分配算法**\n1) 首次适应算法FF\n要求空闲分区链以地址递增的顺序进行连接，每次从链首开始查找，低地址空间可能会被反复划分 缺点：造成空间浪费，内存碎片\n2) 循环首次适应算法NF\n不在每次从链首开始查找，而是从上一次查找的空闲分区的下一个分区开始查找，每次应设置一个起始查找指针，指示下一次查找的分区\n3) 最佳适应算法BF\n为了方便查找，把所有空闲区，按照空闲大小递增的顺序进行排列，总是把大小和进程请求的内存空间大小接近的空间分配给进程。\n优点：避免了大材小用，提高了内存的利用率\n缺点：容易留下难以使用的小空闲区\n\n## 4. 基于分页存储的管理方式\n把进程的存储在内存中的物理地址不连续的区域，这种内存管理方式称为离散内存管理方式。\n离散内存管理分配内存空间的管理方式有：**分页存储管理，分段存储管理、段也式存储管理**\n\n**页**：将一个进程的逻辑地址空间分为若干个大小相等的片，，称之为页\n**页框**：将物理内存地址分成与页大小相同的若干个存储块，称之为页框\n\n**业内碎片**：进程的最后一页一般装不满一个叶框，而形成了不可利用的碎片称为页内碎片。\n\n**页表**：实现页号到页框的映射，在基本的分页制度中，每个进程有一个页表，进程的每一页在页表中有一个对应的页表项，页表在内存中连续存放。\n\n**分页管理方式的地址结构**\n页的存储结构：\n页号P   页内偏移量W\n若用m位标识逻辑地址，页大小为2的n次方，则用低n位表示页内偏移量w,用高位m-n位表示P\n\n分页地址变换：实现逻辑地址到物理地址的转换\n公式:物理地址=页框号x页框大小 + 页内偏移量\n\n为了减少cpu在有效访问内存时间上的开销，提高内存的速度，引入了快表机制\n**快表**:也称转换后的缓冲是为了提高访问内存速度而采用的专用缓存，存放最近访问过的页表项。\n\n## 4. 基于两级页表和多级页表的管理方式\n页表再分页，就形成了两级或者多级页表\n两级页表：将页表再分页，使得每个页表分页的大小与内存页框的大小相同\n页目录号实际是一个索引值，根据p1从也木勒表项中找到页表所在的页框号，页号p2是页表中的偏移量，根据p2可以知道应该从也飙中的第p2项找到进程页所在的页框号。\n## 5. 基于分页虚拟存储的系统\n虚拟存储技术实现的基本思想是：只把进程的一部分装入内存，在进程执行的过程中，cpu访问内存如果发现所访问的内容不再内存中，则通过异常处理将所需的内容从外存调入内存。\n虚拟存储技术的好处：\n1) 提高内存的利用率\n2) 提高多道程序度\n3) 把逻辑地址空间和物理地址空间分开，程序员不用关心物理内存的容量对编程的限制。\n\n**虚拟存储技术的特征**\n1) 离散性\n2) 多次性\n3) 对换性\n\n## 6. 页的分配策略\n最少页框数：是指保证进程正常运行所需的最少页框数。操作系统为进程分配的页应该大于或者等于最少页框数\n\n页分配策略：固定分配策略和可变分配策略\n页置换策略：局部置换和全局置换。1)局部置换发生置换时，只从请求置换的进程本身的内存页中选择淘汰页，腾出内存空间 2)全局置换是指发生置换时，从所有进程的内存页中选择淘汰的页。\n也有局部置换和全局置换组合的策略：1)固定分配局部置换 2可变分配局部置换 3)可变分配全局置换\n\n**分配算法**\n1) 平均分配算法n进程m页框，则分配INT[m/n]个页框，余数放入缓冲\n2) 按比例分配算法，为进程分配的页框数=进程页数/所有进程页数总和 * 总页框数\n3) 优先权的分配算法\n\n## 7.页调入策略\n1) 系统可以在进程需要时将页调入内存，有利于内存的使用率，但是对系统的时间性能不利\n2) 采用预先调入页的策略，将预计不久后会被访问的页预先调入内存\n\n## 8.页置换算法\n1) 最佳置换算法ORA:该算法选择以后永远不会被访问的页或者长时间不会被访问的页作为换出页\n2) 先进先出置换算法FIFO：最简单。当选择换出页时，选择进入内存时间最早的页（用指针指示当前调入新页时，应当淘汰的那个也在队列中的位置，换出后，指针指向下一个应该淘汰的页）\n3) 最久未使用的LRU置换算法：性能较好的算法，该算法是选择最久未使用的页换出。\n4) 其他置换算法：附件引用位算法、简单clock算法、改进型clock算法、最少使用置换算法、页缓冲算法\n\n## 9.分段存储管理\n引入分段机制的优点是方便编程、分段共享、分段保护、动态链接以及存储空间的动态增长","slug":"操作系统原理/操作系统原理——内存管理","published":1,"updated":"2022-08-25T09:13:01.886Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78ycziw001avwm1thahvbuv","content":"<h1 id=\"内存管理的目标\"><a href=\"#内存管理的目标\" class=\"headerlink\" title=\"内存管理的目标\"></a>内存管理的目标</h1><p>1) 实现内存分配、内存回收等操作<br>2) 提高内存的利用率和内存的访问速度<br>即充分利用现有的内存资源，为应用程序提供方便的内存使用方式和一个快速、安全且充分大的存储器</p>\n<h1 id=\"程序的链接和装入\"><a href=\"#程序的链接和装入\" class=\"headerlink\" title=\"程序的链接和装入\"></a>程序的链接和装入</h1><p>链接要解决的问题是将编译后的目标模块装配成一个可执行的程序，分为静态链接和动态链接</p>\n<h3 id=\"1-程序链接\"><a href=\"#1-程序链接\" class=\"headerlink\" title=\"1. 程序链接\"></a>1. 程序链接</h3><p><strong>静态链接</strong>：在程序运行之前，用链接程序将目标模块连接成一个完整的转入模块，任务：一是对逻辑地址进行修改，二是转换外部调用符号<br>优点：运行速度快 缺点：可执行文件较大，占用空间大，系统开销大，程序开发不够灵活，修改一个模块会导致整个程序重新连接</p>\n<p><strong>动态链接</strong><br>可将某些目标模块的链接推迟到这些模块中的函数要被调用时再进行。<br>优点：节省内存和外存空间，方便程序开发<br>缺点：增加了运行时的开销，是程序运行时速度变慢</p>\n<h3 id=\"2-程序的装入\"><a href=\"#2-程序的装入\" class=\"headerlink\" title=\"2.程序的装入\"></a>2.程序的装入</h3><p>装入方式：绝对装入方式、可重定位装入（静态装入方式）和动态运行时装入方式</p>\n<p><strong>绝对装入方式</strong>：编译程序已知程序在内存中的位置，编译时产生物理地址的目标代码，转入程序按照装入模块的物理地址将程序和数据装入内存<br><strong>可重定位装入方式</strong>：编译时不知道程序在内存中的位置，那么编译时就必须生成可重定位的代码，其中的地址都是逻辑地址，在程序转入内存时，再把逻辑地址映射为物理地址。程序装入时对目标称重的指令和数据地址修改的过程称之为重定位转入</p>\n<p>静态装入方式的特点：1)编译程序使目标模块的地址从0开始<br>2) 程序装入时，装入程序根据内存的使用情况将装入模块的装入内存的某个位置，并对模块进行重定位。物理地址=有效的逻辑地址+程序在内存中的其实位置</p>\n<p>动态运行时装入：当一个进程在被换出之前的内存地址与后来被从外存调入时的位置不同，这是地址映射延迟到进程执行时再进行。</p>\n<h2 id=\"3-连续分配的存储管理方式\"><a href=\"#3-连续分配的存储管理方式\" class=\"headerlink\" title=\"3.连续分配的存储管理方式\"></a>3.连续分配的存储管理方式</h2><ol>\n<li>单一连续去分配方式<br>适合于单用户单任务系统，内存分为系统区和用户区</li>\n<li>固定分区分配<br>将用户内存空间分配成若干固定大小的区域，每个区域运行一道用户程序；分区的数量固定的，大小也是固定的<br>每个分区大小相等的分配方式缺点是：内存利用率低，主要用于一个计算机去控制多个相同对象的场合，如冶炼炉<br>在一些实时系统中，固定分区的分配方式还是简单而有效的</li>\n<li>动态分区分配方式<br>用户分区的数量和大小都是动态变化的<br>分配原理：系统初始只有一个大的空闲分区，当进程请求内存资源时，系统根据请求资源的大小分配一片空闲区域给进程，当运行一段时间后，空闲分区可能散布在不连续的区域，这时候系统会维护一个记录当前空闲分区的数据接口，当进程请求内存时，系统从所有空闲分区中找到一个合适大小的空间给进程。<br>数据结构：空闲分区表和空闲分区链<br>空闲分区链可以动态为每个分区建立一个节点，每个节点包括分区大小、分区起始地址、指向前一个空闲分区节点的指针、指向后一个空闲分区节点的指针。每一个节点占用的内存动态分配、动态回收。</li>\n</ol>\n<p><strong>动态分区分配算法</strong><br>1) 首次适应算法FF<br>要求空闲分区链以地址递增的顺序进行连接，每次从链首开始查找，低地址空间可能会被反复划分 缺点：造成空间浪费，内存碎片<br>2) 循环首次适应算法NF<br>不在每次从链首开始查找，而是从上一次查找的空闲分区的下一个分区开始查找，每次应设置一个起始查找指针，指示下一次查找的分区<br>3) 最佳适应算法BF<br>为了方便查找，把所有空闲区，按照空闲大小递增的顺序进行排列，总是把大小和进程请求的内存空间大小接近的空间分配给进程。<br>优点：避免了大材小用，提高了内存的利用率<br>缺点：容易留下难以使用的小空闲区</p>\n<h2 id=\"4-基于分页存储的管理方式\"><a href=\"#4-基于分页存储的管理方式\" class=\"headerlink\" title=\"4. 基于分页存储的管理方式\"></a>4. 基于分页存储的管理方式</h2><p>把进程的存储在内存中的物理地址不连续的区域，这种内存管理方式称为离散内存管理方式。<br>离散内存管理分配内存空间的管理方式有：<strong>分页存储管理，分段存储管理、段也式存储管理</strong></p>\n<p><strong>页</strong>：将一个进程的逻辑地址空间分为若干个大小相等的片，，称之为页<br><strong>页框</strong>：将物理内存地址分成与页大小相同的若干个存储块，称之为页框</p>\n<p><strong>业内碎片</strong>：进程的最后一页一般装不满一个叶框，而形成了不可利用的碎片称为页内碎片。</p>\n<p><strong>页表</strong>：实现页号到页框的映射，在基本的分页制度中，每个进程有一个页表，进程的每一页在页表中有一个对应的页表项，页表在内存中连续存放。</p>\n<p><strong>分页管理方式的地址结构</strong><br>页的存储结构：<br>页号P   页内偏移量W<br>若用m位标识逻辑地址，页大小为2的n次方，则用低n位表示页内偏移量w,用高位m-n位表示P</p>\n<p>分页地址变换：实现逻辑地址到物理地址的转换<br>公式:物理地址=页框号x页框大小 + 页内偏移量</p>\n<p>为了减少cpu在有效访问内存时间上的开销，提高内存的速度，引入了快表机制<br><strong>快表</strong>:也称转换后的缓冲是为了提高访问内存速度而采用的专用缓存，存放最近访问过的页表项。</p>\n<h2 id=\"4-基于两级页表和多级页表的管理方式\"><a href=\"#4-基于两级页表和多级页表的管理方式\" class=\"headerlink\" title=\"4. 基于两级页表和多级页表的管理方式\"></a>4. 基于两级页表和多级页表的管理方式</h2><p>页表再分页，就形成了两级或者多级页表<br>两级页表：将页表再分页，使得每个页表分页的大小与内存页框的大小相同<br>页目录号实际是一个索引值，根据p1从也木勒表项中找到页表所在的页框号，页号p2是页表中的偏移量，根据p2可以知道应该从也飙中的第p2项找到进程页所在的页框号。</p>\n<h2 id=\"5-基于分页虚拟存储的系统\"><a href=\"#5-基于分页虚拟存储的系统\" class=\"headerlink\" title=\"5. 基于分页虚拟存储的系统\"></a>5. 基于分页虚拟存储的系统</h2><p>虚拟存储技术实现的基本思想是：只把进程的一部分装入内存，在进程执行的过程中，cpu访问内存如果发现所访问的内容不再内存中，则通过异常处理将所需的内容从外存调入内存。<br>虚拟存储技术的好处：<br>1) 提高内存的利用率<br>2) 提高多道程序度<br>3) 把逻辑地址空间和物理地址空间分开，程序员不用关心物理内存的容量对编程的限制。</p>\n<p><strong>虚拟存储技术的特征</strong><br>1) 离散性<br>2) 多次性<br>3) 对换性</p>\n<h2 id=\"6-页的分配策略\"><a href=\"#6-页的分配策略\" class=\"headerlink\" title=\"6. 页的分配策略\"></a>6. 页的分配策略</h2><p>最少页框数：是指保证进程正常运行所需的最少页框数。操作系统为进程分配的页应该大于或者等于最少页框数</p>\n<p>页分配策略：固定分配策略和可变分配策略<br>页置换策略：局部置换和全局置换。1)局部置换发生置换时，只从请求置换的进程本身的内存页中选择淘汰页，腾出内存空间 2)全局置换是指发生置换时，从所有进程的内存页中选择淘汰的页。<br>也有局部置换和全局置换组合的策略：1)固定分配局部置换 2可变分配局部置换 3)可变分配全局置换</p>\n<p><strong>分配算法</strong><br>1) 平均分配算法n进程m页框，则分配INT[m/n]个页框，余数放入缓冲<br>2) 按比例分配算法，为进程分配的页框数=进程页数/所有进程页数总和 * 总页框数<br>3) 优先权的分配算法</p>\n<h2 id=\"7-页调入策略\"><a href=\"#7-页调入策略\" class=\"headerlink\" title=\"7.页调入策略\"></a>7.页调入策略</h2><p>1) 系统可以在进程需要时将页调入内存，有利于内存的使用率，但是对系统的时间性能不利<br>2) 采用预先调入页的策略，将预计不久后会被访问的页预先调入内存</p>\n<h2 id=\"8-页置换算法\"><a href=\"#8-页置换算法\" class=\"headerlink\" title=\"8.页置换算法\"></a>8.页置换算法</h2><p>1) 最佳置换算法ORA:该算法选择以后永远不会被访问的页或者长时间不会被访问的页作为换出页<br>2) 先进先出置换算法FIFO：最简单。当选择换出页时，选择进入内存时间最早的页（用指针指示当前调入新页时，应当淘汰的那个也在队列中的位置，换出后，指针指向下一个应该淘汰的页）<br>3) 最久未使用的LRU置换算法：性能较好的算法，该算法是选择最久未使用的页换出。<br>4) 其他置换算法：附件引用位算法、简单clock算法、改进型clock算法、最少使用置换算法、页缓冲算法</p>\n<h2 id=\"9-分段存储管理\"><a href=\"#9-分段存储管理\" class=\"headerlink\" title=\"9.分段存储管理\"></a>9.分段存储管理</h2><p>引入分段机制的优点是方便编程、分段共享、分段保护、动态链接以及存储空间的动态增长</p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"内存管理的目标\"><a href=\"#内存管理的目标\" class=\"headerlink\" title=\"内存管理的目标\"></a>内存管理的目标</h1><p>1) 实现内存分配、内存回收等操作<br>2) 提高内存的利用率和内存的访问速度<br>即充分利用现有的内存资源，为应用程序提供方便的内存使用方式和一个快速、安全且充分大的存储器</p>\n<h1 id=\"程序的链接和装入\"><a href=\"#程序的链接和装入\" class=\"headerlink\" title=\"程序的链接和装入\"></a>程序的链接和装入</h1><p>链接要解决的问题是将编译后的目标模块装配成一个可执行的程序，分为静态链接和动态链接</p>\n<h3 id=\"1-程序链接\"><a href=\"#1-程序链接\" class=\"headerlink\" title=\"1. 程序链接\"></a>1. 程序链接</h3><p><strong>静态链接</strong>：在程序运行之前，用链接程序将目标模块连接成一个完整的转入模块，任务：一是对逻辑地址进行修改，二是转换外部调用符号<br>优点：运行速度快 缺点：可执行文件较大，占用空间大，系统开销大，程序开发不够灵活，修改一个模块会导致整个程序重新连接</p>\n<p><strong>动态链接</strong><br>可将某些目标模块的链接推迟到这些模块中的函数要被调用时再进行。<br>优点：节省内存和外存空间，方便程序开发<br>缺点：增加了运行时的开销，是程序运行时速度变慢</p>\n<h3 id=\"2-程序的装入\"><a href=\"#2-程序的装入\" class=\"headerlink\" title=\"2.程序的装入\"></a>2.程序的装入</h3><p>装入方式：绝对装入方式、可重定位装入（静态装入方式）和动态运行时装入方式</p>\n<p><strong>绝对装入方式</strong>：编译程序已知程序在内存中的位置，编译时产生物理地址的目标代码，转入程序按照装入模块的物理地址将程序和数据装入内存<br><strong>可重定位装入方式</strong>：编译时不知道程序在内存中的位置，那么编译时就必须生成可重定位的代码，其中的地址都是逻辑地址，在程序转入内存时，再把逻辑地址映射为物理地址。程序装入时对目标称重的指令和数据地址修改的过程称之为重定位转入</p>\n<p>静态装入方式的特点：1)编译程序使目标模块的地址从0开始<br>2) 程序装入时，装入程序根据内存的使用情况将装入模块的装入内存的某个位置，并对模块进行重定位。物理地址=有效的逻辑地址+程序在内存中的其实位置</p>\n<p>动态运行时装入：当一个进程在被换出之前的内存地址与后来被从外存调入时的位置不同，这是地址映射延迟到进程执行时再进行。</p>\n<h2 id=\"3-连续分配的存储管理方式\"><a href=\"#3-连续分配的存储管理方式\" class=\"headerlink\" title=\"3.连续分配的存储管理方式\"></a>3.连续分配的存储管理方式</h2><ol>\n<li>单一连续去分配方式<br>适合于单用户单任务系统，内存分为系统区和用户区</li>\n<li>固定分区分配<br>将用户内存空间分配成若干固定大小的区域，每个区域运行一道用户程序；分区的数量固定的，大小也是固定的<br>每个分区大小相等的分配方式缺点是：内存利用率低，主要用于一个计算机去控制多个相同对象的场合，如冶炼炉<br>在一些实时系统中，固定分区的分配方式还是简单而有效的</li>\n<li>动态分区分配方式<br>用户分区的数量和大小都是动态变化的<br>分配原理：系统初始只有一个大的空闲分区，当进程请求内存资源时，系统根据请求资源的大小分配一片空闲区域给进程，当运行一段时间后，空闲分区可能散布在不连续的区域，这时候系统会维护一个记录当前空闲分区的数据接口，当进程请求内存时，系统从所有空闲分区中找到一个合适大小的空间给进程。<br>数据结构：空闲分区表和空闲分区链<br>空闲分区链可以动态为每个分区建立一个节点，每个节点包括分区大小、分区起始地址、指向前一个空闲分区节点的指针、指向后一个空闲分区节点的指针。每一个节点占用的内存动态分配、动态回收。</li>\n</ol>\n<p><strong>动态分区分配算法</strong><br>1) 首次适应算法FF<br>要求空闲分区链以地址递增的顺序进行连接，每次从链首开始查找，低地址空间可能会被反复划分 缺点：造成空间浪费，内存碎片<br>2) 循环首次适应算法NF<br>不在每次从链首开始查找，而是从上一次查找的空闲分区的下一个分区开始查找，每次应设置一个起始查找指针，指示下一次查找的分区<br>3) 最佳适应算法BF<br>为了方便查找，把所有空闲区，按照空闲大小递增的顺序进行排列，总是把大小和进程请求的内存空间大小接近的空间分配给进程。<br>优点：避免了大材小用，提高了内存的利用率<br>缺点：容易留下难以使用的小空闲区</p>\n<h2 id=\"4-基于分页存储的管理方式\"><a href=\"#4-基于分页存储的管理方式\" class=\"headerlink\" title=\"4. 基于分页存储的管理方式\"></a>4. 基于分页存储的管理方式</h2><p>把进程的存储在内存中的物理地址不连续的区域，这种内存管理方式称为离散内存管理方式。<br>离散内存管理分配内存空间的管理方式有：<strong>分页存储管理，分段存储管理、段也式存储管理</strong></p>\n<p><strong>页</strong>：将一个进程的逻辑地址空间分为若干个大小相等的片，，称之为页<br><strong>页框</strong>：将物理内存地址分成与页大小相同的若干个存储块，称之为页框</p>\n<p><strong>业内碎片</strong>：进程的最后一页一般装不满一个叶框，而形成了不可利用的碎片称为页内碎片。</p>\n<p><strong>页表</strong>：实现页号到页框的映射，在基本的分页制度中，每个进程有一个页表，进程的每一页在页表中有一个对应的页表项，页表在内存中连续存放。</p>\n<p><strong>分页管理方式的地址结构</strong><br>页的存储结构：<br>页号P   页内偏移量W<br>若用m位标识逻辑地址，页大小为2的n次方，则用低n位表示页内偏移量w,用高位m-n位表示P</p>\n<p>分页地址变换：实现逻辑地址到物理地址的转换<br>公式:物理地址=页框号x页框大小 + 页内偏移量</p>\n<p>为了减少cpu在有效访问内存时间上的开销，提高内存的速度，引入了快表机制<br><strong>快表</strong>:也称转换后的缓冲是为了提高访问内存速度而采用的专用缓存，存放最近访问过的页表项。</p>\n<h2 id=\"4-基于两级页表和多级页表的管理方式\"><a href=\"#4-基于两级页表和多级页表的管理方式\" class=\"headerlink\" title=\"4. 基于两级页表和多级页表的管理方式\"></a>4. 基于两级页表和多级页表的管理方式</h2><p>页表再分页，就形成了两级或者多级页表<br>两级页表：将页表再分页，使得每个页表分页的大小与内存页框的大小相同<br>页目录号实际是一个索引值，根据p1从也木勒表项中找到页表所在的页框号，页号p2是页表中的偏移量，根据p2可以知道应该从也飙中的第p2项找到进程页所在的页框号。</p>\n<h2 id=\"5-基于分页虚拟存储的系统\"><a href=\"#5-基于分页虚拟存储的系统\" class=\"headerlink\" title=\"5. 基于分页虚拟存储的系统\"></a>5. 基于分页虚拟存储的系统</h2><p>虚拟存储技术实现的基本思想是：只把进程的一部分装入内存，在进程执行的过程中，cpu访问内存如果发现所访问的内容不再内存中，则通过异常处理将所需的内容从外存调入内存。<br>虚拟存储技术的好处：<br>1) 提高内存的利用率<br>2) 提高多道程序度<br>3) 把逻辑地址空间和物理地址空间分开，程序员不用关心物理内存的容量对编程的限制。</p>\n<p><strong>虚拟存储技术的特征</strong><br>1) 离散性<br>2) 多次性<br>3) 对换性</p>\n<h2 id=\"6-页的分配策略\"><a href=\"#6-页的分配策略\" class=\"headerlink\" title=\"6. 页的分配策略\"></a>6. 页的分配策略</h2><p>最少页框数：是指保证进程正常运行所需的最少页框数。操作系统为进程分配的页应该大于或者等于最少页框数</p>\n<p>页分配策略：固定分配策略和可变分配策略<br>页置换策略：局部置换和全局置换。1)局部置换发生置换时，只从请求置换的进程本身的内存页中选择淘汰页，腾出内存空间 2)全局置换是指发生置换时，从所有进程的内存页中选择淘汰的页。<br>也有局部置换和全局置换组合的策略：1)固定分配局部置换 2可变分配局部置换 3)可变分配全局置换</p>\n<p><strong>分配算法</strong><br>1) 平均分配算法n进程m页框，则分配INT[m/n]个页框，余数放入缓冲<br>2) 按比例分配算法，为进程分配的页框数=进程页数/所有进程页数总和 * 总页框数<br>3) 优先权的分配算法</p>\n<h2 id=\"7-页调入策略\"><a href=\"#7-页调入策略\" class=\"headerlink\" title=\"7.页调入策略\"></a>7.页调入策略</h2><p>1) 系统可以在进程需要时将页调入内存，有利于内存的使用率，但是对系统的时间性能不利<br>2) 采用预先调入页的策略，将预计不久后会被访问的页预先调入内存</p>\n<h2 id=\"8-页置换算法\"><a href=\"#8-页置换算法\" class=\"headerlink\" title=\"8.页置换算法\"></a>8.页置换算法</h2><p>1) 最佳置换算法ORA:该算法选择以后永远不会被访问的页或者长时间不会被访问的页作为换出页<br>2) 先进先出置换算法FIFO：最简单。当选择换出页时，选择进入内存时间最早的页（用指针指示当前调入新页时，应当淘汰的那个也在队列中的位置，换出后，指针指向下一个应该淘汰的页）<br>3) 最久未使用的LRU置换算法：性能较好的算法，该算法是选择最久未使用的页换出。<br>4) 其他置换算法：附件引用位算法、简单clock算法、改进型clock算法、最少使用置换算法、页缓冲算法</p>\n<h2 id=\"9-分段存储管理\"><a href=\"#9-分段存储管理\" class=\"headerlink\" title=\"9.分段存储管理\"></a>9.分段存储管理</h2><p>引入分段机制的优点是方便编程、分段共享、分段保护、动态链接以及存储空间的动态增长</p>\n"},{"title":"操作系统原理——进程调度与死锁","date":"2021-07-11T06:25:00.000Z","author":"okeeper","_content":"\n# 一、进程调度\n进程的调度室指按照某种策略或算法从就绪进程中为当前空闲的cpu选择在其上运行的新进程\n\n# 二、进程的调度算法\n##1. 时间概念\n**周转时间**是指从作业开始提交给系统开始，到作业完成为止系统的\n**平均周转时间T**=N各种作业的周转时间之和除以n\n**带权周转时间**=作业的周转时间/系统为它提供服务时间\n**响应时间**=用户从提交一个请求开始至系统首次响应的时间为止的一段时间\n**截止时间**=是指某个人物必须开始执行的最迟时间，或者必须完成的最迟时间\n\n## 2. 调度算法优劣的准则\n- 周转时间短\n- 响应时间快\n- 截止时间保证\n- 系统吞吐量高\n- CPU利用率好\n\n## 3. 调度算法\n1. 先来先服务(FCFS),从就绪队首选择最先到达就绪队列的进程\n优缺点：FCFS适合长进程，不利于短进程，适合CPU繁忙型的进程，不适合IO繁忙型的进程\n2. 短进程调度优先(SPF)，短进程优先算法有效降低进程的平均等待时间，提高系统的吞吐量\n3. 调度算法优先(SPL),分为非抢占式优先调度算法，抢占式优先权调度；优先权的调度类型：静态优先权和动态优先权\n4. 时间片轮转调度算法(RR),时间片大小确认考虑的因素：\n    1. 系统对响应时间的要求，响应时间越短，时间片取值应该越小。\n    2. 就绪队列中的进程数\n    3. 系统的处理能力\n    \n5. 多级队列调度，不同的队列优先权不同，调度算法也可能不同\n6. 多级反馈队列调度，队列优先权越高，时间片越短，时间片通常成倍增长。\n\n##实时系统中的调度 \n1. 提供必要的调度信息\n2. 系统处理能力强\n3. 采用抢占式调度机制\n4. 具有快速切换机制\n\n## 死锁\n死锁是由于多个进程竞争共享资源引起的进程不能向前推进的僵死状态\n\n产生死锁的原因：竞争死锁资源且分配资源的顺序不当\n产生死锁的必要条件：\n1. 互斥\n2. 请求保持\n3. 不剥夺\n4. 环路等待\n\n处理死锁的防范：\n1. 预防死锁\n2. 避免死锁，资源分配的状态分为安全和不安全状态，不安全状态不一定产生死锁，但是系统进入安全状态一定不会产生死锁，这样就可以避免死锁的产生，银行家算法就是一种系统避免系统死锁的一种检测算法，其基本思想是：一个进程提出资源请求后，系统进行资源的试分配。然后检测此次分配是否处于安全状态，若安全则按分配方案分配资源，否则不进行分配资源。\n3. 检测并解除死锁\n4. 忽略死锁\n\n某系统中有3个并发进程，都需要同类资源4个，试问该系统保证不会发生死锁的最少资源数是______\n如果一个进程有m个资源它就能够结束，不会使自己陷入死锁中。因此最差情况是每个进程有m-1个资源并且需要另外一个资源。如果留下有一个资源可用，那么其中某个进程就能够结束并释放它的所有资源，使其它进程也能够结束。所以避免死锁的条件是：r≥p(m-1)+1。带入上述条件公式：**r≥3*(4-1)+1=10**。所以答案为10个。","source":"_posts/操作系统原理/操作系统原理——进程调度与死锁.md","raw":"---\ntitle: 操作系统原理——进程调度与死锁\ndate: 2021-07-11 14:25:00\nauthor: okeeper\ncategories: 操作系统原理\ntags:\n  - 操作系统原理\n---\n\n# 一、进程调度\n进程的调度室指按照某种策略或算法从就绪进程中为当前空闲的cpu选择在其上运行的新进程\n\n# 二、进程的调度算法\n##1. 时间概念\n**周转时间**是指从作业开始提交给系统开始，到作业完成为止系统的\n**平均周转时间T**=N各种作业的周转时间之和除以n\n**带权周转时间**=作业的周转时间/系统为它提供服务时间\n**响应时间**=用户从提交一个请求开始至系统首次响应的时间为止的一段时间\n**截止时间**=是指某个人物必须开始执行的最迟时间，或者必须完成的最迟时间\n\n## 2. 调度算法优劣的准则\n- 周转时间短\n- 响应时间快\n- 截止时间保证\n- 系统吞吐量高\n- CPU利用率好\n\n## 3. 调度算法\n1. 先来先服务(FCFS),从就绪队首选择最先到达就绪队列的进程\n优缺点：FCFS适合长进程，不利于短进程，适合CPU繁忙型的进程，不适合IO繁忙型的进程\n2. 短进程调度优先(SPF)，短进程优先算法有效降低进程的平均等待时间，提高系统的吞吐量\n3. 调度算法优先(SPL),分为非抢占式优先调度算法，抢占式优先权调度；优先权的调度类型：静态优先权和动态优先权\n4. 时间片轮转调度算法(RR),时间片大小确认考虑的因素：\n    1. 系统对响应时间的要求，响应时间越短，时间片取值应该越小。\n    2. 就绪队列中的进程数\n    3. 系统的处理能力\n    \n5. 多级队列调度，不同的队列优先权不同，调度算法也可能不同\n6. 多级反馈队列调度，队列优先权越高，时间片越短，时间片通常成倍增长。\n\n##实时系统中的调度 \n1. 提供必要的调度信息\n2. 系统处理能力强\n3. 采用抢占式调度机制\n4. 具有快速切换机制\n\n## 死锁\n死锁是由于多个进程竞争共享资源引起的进程不能向前推进的僵死状态\n\n产生死锁的原因：竞争死锁资源且分配资源的顺序不当\n产生死锁的必要条件：\n1. 互斥\n2. 请求保持\n3. 不剥夺\n4. 环路等待\n\n处理死锁的防范：\n1. 预防死锁\n2. 避免死锁，资源分配的状态分为安全和不安全状态，不安全状态不一定产生死锁，但是系统进入安全状态一定不会产生死锁，这样就可以避免死锁的产生，银行家算法就是一种系统避免系统死锁的一种检测算法，其基本思想是：一个进程提出资源请求后，系统进行资源的试分配。然后检测此次分配是否处于安全状态，若安全则按分配方案分配资源，否则不进行分配资源。\n3. 检测并解除死锁\n4. 忽略死锁\n\n某系统中有3个并发进程，都需要同类资源4个，试问该系统保证不会发生死锁的最少资源数是______\n如果一个进程有m个资源它就能够结束，不会使自己陷入死锁中。因此最差情况是每个进程有m-1个资源并且需要另外一个资源。如果留下有一个资源可用，那么其中某个进程就能够结束并释放它的所有资源，使其它进程也能够结束。所以避免死锁的条件是：r≥p(m-1)+1。带入上述条件公式：**r≥3*(4-1)+1=10**。所以答案为10个。","slug":"操作系统原理/操作系统原理——进程调度与死锁","published":1,"updated":"2022-08-25T09:12:18.836Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczix001fvwm1nu256f5j","content":"<h1 id=\"一、进程调度\"><a href=\"#一、进程调度\" class=\"headerlink\" title=\"一、进程调度\"></a>一、进程调度</h1><p>进程的调度室指按照某种策略或算法从就绪进程中为当前空闲的cpu选择在其上运行的新进程</p>\n<h1 id=\"二、进程的调度算法\"><a href=\"#二、进程的调度算法\" class=\"headerlink\" title=\"二、进程的调度算法\"></a>二、进程的调度算法</h1><p>##1. 时间概念<br><strong>周转时间</strong>是指从作业开始提交给系统开始，到作业完成为止系统的<br><strong>平均周转时间T</strong>=N各种作业的周转时间之和除以n<br><strong>带权周转时间</strong>=作业的周转时间/系统为它提供服务时间<br><strong>响应时间</strong>=用户从提交一个请求开始至系统首次响应的时间为止的一段时间<br><strong>截止时间</strong>=是指某个人物必须开始执行的最迟时间，或者必须完成的最迟时间</p>\n<h2 id=\"2-调度算法优劣的准则\"><a href=\"#2-调度算法优劣的准则\" class=\"headerlink\" title=\"2. 调度算法优劣的准则\"></a>2. 调度算法优劣的准则</h2><ul>\n<li>周转时间短</li>\n<li>响应时间快</li>\n<li>截止时间保证</li>\n<li>系统吞吐量高</li>\n<li>CPU利用率好</li>\n</ul>\n<h2 id=\"3-调度算法\"><a href=\"#3-调度算法\" class=\"headerlink\" title=\"3. 调度算法\"></a>3. 调度算法</h2><ol>\n<li><p>先来先服务(FCFS),从就绪队首选择最先到达就绪队列的进程<br>优缺点：FCFS适合长进程，不利于短进程，适合CPU繁忙型的进程，不适合IO繁忙型的进程</p>\n</li>\n<li><p>短进程调度优先(SPF)，短进程优先算法有效降低进程的平均等待时间，提高系统的吞吐量</p>\n</li>\n<li><p>调度算法优先(SPL),分为非抢占式优先调度算法，抢占式优先权调度；优先权的调度类型：静态优先权和动态优先权</p>\n</li>\n<li><p>时间片轮转调度算法(RR),时间片大小确认考虑的因素：</p>\n<ol>\n<li>系统对响应时间的要求，响应时间越短，时间片取值应该越小。</li>\n<li>就绪队列中的进程数</li>\n<li>系统的处理能力</li>\n</ol>\n</li>\n<li><p>多级队列调度，不同的队列优先权不同，调度算法也可能不同</p>\n</li>\n<li><p>多级反馈队列调度，队列优先权越高，时间片越短，时间片通常成倍增长。</p>\n</li>\n</ol>\n<p>##实时系统中的调度 </p>\n<ol>\n<li>提供必要的调度信息</li>\n<li>系统处理能力强</li>\n<li>采用抢占式调度机制</li>\n<li>具有快速切换机制</li>\n</ol>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>死锁是由于多个进程竞争共享资源引起的进程不能向前推进的僵死状态</p>\n<p>产生死锁的原因：竞争死锁资源且分配资源的顺序不当<br>产生死锁的必要条件：</p>\n<ol>\n<li>互斥</li>\n<li>请求保持</li>\n<li>不剥夺</li>\n<li>环路等待</li>\n</ol>\n<p>处理死锁的防范：</p>\n<ol>\n<li>预防死锁</li>\n<li>避免死锁，资源分配的状态分为安全和不安全状态，不安全状态不一定产生死锁，但是系统进入安全状态一定不会产生死锁，这样就可以避免死锁的产生，银行家算法就是一种系统避免系统死锁的一种检测算法，其基本思想是：一个进程提出资源请求后，系统进行资源的试分配。然后检测此次分配是否处于安全状态，若安全则按分配方案分配资源，否则不进行分配资源。</li>\n<li>检测并解除死锁</li>\n<li>忽略死锁</li>\n</ol>\n<p>某系统中有3个并发进程，都需要同类资源4个，试问该系统保证不会发生死锁的最少资源数是<strong>__</strong><br>如果一个进程有m个资源它就能够结束，不会使自己陷入死锁中。因此最差情况是每个进程有m-1个资源并且需要另外一个资源。如果留下有一个资源可用，那么其中某个进程就能够结束并释放它的所有资源，使其它进程也能够结束。所以避免死锁的条件是：r≥p(m-1)+1。带入上述条件公式：<strong>r≥3*(4-1)+1=10</strong>。所以答案为10个。</p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"一、进程调度\"><a href=\"#一、进程调度\" class=\"headerlink\" title=\"一、进程调度\"></a>一、进程调度</h1><p>进程的调度室指按照某种策略或算法从就绪进程中为当前空闲的cpu选择在其上运行的新进程</p>\n<h1 id=\"二、进程的调度算法\"><a href=\"#二、进程的调度算法\" class=\"headerlink\" title=\"二、进程的调度算法\"></a>二、进程的调度算法</h1><p>##1. 时间概念<br><strong>周转时间</strong>是指从作业开始提交给系统开始，到作业完成为止系统的<br><strong>平均周转时间T</strong>=N各种作业的周转时间之和除以n<br><strong>带权周转时间</strong>=作业的周转时间/系统为它提供服务时间<br><strong>响应时间</strong>=用户从提交一个请求开始至系统首次响应的时间为止的一段时间<br><strong>截止时间</strong>=是指某个人物必须开始执行的最迟时间，或者必须完成的最迟时间</p>\n<h2 id=\"2-调度算法优劣的准则\"><a href=\"#2-调度算法优劣的准则\" class=\"headerlink\" title=\"2. 调度算法优劣的准则\"></a>2. 调度算法优劣的准则</h2><ul>\n<li>周转时间短</li>\n<li>响应时间快</li>\n<li>截止时间保证</li>\n<li>系统吞吐量高</li>\n<li>CPU利用率好</li>\n</ul>\n<h2 id=\"3-调度算法\"><a href=\"#3-调度算法\" class=\"headerlink\" title=\"3. 调度算法\"></a>3. 调度算法</h2><ol>\n<li><p>先来先服务(FCFS),从就绪队首选择最先到达就绪队列的进程<br>优缺点：FCFS适合长进程，不利于短进程，适合CPU繁忙型的进程，不适合IO繁忙型的进程</p>\n</li>\n<li><p>短进程调度优先(SPF)，短进程优先算法有效降低进程的平均等待时间，提高系统的吞吐量</p>\n</li>\n<li><p>调度算法优先(SPL),分为非抢占式优先调度算法，抢占式优先权调度；优先权的调度类型：静态优先权和动态优先权</p>\n</li>\n<li><p>时间片轮转调度算法(RR),时间片大小确认考虑的因素：</p>\n<ol>\n<li>系统对响应时间的要求，响应时间越短，时间片取值应该越小。</li>\n<li>就绪队列中的进程数</li>\n<li>系统的处理能力</li>\n</ol>\n</li>\n<li><p>多级队列调度，不同的队列优先权不同，调度算法也可能不同</p>\n</li>\n<li><p>多级反馈队列调度，队列优先权越高，时间片越短，时间片通常成倍增长。</p>\n</li>\n</ol>\n<p>##实时系统中的调度 </p>\n<ol>\n<li>提供必要的调度信息</li>\n<li>系统处理能力强</li>\n<li>采用抢占式调度机制</li>\n<li>具有快速切换机制</li>\n</ol>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>死锁是由于多个进程竞争共享资源引起的进程不能向前推进的僵死状态</p>\n<p>产生死锁的原因：竞争死锁资源且分配资源的顺序不当<br>产生死锁的必要条件：</p>\n<ol>\n<li>互斥</li>\n<li>请求保持</li>\n<li>不剥夺</li>\n<li>环路等待</li>\n</ol>\n<p>处理死锁的防范：</p>\n<ol>\n<li>预防死锁</li>\n<li>避免死锁，资源分配的状态分为安全和不安全状态，不安全状态不一定产生死锁，但是系统进入安全状态一定不会产生死锁，这样就可以避免死锁的产生，银行家算法就是一种系统避免系统死锁的一种检测算法，其基本思想是：一个进程提出资源请求后，系统进行资源的试分配。然后检测此次分配是否处于安全状态，若安全则按分配方案分配资源，否则不进行分配资源。</li>\n<li>检测并解除死锁</li>\n<li>忽略死锁</li>\n</ol>\n<p>某系统中有3个并发进程，都需要同类资源4个，试问该系统保证不会发生死锁的最少资源数是<strong>__</strong><br>如果一个进程有m个资源它就能够结束，不会使自己陷入死锁中。因此最差情况是每个进程有m-1个资源并且需要另外一个资源。如果留下有一个资源可用，那么其中某个进程就能够结束并释放它的所有资源，使其它进程也能够结束。所以避免死锁的条件是：r≥p(m-1)+1。带入上述条件公式：<strong>r≥3*(4-1)+1=10</strong>。所以答案为10个。</p>\n"},{"title":"操作系统原理——初识操作系统","date":"2021-10-29T01:25:00.000Z","author":"okeeper","_content":"\n# 什么是操作系统\n  操作系统是提供计算机用不与计算机硬件之间的使用接口，并能够管理计算机软件和硬件资源的一个复杂的系统软件，为用户的应用程序提供直接可用的运行环境，是应用程序的开发变得简单、高效。\n  试想一下如果没有操作系统，你将怎样写代码？\n  例如你要写一个实现`printf(\"hello world\")`的功能，你要怎么实现呢？\n  无操作系统的环境下，你只能使用汇编语言直接操作硬件接口\n  ```\n  xor ah,ah;//对ah、dl清零\n  xor dl,dl;//软驱复位\n  int13h;//BIOS功能调用int 13h中断\n  ... //此处省略n行代码\n  mov cl,ah;//其实扇区号送cl寄存器\n  mov dh,al;\n  ```\n\n  可以看出一个简单的功能，要实现一大段的代码，并且没有的计算机资源做统一的管理，极大的降低程序运行的效率和开发效率。\n\n# 操作系统的发展历史\n## 无操作系统时代\n第一代计算机（1945~1955年）使用电子管作为主要电子器件，用插件版的链接先或穿孔片表示程序，没有用来存储程序的内存，无操作系统的。\n我们熟知的那个庞然大物——人类第一台计算机\"艾尼阿克\"（ENIAC）就是这样的计算机，最初只能完成5000每秒的计算，耗电量在150千万每小时。程序的编程只能通过改变电路的链接方式来表示不同的算法，程序的运行与退出都需要人工的干预，这就是我们人类最初的计算机\n![](https://leanote.com/api/file/getImage?fileId=5ce16d88ab64414b37003427)\n\n## 单道批量处理计算机\n从第一代计算机开始大概经过了10年的发展，开始使用磁性存储设备，程序员在磁带上录入多批次的作业，交给计算机操作人员，放入计算机中批量载入计算机，计算机会一个一个计算并将结果输出到另外一个磁性设备。这一时期的操作系统就是单到批处理系统，内存红能主流移到用户作业，cup和内存资源被用户作业独占。程序是指令的集合，程序执行是cpu的依次、逐条执行指令的过程。相比于上一代计算机，减少了等待人工操作的时间，但是作业进行I/O时，CPU只能等待I/O完成而无事可做，cpu资源得不到充分利用\n\n## 多道批处理系统的特点\n为了解决上一代计算机的问题，有发展到了多道批处理系统。\n与单道批处理系统相比，躲到批处理系统支持多道程序驻留内存，cpu不在因为某个进程等待I/O而空闲，而是可以去执行其他进程。\n\n## 分时操作系统\n分时操作系统运行多个用户通过终端同时使用计算机。分时操作系统需要解决的两个关键问题是及时接收和及时处理。分时操作系统为例保证每个用户终端的相应时间，使所有的用户任务直接进入内存，并在很短的时间内快速切换让每个任务都运行一遍，达到多个用户任务并行处理的目的。\n\n## 实时操作系统\n实时操作系统主要用户实时控制和实时信息处理领域。与分时系统相比，它具有多路性、独立性、及时性、交互性、可靠性几个特点。\n实时系统比分时系统要求有更高的可靠性，必须能够在任务能够容忍的时间范围内处理完，否则可能带来巨大的经济损失设置生命安全。批处理系统、分时系统和实时系统是三种基本的草鞋系统类型，实时操作系统可能兼有三者货主其中两者的功能特征.\n\n#操作系统的五大功能\n## 内存管理\n内存管理主要是为多道程序运行提供良好的环境，方便用户使用内存，提高内存的利用率，已经从逻辑上扩充内存以实现虚拟存储。包括内存分配、内存保护、地址映射、内存扩充功能。\n### 内存分配\n内存分配可分为静态分配和动态分配，静态是指按程序所需分配固定大小后不再变化，动态分配是指在系统运行中，根据进程的骑牛分配内存大小，是可以在运行时变化的。\n为了实现内存分配，需要实现以下几个功能：\n1. 适用于内存分配的数据结构，包含内存的使用情况，内存的空闲区大小，空闲区的起始地址，未内存分配实现提供依据。\n2. 内存分配功能。系统安装一定的内存分配算法分配内存空间。\n3. 内存回收。系统需要回收被释放的内存空间。\n\n### 内存保护\n内存保护的任务：一是是操作系统内核的空间不会被用户随意访问，以保证系统的稳定安全。二是是没道用户程序都在自己的内存空间中运行，相对独立互不干扰。\n\n### 地址映射\ncpu执行程序的过程中，需要把程序的逻辑地址转变成物理地址，这个转换过程称为地址映射。\n\n逻辑地址：是指一个程序编译后，通常会形成若干个目标程序，这些程序再经过链接而形成可装载的程序。这些程序中的指令和数据的地址都是相对于编译链接后的机器代码程序的起始地址计算的。称之为逻辑地址。\n\n### 内存扩充\n为了满足程序的更大内存需求，就要为其从逻辑上扩充更大的内存，需要实现以下功能：\n1. 请求调入功能。运行系统在装入一部分用户程序是就启动该程序的运行，若在程序运行过程中发现要执行的指令货主要访问的数据没有载入内存，通过请求调入装入内存。\n2. 置换功能。在请求调入是，若发现内存空间不足，需要系统将内存中一部分内存换到外存中，以便腾出内存空间载入当前需要的内容。\n\n## 进程管理\n进程管理主要包括：经常的组织和描述、进程的控制、进程的同步、进程同学及进程调度。例如进程的创建、销毁、唤醒、阻塞等操作。\n\n## 设备管理\n设备管理主要完成用户的I/O请求，未用户分配I/O设备。为了完成这些任务，设备管理需要具备以下功能：\n1. 缓冲管理。\n2. 设备分配。分配用户I/O所需的设备。\n3. 设备处理。由设备驱动程序来实现cpu与设备控制之间的通讯。\n4. 设备独立性和虚拟设备。设备独立性功能是应用程序独立于物理设备。例如，用高级程序设计语言打印图形程序。\n\n\n## 文件管理\n文件存储空间的管理、文件目录的管理、文件读写\n\n## 提供用户接口\n为了方便用户使用操作系统，操作系统向用户提供命令行和图形用户接口，向程序员提供应用程序与操作系统之间的接口。\n\n# 操作系统的体系结构\n操作系统的体系结构是一个复杂软件系统的高层结构，未软件系统提供了一个结构、行为和属性的高级抽象，包括系统元素的结构、元素拣的相互关系，以及指导元素集成的模式和约束。\n\n## 简单的监控程序模型\n最初的计算机并不存在操作系统这个概念，所有的任务都是直接运行与硬件上，程序员直接操作硬件系统。随着控制语言的出现，产生了简单的监控程序，能够保证任意时刻系统只能运行一个任务，保证对系统信息的互斥访问。\n\n## 单体结构模型\n在单体结构模型中，多有的软件和数据结构防止在一个逻辑模块中，对外出的用户程序提供一个完成的内核界面——系统调用。整个系统有若干个功能独立的子程序组成，运行任意一子程序调用其他子程序，因此它的特点是结构简单，便于理解和实现，而且系统所有的部分都集中在一个内核中，效期较高，缺点也很明显，各个子程序之间可以相互调用，系统结构关系复杂，容易引起循环调用和死锁。\n\n## 层次结构模型\n层次结构的基本思想是讲操作系统分解为多个晓得容易理解的层，系统功能被隔离在不同的层中，每一层提供对系统功能的部分抽象。在操作系统的层次结构中，各个模块都有相对固定的位置、相对固定的层次。层与层之间有间隔的接口定义，每一次值依赖于它下层提供的服务而工作，不能夸层随意访问。不过出于效率的考虑，有些系统运行夸层乡下调用。\n\n## 客户/服务器模型与微内核结构\n它的核心思想是功能外迁，即吧传统操作系统内核中的一些组成部分（如文件系统、网络、驱动程序等内核功能）放到内核之外作为一个独立的服务进程来实现，在微内核中只保留了操作系统最基本的功能，包括处理器调度、存储管理和消息通道等。\n\n## 动态可扩展结构模型\n采用UPCALL和DOWNLOAD技术。它试图将所有的传统操作系统内核中提供的抽象转移到用户控件，以操作系统库的形式提供服务，内核层只负责对物理设备的控制。应用程序可以从用户层库中得到并控件内核抽象，从而实现了操作系统的动态扩展。\n\n# 指令的执行\n## 取指令和执行指令\n1. 取指令，在每个指令周期开会时，处理器从存储器中读取一条指令，在典型的固定长度指令处理器中，程序计数器（PC）保存有下一次要取的指令地址，每次取指令后都对PC作递增，使它能够按顺序读取吓一条指令，即位于下一个高端存储器地址的指令。\n2. 执行指令，取到指令被防止在处理器的指令寄存器IR中。指令中包含确定处理器将要采取动作的位，处理器解释指令并执行要求的动作，这些动作可分为4类：\n2.1 处理器与存储器之间的指令或数据传送操作。\n2.2 处理器与I/O设备质检的指令或数据传送操作\n2.3 算数运算操作或逻辑运算操作\n2.4 控制操作，即修改指令的执行顺序的操作。\n\n## 小结\n程序执行过程是反复取指令和执行指令的过程。PC使用存有下一条指令的地址。指令的执行结果就是使寄存器或内存单元的值发生变化，指令执行的过程也就是存储体内容不断变化的过程。取指令和执行指令是有硬件完成的，不同硬件的体系结构支持不同的指令集合，为某一种硬件平台开发的操作系统不能直接在另外一中体系结构的硬件上运行。","source":"_posts/操作系统原理/操作系统原理——初识操作系统.md","raw":"---\ntitle: 操作系统原理——初识操作系统\ndate: 2021-10-29 09:25:00\nauthor: okeeper\ncategories: 操作系统原理\ntags:\n  - 操作系统原理\n---\n\n# 什么是操作系统\n  操作系统是提供计算机用不与计算机硬件之间的使用接口，并能够管理计算机软件和硬件资源的一个复杂的系统软件，为用户的应用程序提供直接可用的运行环境，是应用程序的开发变得简单、高效。\n  试想一下如果没有操作系统，你将怎样写代码？\n  例如你要写一个实现`printf(\"hello world\")`的功能，你要怎么实现呢？\n  无操作系统的环境下，你只能使用汇编语言直接操作硬件接口\n  ```\n  xor ah,ah;//对ah、dl清零\n  xor dl,dl;//软驱复位\n  int13h;//BIOS功能调用int 13h中断\n  ... //此处省略n行代码\n  mov cl,ah;//其实扇区号送cl寄存器\n  mov dh,al;\n  ```\n\n  可以看出一个简单的功能，要实现一大段的代码，并且没有的计算机资源做统一的管理，极大的降低程序运行的效率和开发效率。\n\n# 操作系统的发展历史\n## 无操作系统时代\n第一代计算机（1945~1955年）使用电子管作为主要电子器件，用插件版的链接先或穿孔片表示程序，没有用来存储程序的内存，无操作系统的。\n我们熟知的那个庞然大物——人类第一台计算机\"艾尼阿克\"（ENIAC）就是这样的计算机，最初只能完成5000每秒的计算，耗电量在150千万每小时。程序的编程只能通过改变电路的链接方式来表示不同的算法，程序的运行与退出都需要人工的干预，这就是我们人类最初的计算机\n![](https://leanote.com/api/file/getImage?fileId=5ce16d88ab64414b37003427)\n\n## 单道批量处理计算机\n从第一代计算机开始大概经过了10年的发展，开始使用磁性存储设备，程序员在磁带上录入多批次的作业，交给计算机操作人员，放入计算机中批量载入计算机，计算机会一个一个计算并将结果输出到另外一个磁性设备。这一时期的操作系统就是单到批处理系统，内存红能主流移到用户作业，cup和内存资源被用户作业独占。程序是指令的集合，程序执行是cpu的依次、逐条执行指令的过程。相比于上一代计算机，减少了等待人工操作的时间，但是作业进行I/O时，CPU只能等待I/O完成而无事可做，cpu资源得不到充分利用\n\n## 多道批处理系统的特点\n为了解决上一代计算机的问题，有发展到了多道批处理系统。\n与单道批处理系统相比，躲到批处理系统支持多道程序驻留内存，cpu不在因为某个进程等待I/O而空闲，而是可以去执行其他进程。\n\n## 分时操作系统\n分时操作系统运行多个用户通过终端同时使用计算机。分时操作系统需要解决的两个关键问题是及时接收和及时处理。分时操作系统为例保证每个用户终端的相应时间，使所有的用户任务直接进入内存，并在很短的时间内快速切换让每个任务都运行一遍，达到多个用户任务并行处理的目的。\n\n## 实时操作系统\n实时操作系统主要用户实时控制和实时信息处理领域。与分时系统相比，它具有多路性、独立性、及时性、交互性、可靠性几个特点。\n实时系统比分时系统要求有更高的可靠性，必须能够在任务能够容忍的时间范围内处理完，否则可能带来巨大的经济损失设置生命安全。批处理系统、分时系统和实时系统是三种基本的草鞋系统类型，实时操作系统可能兼有三者货主其中两者的功能特征.\n\n#操作系统的五大功能\n## 内存管理\n内存管理主要是为多道程序运行提供良好的环境，方便用户使用内存，提高内存的利用率，已经从逻辑上扩充内存以实现虚拟存储。包括内存分配、内存保护、地址映射、内存扩充功能。\n### 内存分配\n内存分配可分为静态分配和动态分配，静态是指按程序所需分配固定大小后不再变化，动态分配是指在系统运行中，根据进程的骑牛分配内存大小，是可以在运行时变化的。\n为了实现内存分配，需要实现以下几个功能：\n1. 适用于内存分配的数据结构，包含内存的使用情况，内存的空闲区大小，空闲区的起始地址，未内存分配实现提供依据。\n2. 内存分配功能。系统安装一定的内存分配算法分配内存空间。\n3. 内存回收。系统需要回收被释放的内存空间。\n\n### 内存保护\n内存保护的任务：一是是操作系统内核的空间不会被用户随意访问，以保证系统的稳定安全。二是是没道用户程序都在自己的内存空间中运行，相对独立互不干扰。\n\n### 地址映射\ncpu执行程序的过程中，需要把程序的逻辑地址转变成物理地址，这个转换过程称为地址映射。\n\n逻辑地址：是指一个程序编译后，通常会形成若干个目标程序，这些程序再经过链接而形成可装载的程序。这些程序中的指令和数据的地址都是相对于编译链接后的机器代码程序的起始地址计算的。称之为逻辑地址。\n\n### 内存扩充\n为了满足程序的更大内存需求，就要为其从逻辑上扩充更大的内存，需要实现以下功能：\n1. 请求调入功能。运行系统在装入一部分用户程序是就启动该程序的运行，若在程序运行过程中发现要执行的指令货主要访问的数据没有载入内存，通过请求调入装入内存。\n2. 置换功能。在请求调入是，若发现内存空间不足，需要系统将内存中一部分内存换到外存中，以便腾出内存空间载入当前需要的内容。\n\n## 进程管理\n进程管理主要包括：经常的组织和描述、进程的控制、进程的同步、进程同学及进程调度。例如进程的创建、销毁、唤醒、阻塞等操作。\n\n## 设备管理\n设备管理主要完成用户的I/O请求，未用户分配I/O设备。为了完成这些任务，设备管理需要具备以下功能：\n1. 缓冲管理。\n2. 设备分配。分配用户I/O所需的设备。\n3. 设备处理。由设备驱动程序来实现cpu与设备控制之间的通讯。\n4. 设备独立性和虚拟设备。设备独立性功能是应用程序独立于物理设备。例如，用高级程序设计语言打印图形程序。\n\n\n## 文件管理\n文件存储空间的管理、文件目录的管理、文件读写\n\n## 提供用户接口\n为了方便用户使用操作系统，操作系统向用户提供命令行和图形用户接口，向程序员提供应用程序与操作系统之间的接口。\n\n# 操作系统的体系结构\n操作系统的体系结构是一个复杂软件系统的高层结构，未软件系统提供了一个结构、行为和属性的高级抽象，包括系统元素的结构、元素拣的相互关系，以及指导元素集成的模式和约束。\n\n## 简单的监控程序模型\n最初的计算机并不存在操作系统这个概念，所有的任务都是直接运行与硬件上，程序员直接操作硬件系统。随着控制语言的出现，产生了简单的监控程序，能够保证任意时刻系统只能运行一个任务，保证对系统信息的互斥访问。\n\n## 单体结构模型\n在单体结构模型中，多有的软件和数据结构防止在一个逻辑模块中，对外出的用户程序提供一个完成的内核界面——系统调用。整个系统有若干个功能独立的子程序组成，运行任意一子程序调用其他子程序，因此它的特点是结构简单，便于理解和实现，而且系统所有的部分都集中在一个内核中，效期较高，缺点也很明显，各个子程序之间可以相互调用，系统结构关系复杂，容易引起循环调用和死锁。\n\n## 层次结构模型\n层次结构的基本思想是讲操作系统分解为多个晓得容易理解的层，系统功能被隔离在不同的层中，每一层提供对系统功能的部分抽象。在操作系统的层次结构中，各个模块都有相对固定的位置、相对固定的层次。层与层之间有间隔的接口定义，每一次值依赖于它下层提供的服务而工作，不能夸层随意访问。不过出于效率的考虑，有些系统运行夸层乡下调用。\n\n## 客户/服务器模型与微内核结构\n它的核心思想是功能外迁，即吧传统操作系统内核中的一些组成部分（如文件系统、网络、驱动程序等内核功能）放到内核之外作为一个独立的服务进程来实现，在微内核中只保留了操作系统最基本的功能，包括处理器调度、存储管理和消息通道等。\n\n## 动态可扩展结构模型\n采用UPCALL和DOWNLOAD技术。它试图将所有的传统操作系统内核中提供的抽象转移到用户控件，以操作系统库的形式提供服务，内核层只负责对物理设备的控制。应用程序可以从用户层库中得到并控件内核抽象，从而实现了操作系统的动态扩展。\n\n# 指令的执行\n## 取指令和执行指令\n1. 取指令，在每个指令周期开会时，处理器从存储器中读取一条指令，在典型的固定长度指令处理器中，程序计数器（PC）保存有下一次要取的指令地址，每次取指令后都对PC作递增，使它能够按顺序读取吓一条指令，即位于下一个高端存储器地址的指令。\n2. 执行指令，取到指令被防止在处理器的指令寄存器IR中。指令中包含确定处理器将要采取动作的位，处理器解释指令并执行要求的动作，这些动作可分为4类：\n2.1 处理器与存储器之间的指令或数据传送操作。\n2.2 处理器与I/O设备质检的指令或数据传送操作\n2.3 算数运算操作或逻辑运算操作\n2.4 控制操作，即修改指令的执行顺序的操作。\n\n## 小结\n程序执行过程是反复取指令和执行指令的过程。PC使用存有下一条指令的地址。指令的执行结果就是使寄存器或内存单元的值发生变化，指令执行的过程也就是存储体内容不断变化的过程。取指令和执行指令是有硬件完成的，不同硬件的体系结构支持不同的指令集合，为某一种硬件平台开发的操作系统不能直接在另外一中体系结构的硬件上运行。","slug":"操作系统原理/操作系统原理——初识操作系统","published":1,"updated":"2022-08-25T09:13:01.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78ycziy001gvwm1qka5v5ji","content":"<h1 id=\"什么是操作系统\"><a href=\"#什么是操作系统\" class=\"headerlink\" title=\"什么是操作系统\"></a>什么是操作系统</h1><p>  操作系统是提供计算机用不与计算机硬件之间的使用接口，并能够管理计算机软件和硬件资源的一个复杂的系统软件，为用户的应用程序提供直接可用的运行环境，是应用程序的开发变得简单、高效。<br>  试想一下如果没有操作系统，你将怎样写代码？<br>  例如你要写一个实现<code>printf(&quot;hello world&quot;)</code>的功能，你要怎么实现呢？<br>  无操作系统的环境下，你只能使用汇编语言直接操作硬件接口</p>\n<pre><code>  xor ah,ah;//对ah、dl清零\n  xor dl,dl;//软驱复位\n  int13h;//BIOS功能调用int 13h中断\n  ... //此处省略n行代码\n  mov cl,ah;//其实扇区号送cl寄存器\n  mov dh,al;</code></pre><p>  可以看出一个简单的功能，要实现一大段的代码，并且没有的计算机资源做统一的管理，极大的降低程序运行的效率和开发效率。</p>\n<h1 id=\"操作系统的发展历史\"><a href=\"#操作系统的发展历史\" class=\"headerlink\" title=\"操作系统的发展历史\"></a>操作系统的发展历史</h1><h2 id=\"无操作系统时代\"><a href=\"#无操作系统时代\" class=\"headerlink\" title=\"无操作系统时代\"></a>无操作系统时代</h2><p>第一代计算机（1945~1955年）使用电子管作为主要电子器件，用插件版的链接先或穿孔片表示程序，没有用来存储程序的内存，无操作系统的。<br>我们熟知的那个庞然大物——人类第一台计算机”艾尼阿克”（ENIAC）就是这样的计算机，最初只能完成5000每秒的计算，耗电量在150千万每小时。程序的编程只能通过改变电路的链接方式来表示不同的算法，程序的运行与退出都需要人工的干预，这就是我们人类最初的计算机<br><img src=\"https://leanote.com/api/file/getImage?fileId=5ce16d88ab64414b37003427\" alt></p>\n<h2 id=\"单道批量处理计算机\"><a href=\"#单道批量处理计算机\" class=\"headerlink\" title=\"单道批量处理计算机\"></a>单道批量处理计算机</h2><p>从第一代计算机开始大概经过了10年的发展，开始使用磁性存储设备，程序员在磁带上录入多批次的作业，交给计算机操作人员，放入计算机中批量载入计算机，计算机会一个一个计算并将结果输出到另外一个磁性设备。这一时期的操作系统就是单到批处理系统，内存红能主流移到用户作业，cup和内存资源被用户作业独占。程序是指令的集合，程序执行是cpu的依次、逐条执行指令的过程。相比于上一代计算机，减少了等待人工操作的时间，但是作业进行I/O时，CPU只能等待I/O完成而无事可做，cpu资源得不到充分利用</p>\n<h2 id=\"多道批处理系统的特点\"><a href=\"#多道批处理系统的特点\" class=\"headerlink\" title=\"多道批处理系统的特点\"></a>多道批处理系统的特点</h2><p>为了解决上一代计算机的问题，有发展到了多道批处理系统。<br>与单道批处理系统相比，躲到批处理系统支持多道程序驻留内存，cpu不在因为某个进程等待I/O而空闲，而是可以去执行其他进程。</p>\n<h2 id=\"分时操作系统\"><a href=\"#分时操作系统\" class=\"headerlink\" title=\"分时操作系统\"></a>分时操作系统</h2><p>分时操作系统运行多个用户通过终端同时使用计算机。分时操作系统需要解决的两个关键问题是及时接收和及时处理。分时操作系统为例保证每个用户终端的相应时间，使所有的用户任务直接进入内存，并在很短的时间内快速切换让每个任务都运行一遍，达到多个用户任务并行处理的目的。</p>\n<h2 id=\"实时操作系统\"><a href=\"#实时操作系统\" class=\"headerlink\" title=\"实时操作系统\"></a>实时操作系统</h2><p>实时操作系统主要用户实时控制和实时信息处理领域。与分时系统相比，它具有多路性、独立性、及时性、交互性、可靠性几个特点。<br>实时系统比分时系统要求有更高的可靠性，必须能够在任务能够容忍的时间范围内处理完，否则可能带来巨大的经济损失设置生命安全。批处理系统、分时系统和实时系统是三种基本的草鞋系统类型，实时操作系统可能兼有三者货主其中两者的功能特征.</p>\n<p>#操作系统的五大功能</p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><p>内存管理主要是为多道程序运行提供良好的环境，方便用户使用内存，提高内存的利用率，已经从逻辑上扩充内存以实现虚拟存储。包括内存分配、内存保护、地址映射、内存扩充功能。</p>\n<h3 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h3><p>内存分配可分为静态分配和动态分配，静态是指按程序所需分配固定大小后不再变化，动态分配是指在系统运行中，根据进程的骑牛分配内存大小，是可以在运行时变化的。<br>为了实现内存分配，需要实现以下几个功能：</p>\n<ol>\n<li>适用于内存分配的数据结构，包含内存的使用情况，内存的空闲区大小，空闲区的起始地址，未内存分配实现提供依据。</li>\n<li>内存分配功能。系统安装一定的内存分配算法分配内存空间。</li>\n<li>内存回收。系统需要回收被释放的内存空间。</li>\n</ol>\n<h3 id=\"内存保护\"><a href=\"#内存保护\" class=\"headerlink\" title=\"内存保护\"></a>内存保护</h3><p>内存保护的任务：一是是操作系统内核的空间不会被用户随意访问，以保证系统的稳定安全。二是是没道用户程序都在自己的内存空间中运行，相对独立互不干扰。</p>\n<h3 id=\"地址映射\"><a href=\"#地址映射\" class=\"headerlink\" title=\"地址映射\"></a>地址映射</h3><p>cpu执行程序的过程中，需要把程序的逻辑地址转变成物理地址，这个转换过程称为地址映射。</p>\n<p>逻辑地址：是指一个程序编译后，通常会形成若干个目标程序，这些程序再经过链接而形成可装载的程序。这些程序中的指令和数据的地址都是相对于编译链接后的机器代码程序的起始地址计算的。称之为逻辑地址。</p>\n<h3 id=\"内存扩充\"><a href=\"#内存扩充\" class=\"headerlink\" title=\"内存扩充\"></a>内存扩充</h3><p>为了满足程序的更大内存需求，就要为其从逻辑上扩充更大的内存，需要实现以下功能：</p>\n<ol>\n<li>请求调入功能。运行系统在装入一部分用户程序是就启动该程序的运行，若在程序运行过程中发现要执行的指令货主要访问的数据没有载入内存，通过请求调入装入内存。</li>\n<li>置换功能。在请求调入是，若发现内存空间不足，需要系统将内存中一部分内存换到外存中，以便腾出内存空间载入当前需要的内容。</li>\n</ol>\n<h2 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h2><p>进程管理主要包括：经常的组织和描述、进程的控制、进程的同步、进程同学及进程调度。例如进程的创建、销毁、唤醒、阻塞等操作。</p>\n<h2 id=\"设备管理\"><a href=\"#设备管理\" class=\"headerlink\" title=\"设备管理\"></a>设备管理</h2><p>设备管理主要完成用户的I/O请求，未用户分配I/O设备。为了完成这些任务，设备管理需要具备以下功能：</p>\n<ol>\n<li>缓冲管理。</li>\n<li>设备分配。分配用户I/O所需的设备。</li>\n<li>设备处理。由设备驱动程序来实现cpu与设备控制之间的通讯。</li>\n<li>设备独立性和虚拟设备。设备独立性功能是应用程序独立于物理设备。例如，用高级程序设计语言打印图形程序。</li>\n</ol>\n<h2 id=\"文件管理\"><a href=\"#文件管理\" class=\"headerlink\" title=\"文件管理\"></a>文件管理</h2><p>文件存储空间的管理、文件目录的管理、文件读写</p>\n<h2 id=\"提供用户接口\"><a href=\"#提供用户接口\" class=\"headerlink\" title=\"提供用户接口\"></a>提供用户接口</h2><p>为了方便用户使用操作系统，操作系统向用户提供命令行和图形用户接口，向程序员提供应用程序与操作系统之间的接口。</p>\n<h1 id=\"操作系统的体系结构\"><a href=\"#操作系统的体系结构\" class=\"headerlink\" title=\"操作系统的体系结构\"></a>操作系统的体系结构</h1><p>操作系统的体系结构是一个复杂软件系统的高层结构，未软件系统提供了一个结构、行为和属性的高级抽象，包括系统元素的结构、元素拣的相互关系，以及指导元素集成的模式和约束。</p>\n<h2 id=\"简单的监控程序模型\"><a href=\"#简单的监控程序模型\" class=\"headerlink\" title=\"简单的监控程序模型\"></a>简单的监控程序模型</h2><p>最初的计算机并不存在操作系统这个概念，所有的任务都是直接运行与硬件上，程序员直接操作硬件系统。随着控制语言的出现，产生了简单的监控程序，能够保证任意时刻系统只能运行一个任务，保证对系统信息的互斥访问。</p>\n<h2 id=\"单体结构模型\"><a href=\"#单体结构模型\" class=\"headerlink\" title=\"单体结构模型\"></a>单体结构模型</h2><p>在单体结构模型中，多有的软件和数据结构防止在一个逻辑模块中，对外出的用户程序提供一个完成的内核界面——系统调用。整个系统有若干个功能独立的子程序组成，运行任意一子程序调用其他子程序，因此它的特点是结构简单，便于理解和实现，而且系统所有的部分都集中在一个内核中，效期较高，缺点也很明显，各个子程序之间可以相互调用，系统结构关系复杂，容易引起循环调用和死锁。</p>\n<h2 id=\"层次结构模型\"><a href=\"#层次结构模型\" class=\"headerlink\" title=\"层次结构模型\"></a>层次结构模型</h2><p>层次结构的基本思想是讲操作系统分解为多个晓得容易理解的层，系统功能被隔离在不同的层中，每一层提供对系统功能的部分抽象。在操作系统的层次结构中，各个模块都有相对固定的位置、相对固定的层次。层与层之间有间隔的接口定义，每一次值依赖于它下层提供的服务而工作，不能夸层随意访问。不过出于效率的考虑，有些系统运行夸层乡下调用。</p>\n<h2 id=\"客户-服务器模型与微内核结构\"><a href=\"#客户-服务器模型与微内核结构\" class=\"headerlink\" title=\"客户/服务器模型与微内核结构\"></a>客户/服务器模型与微内核结构</h2><p>它的核心思想是功能外迁，即吧传统操作系统内核中的一些组成部分（如文件系统、网络、驱动程序等内核功能）放到内核之外作为一个独立的服务进程来实现，在微内核中只保留了操作系统最基本的功能，包括处理器调度、存储管理和消息通道等。</p>\n<h2 id=\"动态可扩展结构模型\"><a href=\"#动态可扩展结构模型\" class=\"headerlink\" title=\"动态可扩展结构模型\"></a>动态可扩展结构模型</h2><p>采用UPCALL和DOWNLOAD技术。它试图将所有的传统操作系统内核中提供的抽象转移到用户控件，以操作系统库的形式提供服务，内核层只负责对物理设备的控制。应用程序可以从用户层库中得到并控件内核抽象，从而实现了操作系统的动态扩展。</p>\n<h1 id=\"指令的执行\"><a href=\"#指令的执行\" class=\"headerlink\" title=\"指令的执行\"></a>指令的执行</h1><h2 id=\"取指令和执行指令\"><a href=\"#取指令和执行指令\" class=\"headerlink\" title=\"取指令和执行指令\"></a>取指令和执行指令</h2><ol>\n<li>取指令，在每个指令周期开会时，处理器从存储器中读取一条指令，在典型的固定长度指令处理器中，程序计数器（PC）保存有下一次要取的指令地址，每次取指令后都对PC作递增，使它能够按顺序读取吓一条指令，即位于下一个高端存储器地址的指令。</li>\n<li>执行指令，取到指令被防止在处理器的指令寄存器IR中。指令中包含确定处理器将要采取动作的位，处理器解释指令并执行要求的动作，这些动作可分为4类：</li>\n<li>1 处理器与存储器之间的指令或数据传送操作。</li>\n<li>2 处理器与I/O设备质检的指令或数据传送操作</li>\n<li>3 算数运算操作或逻辑运算操作</li>\n<li>4 控制操作，即修改指令的执行顺序的操作。</li>\n</ol>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>程序执行过程是反复取指令和执行指令的过程。PC使用存有下一条指令的地址。指令的执行结果就是使寄存器或内存单元的值发生变化，指令执行的过程也就是存储体内容不断变化的过程。取指令和执行指令是有硬件完成的，不同硬件的体系结构支持不同的指令集合，为某一种硬件平台开发的操作系统不能直接在另外一中体系结构的硬件上运行。</p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"什么是操作系统\"><a href=\"#什么是操作系统\" class=\"headerlink\" title=\"什么是操作系统\"></a>什么是操作系统</h1><p>  操作系统是提供计算机用不与计算机硬件之间的使用接口，并能够管理计算机软件和硬件资源的一个复杂的系统软件，为用户的应用程序提供直接可用的运行环境，是应用程序的开发变得简单、高效。<br>  试想一下如果没有操作系统，你将怎样写代码？<br>  例如你要写一个实现<code>printf(&quot;hello world&quot;)</code>的功能，你要怎么实现呢？<br>  无操作系统的环境下，你只能使用汇编语言直接操作硬件接口</p>\n<pre><code>  xor ah,ah;//对ah、dl清零\n  xor dl,dl;//软驱复位\n  int13h;//BIOS功能调用int 13h中断\n  ... //此处省略n行代码\n  mov cl,ah;//其实扇区号送cl寄存器\n  mov dh,al;</code></pre><p>  可以看出一个简单的功能，要实现一大段的代码，并且没有的计算机资源做统一的管理，极大的降低程序运行的效率和开发效率。</p>\n<h1 id=\"操作系统的发展历史\"><a href=\"#操作系统的发展历史\" class=\"headerlink\" title=\"操作系统的发展历史\"></a>操作系统的发展历史</h1><h2 id=\"无操作系统时代\"><a href=\"#无操作系统时代\" class=\"headerlink\" title=\"无操作系统时代\"></a>无操作系统时代</h2><p>第一代计算机（1945~1955年）使用电子管作为主要电子器件，用插件版的链接先或穿孔片表示程序，没有用来存储程序的内存，无操作系统的。<br>我们熟知的那个庞然大物——人类第一台计算机”艾尼阿克”（ENIAC）就是这样的计算机，最初只能完成5000每秒的计算，耗电量在150千万每小时。程序的编程只能通过改变电路的链接方式来表示不同的算法，程序的运行与退出都需要人工的干预，这就是我们人类最初的计算机<br><img src=\"https://leanote.com/api/file/getImage?fileId=5ce16d88ab64414b37003427\" alt></p>\n<h2 id=\"单道批量处理计算机\"><a href=\"#单道批量处理计算机\" class=\"headerlink\" title=\"单道批量处理计算机\"></a>单道批量处理计算机</h2><p>从第一代计算机开始大概经过了10年的发展，开始使用磁性存储设备，程序员在磁带上录入多批次的作业，交给计算机操作人员，放入计算机中批量载入计算机，计算机会一个一个计算并将结果输出到另外一个磁性设备。这一时期的操作系统就是单到批处理系统，内存红能主流移到用户作业，cup和内存资源被用户作业独占。程序是指令的集合，程序执行是cpu的依次、逐条执行指令的过程。相比于上一代计算机，减少了等待人工操作的时间，但是作业进行I/O时，CPU只能等待I/O完成而无事可做，cpu资源得不到充分利用</p>\n<h2 id=\"多道批处理系统的特点\"><a href=\"#多道批处理系统的特点\" class=\"headerlink\" title=\"多道批处理系统的特点\"></a>多道批处理系统的特点</h2><p>为了解决上一代计算机的问题，有发展到了多道批处理系统。<br>与单道批处理系统相比，躲到批处理系统支持多道程序驻留内存，cpu不在因为某个进程等待I/O而空闲，而是可以去执行其他进程。</p>\n<h2 id=\"分时操作系统\"><a href=\"#分时操作系统\" class=\"headerlink\" title=\"分时操作系统\"></a>分时操作系统</h2><p>分时操作系统运行多个用户通过终端同时使用计算机。分时操作系统需要解决的两个关键问题是及时接收和及时处理。分时操作系统为例保证每个用户终端的相应时间，使所有的用户任务直接进入内存，并在很短的时间内快速切换让每个任务都运行一遍，达到多个用户任务并行处理的目的。</p>\n<h2 id=\"实时操作系统\"><a href=\"#实时操作系统\" class=\"headerlink\" title=\"实时操作系统\"></a>实时操作系统</h2><p>实时操作系统主要用户实时控制和实时信息处理领域。与分时系统相比，它具有多路性、独立性、及时性、交互性、可靠性几个特点。<br>实时系统比分时系统要求有更高的可靠性，必须能够在任务能够容忍的时间范围内处理完，否则可能带来巨大的经济损失设置生命安全。批处理系统、分时系统和实时系统是三种基本的草鞋系统类型，实时操作系统可能兼有三者货主其中两者的功能特征.</p>\n<p>#操作系统的五大功能</p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><p>内存管理主要是为多道程序运行提供良好的环境，方便用户使用内存，提高内存的利用率，已经从逻辑上扩充内存以实现虚拟存储。包括内存分配、内存保护、地址映射、内存扩充功能。</p>\n<h3 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h3><p>内存分配可分为静态分配和动态分配，静态是指按程序所需分配固定大小后不再变化，动态分配是指在系统运行中，根据进程的骑牛分配内存大小，是可以在运行时变化的。<br>为了实现内存分配，需要实现以下几个功能：</p>\n<ol>\n<li>适用于内存分配的数据结构，包含内存的使用情况，内存的空闲区大小，空闲区的起始地址，未内存分配实现提供依据。</li>\n<li>内存分配功能。系统安装一定的内存分配算法分配内存空间。</li>\n<li>内存回收。系统需要回收被释放的内存空间。</li>\n</ol>\n<h3 id=\"内存保护\"><a href=\"#内存保护\" class=\"headerlink\" title=\"内存保护\"></a>内存保护</h3><p>内存保护的任务：一是是操作系统内核的空间不会被用户随意访问，以保证系统的稳定安全。二是是没道用户程序都在自己的内存空间中运行，相对独立互不干扰。</p>\n<h3 id=\"地址映射\"><a href=\"#地址映射\" class=\"headerlink\" title=\"地址映射\"></a>地址映射</h3><p>cpu执行程序的过程中，需要把程序的逻辑地址转变成物理地址，这个转换过程称为地址映射。</p>\n<p>逻辑地址：是指一个程序编译后，通常会形成若干个目标程序，这些程序再经过链接而形成可装载的程序。这些程序中的指令和数据的地址都是相对于编译链接后的机器代码程序的起始地址计算的。称之为逻辑地址。</p>\n<h3 id=\"内存扩充\"><a href=\"#内存扩充\" class=\"headerlink\" title=\"内存扩充\"></a>内存扩充</h3><p>为了满足程序的更大内存需求，就要为其从逻辑上扩充更大的内存，需要实现以下功能：</p>\n<ol>\n<li>请求调入功能。运行系统在装入一部分用户程序是就启动该程序的运行，若在程序运行过程中发现要执行的指令货主要访问的数据没有载入内存，通过请求调入装入内存。</li>\n<li>置换功能。在请求调入是，若发现内存空间不足，需要系统将内存中一部分内存换到外存中，以便腾出内存空间载入当前需要的内容。</li>\n</ol>\n<h2 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h2><p>进程管理主要包括：经常的组织和描述、进程的控制、进程的同步、进程同学及进程调度。例如进程的创建、销毁、唤醒、阻塞等操作。</p>\n<h2 id=\"设备管理\"><a href=\"#设备管理\" class=\"headerlink\" title=\"设备管理\"></a>设备管理</h2><p>设备管理主要完成用户的I/O请求，未用户分配I/O设备。为了完成这些任务，设备管理需要具备以下功能：</p>\n<ol>\n<li>缓冲管理。</li>\n<li>设备分配。分配用户I/O所需的设备。</li>\n<li>设备处理。由设备驱动程序来实现cpu与设备控制之间的通讯。</li>\n<li>设备独立性和虚拟设备。设备独立性功能是应用程序独立于物理设备。例如，用高级程序设计语言打印图形程序。</li>\n</ol>\n<h2 id=\"文件管理\"><a href=\"#文件管理\" class=\"headerlink\" title=\"文件管理\"></a>文件管理</h2><p>文件存储空间的管理、文件目录的管理、文件读写</p>\n<h2 id=\"提供用户接口\"><a href=\"#提供用户接口\" class=\"headerlink\" title=\"提供用户接口\"></a>提供用户接口</h2><p>为了方便用户使用操作系统，操作系统向用户提供命令行和图形用户接口，向程序员提供应用程序与操作系统之间的接口。</p>\n<h1 id=\"操作系统的体系结构\"><a href=\"#操作系统的体系结构\" class=\"headerlink\" title=\"操作系统的体系结构\"></a>操作系统的体系结构</h1><p>操作系统的体系结构是一个复杂软件系统的高层结构，未软件系统提供了一个结构、行为和属性的高级抽象，包括系统元素的结构、元素拣的相互关系，以及指导元素集成的模式和约束。</p>\n<h2 id=\"简单的监控程序模型\"><a href=\"#简单的监控程序模型\" class=\"headerlink\" title=\"简单的监控程序模型\"></a>简单的监控程序模型</h2><p>最初的计算机并不存在操作系统这个概念，所有的任务都是直接运行与硬件上，程序员直接操作硬件系统。随着控制语言的出现，产生了简单的监控程序，能够保证任意时刻系统只能运行一个任务，保证对系统信息的互斥访问。</p>\n<h2 id=\"单体结构模型\"><a href=\"#单体结构模型\" class=\"headerlink\" title=\"单体结构模型\"></a>单体结构模型</h2><p>在单体结构模型中，多有的软件和数据结构防止在一个逻辑模块中，对外出的用户程序提供一个完成的内核界面——系统调用。整个系统有若干个功能独立的子程序组成，运行任意一子程序调用其他子程序，因此它的特点是结构简单，便于理解和实现，而且系统所有的部分都集中在一个内核中，效期较高，缺点也很明显，各个子程序之间可以相互调用，系统结构关系复杂，容易引起循环调用和死锁。</p>\n<h2 id=\"层次结构模型\"><a href=\"#层次结构模型\" class=\"headerlink\" title=\"层次结构模型\"></a>层次结构模型</h2><p>层次结构的基本思想是讲操作系统分解为多个晓得容易理解的层，系统功能被隔离在不同的层中，每一层提供对系统功能的部分抽象。在操作系统的层次结构中，各个模块都有相对固定的位置、相对固定的层次。层与层之间有间隔的接口定义，每一次值依赖于它下层提供的服务而工作，不能夸层随意访问。不过出于效率的考虑，有些系统运行夸层乡下调用。</p>\n<h2 id=\"客户-服务器模型与微内核结构\"><a href=\"#客户-服务器模型与微内核结构\" class=\"headerlink\" title=\"客户/服务器模型与微内核结构\"></a>客户/服务器模型与微内核结构</h2><p>它的核心思想是功能外迁，即吧传统操作系统内核中的一些组成部分（如文件系统、网络、驱动程序等内核功能）放到内核之外作为一个独立的服务进程来实现，在微内核中只保留了操作系统最基本的功能，包括处理器调度、存储管理和消息通道等。</p>\n<h2 id=\"动态可扩展结构模型\"><a href=\"#动态可扩展结构模型\" class=\"headerlink\" title=\"动态可扩展结构模型\"></a>动态可扩展结构模型</h2><p>采用UPCALL和DOWNLOAD技术。它试图将所有的传统操作系统内核中提供的抽象转移到用户控件，以操作系统库的形式提供服务，内核层只负责对物理设备的控制。应用程序可以从用户层库中得到并控件内核抽象，从而实现了操作系统的动态扩展。</p>\n<h1 id=\"指令的执行\"><a href=\"#指令的执行\" class=\"headerlink\" title=\"指令的执行\"></a>指令的执行</h1><h2 id=\"取指令和执行指令\"><a href=\"#取指令和执行指令\" class=\"headerlink\" title=\"取指令和执行指令\"></a>取指令和执行指令</h2><ol>\n<li>取指令，在每个指令周期开会时，处理器从存储器中读取一条指令，在典型的固定长度指令处理器中，程序计数器（PC）保存有下一次要取的指令地址，每次取指令后都对PC作递增，使它能够按顺序读取吓一条指令，即位于下一个高端存储器地址的指令。</li>\n<li>执行指令，取到指令被防止在处理器的指令寄存器IR中。指令中包含确定处理器将要采取动作的位，处理器解释指令并执行要求的动作，这些动作可分为4类：</li>\n<li>1 处理器与存储器之间的指令或数据传送操作。</li>\n<li>2 处理器与I/O设备质检的指令或数据传送操作</li>\n<li>3 算数运算操作或逻辑运算操作</li>\n<li>4 控制操作，即修改指令的执行顺序的操作。</li>\n</ol>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>程序执行过程是反复取指令和执行指令的过程。PC使用存有下一条指令的地址。指令的执行结果就是使寄存器或内存单元的值发生变化，指令执行的过程也就是存储体内容不断变化的过程。取指令和执行指令是有硬件完成的，不同硬件的体系结构支持不同的指令集合，为某一种硬件平台开发的操作系统不能直接在另外一中体系结构的硬件上运行。</p>\n"},{"_content":"# 前言\n在大流量场景，秒杀、抢购场景，一般会对网站做一些流量控制，牺牲一部分流量而保护系统而不至于系统直接down机。\n\n# 常见限流算法\n## 固定计算限流\n就是统计固定时间内的流量数量，如果超过了就限制。这种很容易实现，利用AutomicLong统计，下一个统计周期后又清零重新计算。\n这样会有以下问题：\n1. 1s之内的前100ms就已经达到了,那么后900ms就是空闲的。\n2. 如果1s之内的后100ms和下一秒的前100ms,那么在这个前后1s内加起来的流量是限流的两倍，显然这没有达到“在任意1s内流量不超过限制”的控制，很多黑客利用这个缺陷攻击网站，从而拖垮服务器。\n![](../images/限流相关/getImage-20220825184239907.png)\n\n## 滑动窗口\n为了解决“计数限流”的缺陷，我们引入“滑动窗口”的计数方法。就是在计数限流的基础之上，将1个限流时间周期内切分成更小的单位计数，使得限制流量更加均分。\n具体做法如下：\n1. 将1s钟切成更细粒度200ms为计数单位，将请求时间点按取模的方式计算落到对应的计数格中，然后判断从当前计数格往前推1s(也就是5个计数格)的统计数总和当成当前流量的计数，如果超过阈值则限流，否则放行\n![](../images/限流相关/getImage-20220825184239739-1424159.png)\n2. 随着请求时间的推进，计数窗口也会随之往前移动\n![](../images/限流相关/getImage-20220825184239638.png)\n3. 这样的好处是，优化了“固定计数法”的缺陷，即在任意时刻，都将都以更小粒度的计数方法往前累加计算，防止在单位时间内流量超过限额。如图：\n![](../images/限流相关/getImage-20220825184239708.png)\n\n## 漏桶算法\n漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会时，有一定的缓冲能力，超过最大缓冲时将直接拒绝。这个算法的特点就是，不管桶里面是空还是满，都以均匀的速度放行。下面是从网上找的图：\n![](../images/限流相关/getImage-20220825184239739.png)\n\n\n## 令牌桶算法\n令牌桶算法（Token Bucket）：是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。令牌桶算法示意图如下所示：\n![](../images/限流相关/getImage-20220825184239758.png)\n\n令牌桶算法与漏桶算法的区别在于如果在一段时间内都没有流量，而桶中的令牌数有随着时间流逝匀速增加，那么桶中将会缓冲一定数量的令牌，即使后面流量突然增加超过了限额，也会由于还有可用的令牌直接放行，无需要等待。\n\n# 限流实现\n## Guava的RateLimiter实现\n在Guava的工具包中，`RateLimiter`就是居于`令牌桶算法`实现的内存限流。\n其构造有如下几个：\n```\n //构造方法1\n  @VisibleForTesting\n  static RateLimiter create(SleepingTicker ticker, double permitsPerSecond) {\n    //实现类是Bursty\n    RateLimiter rateLimiter = new Bursty(ticker, 1.0 /* maxBurstSeconds */);\n    //根据permitsPerSecond每秒令牌数计算，每个令牌产生的毫秒数\n    rateLimiter.setRate(permitsPerSecond);\n    return rateLimiter;\n  }\n  \n  //构造方法2\n static RateLimiter create(\n      SleepingTicker ticker, double permitsPerSecond, long warmupPeriod, TimeUnit unit) {\n    //实现类是一个平滑预热限流，就是如果流量突然暴增，即使有足够的令牌，也不会一下子全部放下，会加一些线性等待时间平滑过渡\n    RateLimiter rateLimiter = new WarmingUp(ticker, warmupPeriod, unit);\n    rateLimiter.setRate(permitsPerSecond);\n    return rateLimiter;\n  }\n  \n```\n\n获取令牌\n```\n  public double acquire(int permits) {\n    checkPermits(permits);\n    long microsToWait;\n    //获取全局锁\n    synchronized (mutex) {\n        //根据当前时间算出还需要等待的时间\n        microsToWait = reserveNextTicket(permits, readSafeMicros());\n    }\n    ticker.sleepMicrosUninterruptibly(microsToWait);\n    return 1.0 * microsToWait / TimeUnit.SECONDS.toMicros(1L);\n  }\n```\n\n下面是令牌桶算法的核心\n```\n  private long reserveNextTicket(double requiredPermits, long nowMicros) {\n    //根据当前时间算出可用令牌数及要出来这么多令牌的时间点\n    resync(nowMicros);\n    //看下还需要等多久\n    long microsToNextFreeTicket = nextFreeTicketMicros - nowMicros;\n    //看下当前要立即花费多少令牌\n    double storedPermitsToSpend = Math.min(requiredPermits, this.storedPermits);\n    //还剩多少令牌需要等待\n    double freshPermits = requiredPermits - storedPermitsToSpend;\n\n    //根据不同的实现，Bursty或者WarmingUp，返回额外需要等待的时间\n    long waitMicros = storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend)\n        + (long) (freshPermits * stableIntervalMicros);\n\n    //重置获取这么多令牌要等到啥时候\n    this.nextFreeTicketMicros = nextFreeTicketMicros + waitMicros;\n    //更新下还剩多少可用令牌\n    this.storedPermits -= storedPermitsToSpend;\n    //返回还需要等待的时间\n    return microsToNextFreeTicket;\n  }\n```\n可以看到这个实现，并不是根据算法图一个生产者不断的往一个数组中添加令牌，一个消费者不断的取令牌，而是以时间线的方式，计算出当前获取令牌需要花费的时间及算出当前时间以设定的速度能够无产生多少令牌的方式实时计算的，简单并且没有额外的轮询操作，非常高效节省资源。\n\n\n## 使用Semphore进行并发流控\n`Semphore` 是JUC里面的并发信号量实现，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。很适合多线程情况对有限资源的抢占控制。\n\n\n## Netflix Hystrix 熔断限流\nSpring Clound里的Hystrix能否实现根据一定的访问异常设置，对应用做到降级限流的的控制\n\n## 阿里的Sentinel实现\nSentinel 是阿里中间件团队开源的，面向分布式服务架构的轻量级高可用流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性。\nGITHUB:https://github.com/alibaba/Sentinel\n其官方文档中也提到，其受到Guava RateLmiter的启发。\n\n大家可能会问：Sentinel 和上面提到的Netflix Hystrix 有什么异同呢？\n其官方文档有专门的说明：\nhttps://github.com/alibaba/Sentinel/wiki/Sentinel-%E4%B8%8E-Hystrix-%E7%9A%84%E5%AF%B9%E6%AF%94\n\n\n## 其他实现\n进行限流控制还可以有很多种方法，针对不同的场景各有优劣，例如通过AtomicLong计数器控制、Redis计数，使用MQ消息队列进行流量消峰等等都是可以的。\n\n# 总结\n流量控制在高并发场景是一个对系统保护必不可少的一个手段，能够牺牲一部分流量而保护整个应用的可用性，不止于发生雪崩情况。","source":"_posts/后端&架构/限流相关.md","raw":"# 前言\n在大流量场景，秒杀、抢购场景，一般会对网站做一些流量控制，牺牲一部分流量而保护系统而不至于系统直接down机。\n\n# 常见限流算法\n## 固定计算限流\n就是统计固定时间内的流量数量，如果超过了就限制。这种很容易实现，利用AutomicLong统计，下一个统计周期后又清零重新计算。\n这样会有以下问题：\n1. 1s之内的前100ms就已经达到了,那么后900ms就是空闲的。\n2. 如果1s之内的后100ms和下一秒的前100ms,那么在这个前后1s内加起来的流量是限流的两倍，显然这没有达到“在任意1s内流量不超过限制”的控制，很多黑客利用这个缺陷攻击网站，从而拖垮服务器。\n![](../images/限流相关/getImage-20220825184239907.png)\n\n## 滑动窗口\n为了解决“计数限流”的缺陷，我们引入“滑动窗口”的计数方法。就是在计数限流的基础之上，将1个限流时间周期内切分成更小的单位计数，使得限制流量更加均分。\n具体做法如下：\n1. 将1s钟切成更细粒度200ms为计数单位，将请求时间点按取模的方式计算落到对应的计数格中，然后判断从当前计数格往前推1s(也就是5个计数格)的统计数总和当成当前流量的计数，如果超过阈值则限流，否则放行\n![](../images/限流相关/getImage-20220825184239739-1424159.png)\n2. 随着请求时间的推进，计数窗口也会随之往前移动\n![](../images/限流相关/getImage-20220825184239638.png)\n3. 这样的好处是，优化了“固定计数法”的缺陷，即在任意时刻，都将都以更小粒度的计数方法往前累加计算，防止在单位时间内流量超过限额。如图：\n![](../images/限流相关/getImage-20220825184239708.png)\n\n## 漏桶算法\n漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会时，有一定的缓冲能力，超过最大缓冲时将直接拒绝。这个算法的特点就是，不管桶里面是空还是满，都以均匀的速度放行。下面是从网上找的图：\n![](../images/限流相关/getImage-20220825184239739.png)\n\n\n## 令牌桶算法\n令牌桶算法（Token Bucket）：是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。令牌桶算法示意图如下所示：\n![](../images/限流相关/getImage-20220825184239758.png)\n\n令牌桶算法与漏桶算法的区别在于如果在一段时间内都没有流量，而桶中的令牌数有随着时间流逝匀速增加，那么桶中将会缓冲一定数量的令牌，即使后面流量突然增加超过了限额，也会由于还有可用的令牌直接放行，无需要等待。\n\n# 限流实现\n## Guava的RateLimiter实现\n在Guava的工具包中，`RateLimiter`就是居于`令牌桶算法`实现的内存限流。\n其构造有如下几个：\n```\n //构造方法1\n  @VisibleForTesting\n  static RateLimiter create(SleepingTicker ticker, double permitsPerSecond) {\n    //实现类是Bursty\n    RateLimiter rateLimiter = new Bursty(ticker, 1.0 /* maxBurstSeconds */);\n    //根据permitsPerSecond每秒令牌数计算，每个令牌产生的毫秒数\n    rateLimiter.setRate(permitsPerSecond);\n    return rateLimiter;\n  }\n  \n  //构造方法2\n static RateLimiter create(\n      SleepingTicker ticker, double permitsPerSecond, long warmupPeriod, TimeUnit unit) {\n    //实现类是一个平滑预热限流，就是如果流量突然暴增，即使有足够的令牌，也不会一下子全部放下，会加一些线性等待时间平滑过渡\n    RateLimiter rateLimiter = new WarmingUp(ticker, warmupPeriod, unit);\n    rateLimiter.setRate(permitsPerSecond);\n    return rateLimiter;\n  }\n  \n```\n\n获取令牌\n```\n  public double acquire(int permits) {\n    checkPermits(permits);\n    long microsToWait;\n    //获取全局锁\n    synchronized (mutex) {\n        //根据当前时间算出还需要等待的时间\n        microsToWait = reserveNextTicket(permits, readSafeMicros());\n    }\n    ticker.sleepMicrosUninterruptibly(microsToWait);\n    return 1.0 * microsToWait / TimeUnit.SECONDS.toMicros(1L);\n  }\n```\n\n下面是令牌桶算法的核心\n```\n  private long reserveNextTicket(double requiredPermits, long nowMicros) {\n    //根据当前时间算出可用令牌数及要出来这么多令牌的时间点\n    resync(nowMicros);\n    //看下还需要等多久\n    long microsToNextFreeTicket = nextFreeTicketMicros - nowMicros;\n    //看下当前要立即花费多少令牌\n    double storedPermitsToSpend = Math.min(requiredPermits, this.storedPermits);\n    //还剩多少令牌需要等待\n    double freshPermits = requiredPermits - storedPermitsToSpend;\n\n    //根据不同的实现，Bursty或者WarmingUp，返回额外需要等待的时间\n    long waitMicros = storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend)\n        + (long) (freshPermits * stableIntervalMicros);\n\n    //重置获取这么多令牌要等到啥时候\n    this.nextFreeTicketMicros = nextFreeTicketMicros + waitMicros;\n    //更新下还剩多少可用令牌\n    this.storedPermits -= storedPermitsToSpend;\n    //返回还需要等待的时间\n    return microsToNextFreeTicket;\n  }\n```\n可以看到这个实现，并不是根据算法图一个生产者不断的往一个数组中添加令牌，一个消费者不断的取令牌，而是以时间线的方式，计算出当前获取令牌需要花费的时间及算出当前时间以设定的速度能够无产生多少令牌的方式实时计算的，简单并且没有额外的轮询操作，非常高效节省资源。\n\n\n## 使用Semphore进行并发流控\n`Semphore` 是JUC里面的并发信号量实现，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。很适合多线程情况对有限资源的抢占控制。\n\n\n## Netflix Hystrix 熔断限流\nSpring Clound里的Hystrix能否实现根据一定的访问异常设置，对应用做到降级限流的的控制\n\n## 阿里的Sentinel实现\nSentinel 是阿里中间件团队开源的，面向分布式服务架构的轻量级高可用流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性。\nGITHUB:https://github.com/alibaba/Sentinel\n其官方文档中也提到，其受到Guava RateLmiter的启发。\n\n大家可能会问：Sentinel 和上面提到的Netflix Hystrix 有什么异同呢？\n其官方文档有专门的说明：\nhttps://github.com/alibaba/Sentinel/wiki/Sentinel-%E4%B8%8E-Hystrix-%E7%9A%84%E5%AF%B9%E6%AF%94\n\n\n## 其他实现\n进行限流控制还可以有很多种方法，针对不同的场景各有优劣，例如通过AtomicLong计数器控制、Redis计数，使用MQ消息队列进行流量消峰等等都是可以的。\n\n# 总结\n流量控制在高并发场景是一个对系统保护必不可少的一个手段，能够牺牲一部分流量而保护整个应用的可用性，不止于发生雪崩情况。","slug":"后端&架构/限流相关","published":1,"date":"2022-08-25T10:42:31.302Z","updated":"2022-08-25T10:42:58.726Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78ycziz001kvwm1owxs32a3","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在大流量场景，秒杀、抢购场景，一般会对网站做一些流量控制，牺牲一部分流量而保护系统而不至于系统直接down机。</p>\n<h1 id=\"常见限流算法\"><a href=\"#常见限流算法\" class=\"headerlink\" title=\"常见限流算法\"></a>常见限流算法</h1><h2 id=\"固定计算限流\"><a href=\"#固定计算限流\" class=\"headerlink\" title=\"固定计算限流\"></a>固定计算限流</h2><p>就是统计固定时间内的流量数量，如果超过了就限制。这种很容易实现，利用AutomicLong统计，下一个统计周期后又清零重新计算。<br>这样会有以下问题：</p>\n<ol>\n<li>1s之内的前100ms就已经达到了,那么后900ms就是空闲的。</li>\n<li>如果1s之内的后100ms和下一秒的前100ms,那么在这个前后1s内加起来的流量是限流的两倍，显然这没有达到“在任意1s内流量不超过限制”的控制，很多黑客利用这个缺陷攻击网站，从而拖垮服务器。<br><img src=\"../images/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3/getImage-20220825184239907.png\" alt></li>\n</ol>\n<h2 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h2><p>为了解决“计数限流”的缺陷，我们引入“滑动窗口”的计数方法。就是在计数限流的基础之上，将1个限流时间周期内切分成更小的单位计数，使得限制流量更加均分。<br>具体做法如下：</p>\n<ol>\n<li>将1s钟切成更细粒度200ms为计数单位，将请求时间点按取模的方式计算落到对应的计数格中，然后判断从当前计数格往前推1s(也就是5个计数格)的统计数总和当成当前流量的计数，如果超过阈值则限流，否则放行<br><img src=\"../images/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3/getImage-20220825184239739-1424159.png\" alt></li>\n<li>随着请求时间的推进，计数窗口也会随之往前移动<br><img src=\"../images/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3/getImage-20220825184239638.png\" alt></li>\n<li>这样的好处是，优化了“固定计数法”的缺陷，即在任意时刻，都将都以更小粒度的计数方法往前累加计算，防止在单位时间内流量超过限额。如图：<br><img src=\"../images/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3/getImage-20220825184239708.png\" alt></li>\n</ol>\n<h2 id=\"漏桶算法\"><a href=\"#漏桶算法\" class=\"headerlink\" title=\"漏桶算法\"></a>漏桶算法</h2><p>漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会时，有一定的缓冲能力，超过最大缓冲时将直接拒绝。这个算法的特点就是，不管桶里面是空还是满，都以均匀的速度放行。下面是从网上找的图：<br><img src=\"../images/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3/getImage-20220825184239739.png\" alt></p>\n<h2 id=\"令牌桶算法\"><a href=\"#令牌桶算法\" class=\"headerlink\" title=\"令牌桶算法\"></a>令牌桶算法</h2><p>令牌桶算法（Token Bucket）：是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。令牌桶算法示意图如下所示：<br><img src=\"../images/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3/getImage-20220825184239758.png\" alt></p>\n<p>令牌桶算法与漏桶算法的区别在于如果在一段时间内都没有流量，而桶中的令牌数有随着时间流逝匀速增加，那么桶中将会缓冲一定数量的令牌，即使后面流量突然增加超过了限额，也会由于还有可用的令牌直接放行，无需要等待。</p>\n<h1 id=\"限流实现\"><a href=\"#限流实现\" class=\"headerlink\" title=\"限流实现\"></a>限流实现</h1><h2 id=\"Guava的RateLimiter实现\"><a href=\"#Guava的RateLimiter实现\" class=\"headerlink\" title=\"Guava的RateLimiter实现\"></a>Guava的RateLimiter实现</h2><p>在Guava的工具包中，<code>RateLimiter</code>就是居于<code>令牌桶算法</code>实现的内存限流。<br>其构造有如下几个：</p>\n<pre><code> //构造方法1\n  @VisibleForTesting\n  static RateLimiter create(SleepingTicker ticker, double permitsPerSecond) {\n    //实现类是Bursty\n    RateLimiter rateLimiter = new Bursty(ticker, 1.0 /* maxBurstSeconds */);\n    //根据permitsPerSecond每秒令牌数计算，每个令牌产生的毫秒数\n    rateLimiter.setRate(permitsPerSecond);\n    return rateLimiter;\n  }\n\n  //构造方法2\n static RateLimiter create(\n      SleepingTicker ticker, double permitsPerSecond, long warmupPeriod, TimeUnit unit) {\n    //实现类是一个平滑预热限流，就是如果流量突然暴增，即使有足够的令牌，也不会一下子全部放下，会加一些线性等待时间平滑过渡\n    RateLimiter rateLimiter = new WarmingUp(ticker, warmupPeriod, unit);\n    rateLimiter.setRate(permitsPerSecond);\n    return rateLimiter;\n  }\n</code></pre><p>获取令牌</p>\n<pre><code>  public double acquire(int permits) {\n    checkPermits(permits);\n    long microsToWait;\n    //获取全局锁\n    synchronized (mutex) {\n        //根据当前时间算出还需要等待的时间\n        microsToWait = reserveNextTicket(permits, readSafeMicros());\n    }\n    ticker.sleepMicrosUninterruptibly(microsToWait);\n    return 1.0 * microsToWait / TimeUnit.SECONDS.toMicros(1L);\n  }</code></pre><p>下面是令牌桶算法的核心</p>\n<pre><code>  private long reserveNextTicket(double requiredPermits, long nowMicros) {\n    //根据当前时间算出可用令牌数及要出来这么多令牌的时间点\n    resync(nowMicros);\n    //看下还需要等多久\n    long microsToNextFreeTicket = nextFreeTicketMicros - nowMicros;\n    //看下当前要立即花费多少令牌\n    double storedPermitsToSpend = Math.min(requiredPermits, this.storedPermits);\n    //还剩多少令牌需要等待\n    double freshPermits = requiredPermits - storedPermitsToSpend;\n\n    //根据不同的实现，Bursty或者WarmingUp，返回额外需要等待的时间\n    long waitMicros = storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend)\n        + (long) (freshPermits * stableIntervalMicros);\n\n    //重置获取这么多令牌要等到啥时候\n    this.nextFreeTicketMicros = nextFreeTicketMicros + waitMicros;\n    //更新下还剩多少可用令牌\n    this.storedPermits -= storedPermitsToSpend;\n    //返回还需要等待的时间\n    return microsToNextFreeTicket;\n  }</code></pre><p>可以看到这个实现，并不是根据算法图一个生产者不断的往一个数组中添加令牌，一个消费者不断的取令牌，而是以时间线的方式，计算出当前获取令牌需要花费的时间及算出当前时间以设定的速度能够无产生多少令牌的方式实时计算的，简单并且没有额外的轮询操作，非常高效节省资源。</p>\n<h2 id=\"使用Semphore进行并发流控\"><a href=\"#使用Semphore进行并发流控\" class=\"headerlink\" title=\"使用Semphore进行并发流控\"></a>使用Semphore进行并发流控</h2><p><code>Semphore</code> 是JUC里面的并发信号量实现，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。很适合多线程情况对有限资源的抢占控制。</p>\n<h2 id=\"Netflix-Hystrix-熔断限流\"><a href=\"#Netflix-Hystrix-熔断限流\" class=\"headerlink\" title=\"Netflix Hystrix 熔断限流\"></a>Netflix Hystrix 熔断限流</h2><p>Spring Clound里的Hystrix能否实现根据一定的访问异常设置，对应用做到降级限流的的控制</p>\n<h2 id=\"阿里的Sentinel实现\"><a href=\"#阿里的Sentinel实现\" class=\"headerlink\" title=\"阿里的Sentinel实现\"></a>阿里的Sentinel实现</h2><p>Sentinel 是阿里中间件团队开源的，面向分布式服务架构的轻量级高可用流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性。<br>GITHUB:<a href=\"https://github.com/alibaba/Sentinel\" target=\"_blank\" rel=\"noopener\">https://github.com/alibaba/Sentinel</a><br>其官方文档中也提到，其受到Guava RateLmiter的启发。</p>\n<p>大家可能会问：Sentinel 和上面提到的Netflix Hystrix 有什么异同呢？<br>其官方文档有专门的说明：<br><a href=\"https://github.com/alibaba/Sentinel/wiki/Sentinel-%E4%B8%8E-Hystrix-%E7%9A%84%E5%AF%B9%E6%AF%94\" target=\"_blank\" rel=\"noopener\">https://github.com/alibaba/Sentinel/wiki/Sentinel-%E4%B8%8E-Hystrix-%E7%9A%84%E5%AF%B9%E6%AF%94</a></p>\n<h2 id=\"其他实现\"><a href=\"#其他实现\" class=\"headerlink\" title=\"其他实现\"></a>其他实现</h2><p>进行限流控制还可以有很多种方法，针对不同的场景各有优劣，例如通过AtomicLong计数器控制、Redis计数，使用MQ消息队列进行流量消峰等等都是可以的。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>流量控制在高并发场景是一个对系统保护必不可少的一个手段，能够牺牲一部分流量而保护整个应用的可用性，不止于发生雪崩情况。</p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在大流量场景，秒杀、抢购场景，一般会对网站做一些流量控制，牺牲一部分流量而保护系统而不至于系统直接down机。</p>\n<h1 id=\"常见限流算法\"><a href=\"#常见限流算法\" class=\"headerlink\" title=\"常见限流算法\"></a>常见限流算法</h1><h2 id=\"固定计算限流\"><a href=\"#固定计算限流\" class=\"headerlink\" title=\"固定计算限流\"></a>固定计算限流</h2><p>就是统计固定时间内的流量数量，如果超过了就限制。这种很容易实现，利用AutomicLong统计，下一个统计周期后又清零重新计算。<br>这样会有以下问题：</p>\n<ol>\n<li>1s之内的前100ms就已经达到了,那么后900ms就是空闲的。</li>\n<li>如果1s之内的后100ms和下一秒的前100ms,那么在这个前后1s内加起来的流量是限流的两倍，显然这没有达到“在任意1s内流量不超过限制”的控制，很多黑客利用这个缺陷攻击网站，从而拖垮服务器。<br><img src=\"../images/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3/getImage-20220825184239907.png\" alt></li>\n</ol>\n<h2 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h2><p>为了解决“计数限流”的缺陷，我们引入“滑动窗口”的计数方法。就是在计数限流的基础之上，将1个限流时间周期内切分成更小的单位计数，使得限制流量更加均分。<br>具体做法如下：</p>\n<ol>\n<li>将1s钟切成更细粒度200ms为计数单位，将请求时间点按取模的方式计算落到对应的计数格中，然后判断从当前计数格往前推1s(也就是5个计数格)的统计数总和当成当前流量的计数，如果超过阈值则限流，否则放行<br><img src=\"../images/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3/getImage-20220825184239739-1424159.png\" alt></li>\n<li>随着请求时间的推进，计数窗口也会随之往前移动<br><img src=\"../images/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3/getImage-20220825184239638.png\" alt></li>\n<li>这样的好处是，优化了“固定计数法”的缺陷，即在任意时刻，都将都以更小粒度的计数方法往前累加计算，防止在单位时间内流量超过限额。如图：<br><img src=\"../images/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3/getImage-20220825184239708.png\" alt></li>\n</ol>\n<h2 id=\"漏桶算法\"><a href=\"#漏桶算法\" class=\"headerlink\" title=\"漏桶算法\"></a>漏桶算法</h2><p>漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会时，有一定的缓冲能力，超过最大缓冲时将直接拒绝。这个算法的特点就是，不管桶里面是空还是满，都以均匀的速度放行。下面是从网上找的图：<br><img src=\"../images/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3/getImage-20220825184239739.png\" alt></p>\n<h2 id=\"令牌桶算法\"><a href=\"#令牌桶算法\" class=\"headerlink\" title=\"令牌桶算法\"></a>令牌桶算法</h2><p>令牌桶算法（Token Bucket）：是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。令牌桶算法示意图如下所示：<br><img src=\"../images/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3/getImage-20220825184239758.png\" alt></p>\n<p>令牌桶算法与漏桶算法的区别在于如果在一段时间内都没有流量，而桶中的令牌数有随着时间流逝匀速增加，那么桶中将会缓冲一定数量的令牌，即使后面流量突然增加超过了限额，也会由于还有可用的令牌直接放行，无需要等待。</p>\n<h1 id=\"限流实现\"><a href=\"#限流实现\" class=\"headerlink\" title=\"限流实现\"></a>限流实现</h1><h2 id=\"Guava的RateLimiter实现\"><a href=\"#Guava的RateLimiter实现\" class=\"headerlink\" title=\"Guava的RateLimiter实现\"></a>Guava的RateLimiter实现</h2><p>在Guava的工具包中，<code>RateLimiter</code>就是居于<code>令牌桶算法</code>实现的内存限流。<br>其构造有如下几个：</p>\n<pre><code> //构造方法1\n  @VisibleForTesting\n  static RateLimiter create(SleepingTicker ticker, double permitsPerSecond) {\n    //实现类是Bursty\n    RateLimiter rateLimiter = new Bursty(ticker, 1.0 /* maxBurstSeconds */);\n    //根据permitsPerSecond每秒令牌数计算，每个令牌产生的毫秒数\n    rateLimiter.setRate(permitsPerSecond);\n    return rateLimiter;\n  }\n\n  //构造方法2\n static RateLimiter create(\n      SleepingTicker ticker, double permitsPerSecond, long warmupPeriod, TimeUnit unit) {\n    //实现类是一个平滑预热限流，就是如果流量突然暴增，即使有足够的令牌，也不会一下子全部放下，会加一些线性等待时间平滑过渡\n    RateLimiter rateLimiter = new WarmingUp(ticker, warmupPeriod, unit);\n    rateLimiter.setRate(permitsPerSecond);\n    return rateLimiter;\n  }\n</code></pre><p>获取令牌</p>\n<pre><code>  public double acquire(int permits) {\n    checkPermits(permits);\n    long microsToWait;\n    //获取全局锁\n    synchronized (mutex) {\n        //根据当前时间算出还需要等待的时间\n        microsToWait = reserveNextTicket(permits, readSafeMicros());\n    }\n    ticker.sleepMicrosUninterruptibly(microsToWait);\n    return 1.0 * microsToWait / TimeUnit.SECONDS.toMicros(1L);\n  }</code></pre><p>下面是令牌桶算法的核心</p>\n<pre><code>  private long reserveNextTicket(double requiredPermits, long nowMicros) {\n    //根据当前时间算出可用令牌数及要出来这么多令牌的时间点\n    resync(nowMicros);\n    //看下还需要等多久\n    long microsToNextFreeTicket = nextFreeTicketMicros - nowMicros;\n    //看下当前要立即花费多少令牌\n    double storedPermitsToSpend = Math.min(requiredPermits, this.storedPermits);\n    //还剩多少令牌需要等待\n    double freshPermits = requiredPermits - storedPermitsToSpend;\n\n    //根据不同的实现，Bursty或者WarmingUp，返回额外需要等待的时间\n    long waitMicros = storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend)\n        + (long) (freshPermits * stableIntervalMicros);\n\n    //重置获取这么多令牌要等到啥时候\n    this.nextFreeTicketMicros = nextFreeTicketMicros + waitMicros;\n    //更新下还剩多少可用令牌\n    this.storedPermits -= storedPermitsToSpend;\n    //返回还需要等待的时间\n    return microsToNextFreeTicket;\n  }</code></pre><p>可以看到这个实现，并不是根据算法图一个生产者不断的往一个数组中添加令牌，一个消费者不断的取令牌，而是以时间线的方式，计算出当前获取令牌需要花费的时间及算出当前时间以设定的速度能够无产生多少令牌的方式实时计算的，简单并且没有额外的轮询操作，非常高效节省资源。</p>\n<h2 id=\"使用Semphore进行并发流控\"><a href=\"#使用Semphore进行并发流控\" class=\"headerlink\" title=\"使用Semphore进行并发流控\"></a>使用Semphore进行并发流控</h2><p><code>Semphore</code> 是JUC里面的并发信号量实现，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。很适合多线程情况对有限资源的抢占控制。</p>\n<h2 id=\"Netflix-Hystrix-熔断限流\"><a href=\"#Netflix-Hystrix-熔断限流\" class=\"headerlink\" title=\"Netflix Hystrix 熔断限流\"></a>Netflix Hystrix 熔断限流</h2><p>Spring Clound里的Hystrix能否实现根据一定的访问异常设置，对应用做到降级限流的的控制</p>\n<h2 id=\"阿里的Sentinel实现\"><a href=\"#阿里的Sentinel实现\" class=\"headerlink\" title=\"阿里的Sentinel实现\"></a>阿里的Sentinel实现</h2><p>Sentinel 是阿里中间件团队开源的，面向分布式服务架构的轻量级高可用流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性。<br>GITHUB:<a href=\"https://github.com/alibaba/Sentinel\" target=\"_blank\" rel=\"noopener\">https://github.com/alibaba/Sentinel</a><br>其官方文档中也提到，其受到Guava RateLmiter的启发。</p>\n<p>大家可能会问：Sentinel 和上面提到的Netflix Hystrix 有什么异同呢？<br>其官方文档有专门的说明：<br><a href=\"https://github.com/alibaba/Sentinel/wiki/Sentinel-%E4%B8%8E-Hystrix-%E7%9A%84%E5%AF%B9%E6%AF%94\" target=\"_blank\" rel=\"noopener\">https://github.com/alibaba/Sentinel/wiki/Sentinel-%E4%B8%8E-Hystrix-%E7%9A%84%E5%AF%B9%E6%AF%94</a></p>\n<h2 id=\"其他实现\"><a href=\"#其他实现\" class=\"headerlink\" title=\"其他实现\"></a>其他实现</h2><p>进行限流控制还可以有很多种方法，针对不同的场景各有优劣，例如通过AtomicLong计数器控制、Redis计数，使用MQ消息队列进行流量消峰等等都是可以的。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>流量控制在高并发场景是一个对系统保护必不可少的一个手段，能够牺牲一部分流量而保护整个应用的可用性，不止于发生雪崩情况。</p>\n"},{"title":"高性能无锁阻塞队列——Disruptor","date":"2020-09-30T03:25:00.000Z","author":"okeeper","top":true,"toc":true,"_content":"\n这是我年初在公司内部技术分享讲Disruptor的PPT,整理下放到博客里面。\n# 什么是Disruptor\n\nDisruptor 是一个用于在线程间通信的高效低延时的消息组件，它像个增强的队列，能够在无锁的情况下实现异步并发操作,它是纯内存组件。\n\n它的特点如下：\n- 高性能、无锁，实现每秒千万级别的异步业务处理能力\n- 它除了能实现队列基本功能，还能实现顺序消费，或者复杂的并行和依赖结合的消费方式\n- 能实现一对多、多对一、多对多的广播或抢占试消费\n\n# 为什么高性能，快速？？？\n- 使用RingBuffer数据结构，实现内存复用，减少重新分配空间带来的时间空间损耗\n- 使用CPU底层CAS（Compare And Swap :比较并交换）指令和内存屏障实现读写无锁化，并使用读写指针序列缓存行补齐方式达到真正的读写分离\n- 阻塞等待策略，使用Busy Spin(疯狂死循环)，是多核架构最快的通讯方式，同时也是最耗cpu的通讯方式，典型的牺牲硬件来换取速率\n\n# Disruptor数据结构\nDisruptor底层是一个固定大小的环形数组，每个读或写线程自己维护一个可读可写序列对象Sequence,并保证每个序列在不同的内存缓存行中（cache line）,避免伪共享，实现真正的无锁的读写分离，如图：\n\n![](../images/高性能无锁阻塞队列——Disruptor/getImage-20220825184418757.png)\n假设环形数组长度为L=8\n\n当生产者写入一个元素时，对应写的Sequence下标w++;\n当消费者读取一个元素时，对应读的Sequence下标r++;\n当且r < w < r+L时，数组正常写入及消费\n当且w=r时，数组为空，消费者阻塞，生产者可以从w+1%L的位置开始重复写入\n当且w=r+L时，数组写满，生产者阻塞，消费者可以从r+1%L的位置开始读取\n\n> 关于**缓存行伪共享**\n> 我们知道CPU为了加快访问内存数据，设置了很多CPU高速缓存，当CPU要访问一个内存数据时，先从主内存中缓存一个Cache Line(缓存行，CPU高速缓存存取数据的最小单位是一个缓存行，Hotspot JVM最小单位是64字节，而有的是128字节，不同虚拟机对此处理不一样)，而当一个缓存内的某个变量值改变时，其他缓存了此变量相邻的变量也将将失效，因为它们在一个缓存行中。这就是所谓的内存伪共享，虽然两个线程引用的变量不同，但是由于使用的是同一个缓存行的变量，也将受影响，从而影响CPU的执行速率。\n> ![](../images/高性能无锁阻塞队列——Disruptor/getImage-20220825184418828.png)\n> 在Disruptor中，为了实现真正的读写分离互不影响，也就是用于读写分离的两个Sequence对象使用缓存行填充的“笨方法”来避免这种伪共享。实现的方法就是将一个Sequence对象填充满一个缓存行，而避免其他无关的对象变量影响其使用速率。\n> 实现原理：\n> 我们知道一个在Java中一个对象的在内存中的大小取决于这个对象的成员变量大小，如下\n> ![](../images/高性能无锁阻塞队列——Disruptor/getImage-20220825184418735.png)\n> 需要使用一个long类型的成员变量value，一个long类型是8个字节，除了这个long类型value的下标外，定义14个long类型的变量p1、p2...p15，再加上一个对象的对象头大小是8字节,所以最终一个对象在在内存中的大小刚好是128字节，如果是64字节的 Line Cache就占用两个缓存行，128字节的Line cache就占用一个缓存行，在多线程情况下，排除了无关对象对这个Sequence对象的更新缓存失效影响。由于JDK7开始JVM会对对象的无效变量（未使用的变量）作优化处理，这里使用继承的方式，否则这种方式的缓存行填充是无效的，从JDK8开始已经原生支持缓存行填充，只需要一个注解:\n>\n> \n```\n@Contended\npublic class VolatileLong {\n    public volatile long value = 0L;  \n}\n```\n> 并且在java启动参数中设定`XX:-RestrictContended`，`@Contended`注释才会生效。\n\n# Disruptor的其他特性\n## Disruptor 并行消费的结果依赖（等待）\n![](https://leanote.com/api/file/getImage?fileId=5a27e543ab644163f00002e7)\n\n从中图可以看出需求是介样子的：生产者生产数据经过C1,C2处理完成后再到C3。\n假设如下场景：\n1、交易网关收到交易(P1)把交易数据发到RingBuffer中，\n2、负责处理增值业务的消费者C1和负责数据存储的消费者C2负责处理交易\n3、负责发送JMS消息的消费者C3在C1和C2处理完成后再进行处理。\n使用以下代码就可以实现：\n```\ndisruptor.handleEventsWith(new EventHandleOne(),new EventHandleTow()).then(new EventHandleThree());\n```\n\n# Disruptor与ArrayBlockingQueue、LinkedBlockingQueue的比较\n| -----        | Disruptor                                                    | ArrayBlockingQueue                                           | LinkedBlockingQueue                                          |\n| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 实现原理     | 固定大小的环形的ringbuffer存放元素                           | 固定大小的数组存放元素，通过插入、取出两个下标协同循环使用数组 | 用链表存放元素，大小不固定                                   |\n| 锁           | 无锁，多生产者之间有sequence竞争，采用比锁轻量的CAS操作      | 有锁，且读和写是同一个锁，锁粒度最大                         | 有锁，读锁和写锁分开                                         |\n| gc           | 元素重用，gc较少                                             | 元素重用，gc较少                                             | 元素不重用，gc较多                                           |\n| 其他         | 考虑cpu cacheline，避免false sharing，多种等待策略，可根据具体情况选用。比如自旋、wait、自旋一定时间然后wait等。 | 等待时线程wait，条件满足时，notify，线程切换较多             | 等待时线程wait，条件满足时，notify，线程切换较多             |\n| 适用场景     | 1、性能最好2、消费者其实是一种广播的方式，即每个元素，每个消费者都要消费 | 1、多并发时性能不好。2、典型消费者-生产者模式，一个元素只给一个消费者消费 | 1、并发性比ArrayBlockingQueue好，但gc较多。2、典型消费者-生产者模式，一个元素只给一个消费者消费 |\n| 一对一消费   | 16,355,904 tps/sec                                           | 4,641,233 tps/sec                                            | 4,633,706 tps/sec                                            |\n| 三对一消费   | 15,499,070 tps/sec                                           | 8,055,421 tps/sec                                            | 5,997,361 tps/sec                                            |\n| 10对一消费   | 17,624,251 tps/sec                                           | 4,310,716 tps/sec                                            | 5,670,863 tps/sec                                            |\n| 100对一消费  | 16,952,026 tps/sec                                           | 537,634 tps/sec                                              | 5,701,254 tps/sec                                            |\n| 10000对1消费 | 10,060,362 tps/sec                                           | 84,906 tps/sec                                               | 5,252,101 tps/sec                                            |\n\n大家感兴趣可以运行测试代码，Disruptor 性能测试代码：[https://github.com/okeeper/disruptorTest.git](https://github.com/okeeper/disruptorTest.git)\n\n# 总结\n凡事都不是选最好的，而是要选适合自己的。\n同样，我们系统也要根据我们业务需要选择适合的技术。Disruptor，总结就是：如果非业务性能特殊需要，无必要使用Disruptor，如每秒600万订单处理，大多时候我们的JDK5的java.util.concurrent包已经够我们使用了，因为Disruptor会增加我们的成本（学习成本、维护成本以及硬件资源消耗）。\n\n参考文章:[剖析Disruptor为什么会这么快(2)：神奇的缓存行填充](http://www.importnew.com/19896.html)","source":"_posts/学习/高性能无锁阻塞队列——Disruptor.md","raw":"---\ntitle: 高性能无锁阻塞队列——Disruptor\ndate: 2020-9-30 11:25:00\nauthor: okeeper\ntop: true\ntoc: true\ncategories: 学习\ntags:\n  - Disruptor\n  - 学习\n---\n\n这是我年初在公司内部技术分享讲Disruptor的PPT,整理下放到博客里面。\n# 什么是Disruptor\n\nDisruptor 是一个用于在线程间通信的高效低延时的消息组件，它像个增强的队列，能够在无锁的情况下实现异步并发操作,它是纯内存组件。\n\n它的特点如下：\n- 高性能、无锁，实现每秒千万级别的异步业务处理能力\n- 它除了能实现队列基本功能，还能实现顺序消费，或者复杂的并行和依赖结合的消费方式\n- 能实现一对多、多对一、多对多的广播或抢占试消费\n\n# 为什么高性能，快速？？？\n- 使用RingBuffer数据结构，实现内存复用，减少重新分配空间带来的时间空间损耗\n- 使用CPU底层CAS（Compare And Swap :比较并交换）指令和内存屏障实现读写无锁化，并使用读写指针序列缓存行补齐方式达到真正的读写分离\n- 阻塞等待策略，使用Busy Spin(疯狂死循环)，是多核架构最快的通讯方式，同时也是最耗cpu的通讯方式，典型的牺牲硬件来换取速率\n\n# Disruptor数据结构\nDisruptor底层是一个固定大小的环形数组，每个读或写线程自己维护一个可读可写序列对象Sequence,并保证每个序列在不同的内存缓存行中（cache line）,避免伪共享，实现真正的无锁的读写分离，如图：\n\n![](../images/高性能无锁阻塞队列——Disruptor/getImage-20220825184418757.png)\n假设环形数组长度为L=8\n\n当生产者写入一个元素时，对应写的Sequence下标w++;\n当消费者读取一个元素时，对应读的Sequence下标r++;\n当且r < w < r+L时，数组正常写入及消费\n当且w=r时，数组为空，消费者阻塞，生产者可以从w+1%L的位置开始重复写入\n当且w=r+L时，数组写满，生产者阻塞，消费者可以从r+1%L的位置开始读取\n\n> 关于**缓存行伪共享**\n> 我们知道CPU为了加快访问内存数据，设置了很多CPU高速缓存，当CPU要访问一个内存数据时，先从主内存中缓存一个Cache Line(缓存行，CPU高速缓存存取数据的最小单位是一个缓存行，Hotspot JVM最小单位是64字节，而有的是128字节，不同虚拟机对此处理不一样)，而当一个缓存内的某个变量值改变时，其他缓存了此变量相邻的变量也将将失效，因为它们在一个缓存行中。这就是所谓的内存伪共享，虽然两个线程引用的变量不同，但是由于使用的是同一个缓存行的变量，也将受影响，从而影响CPU的执行速率。\n> ![](../images/高性能无锁阻塞队列——Disruptor/getImage-20220825184418828.png)\n> 在Disruptor中，为了实现真正的读写分离互不影响，也就是用于读写分离的两个Sequence对象使用缓存行填充的“笨方法”来避免这种伪共享。实现的方法就是将一个Sequence对象填充满一个缓存行，而避免其他无关的对象变量影响其使用速率。\n> 实现原理：\n> 我们知道一个在Java中一个对象的在内存中的大小取决于这个对象的成员变量大小，如下\n> ![](../images/高性能无锁阻塞队列——Disruptor/getImage-20220825184418735.png)\n> 需要使用一个long类型的成员变量value，一个long类型是8个字节，除了这个long类型value的下标外，定义14个long类型的变量p1、p2...p15，再加上一个对象的对象头大小是8字节,所以最终一个对象在在内存中的大小刚好是128字节，如果是64字节的 Line Cache就占用两个缓存行，128字节的Line cache就占用一个缓存行，在多线程情况下，排除了无关对象对这个Sequence对象的更新缓存失效影响。由于JDK7开始JVM会对对象的无效变量（未使用的变量）作优化处理，这里使用继承的方式，否则这种方式的缓存行填充是无效的，从JDK8开始已经原生支持缓存行填充，只需要一个注解:\n>\n> \n```\n@Contended\npublic class VolatileLong {\n    public volatile long value = 0L;  \n}\n```\n> 并且在java启动参数中设定`XX:-RestrictContended`，`@Contended`注释才会生效。\n\n# Disruptor的其他特性\n## Disruptor 并行消费的结果依赖（等待）\n![](https://leanote.com/api/file/getImage?fileId=5a27e543ab644163f00002e7)\n\n从中图可以看出需求是介样子的：生产者生产数据经过C1,C2处理完成后再到C3。\n假设如下场景：\n1、交易网关收到交易(P1)把交易数据发到RingBuffer中，\n2、负责处理增值业务的消费者C1和负责数据存储的消费者C2负责处理交易\n3、负责发送JMS消息的消费者C3在C1和C2处理完成后再进行处理。\n使用以下代码就可以实现：\n```\ndisruptor.handleEventsWith(new EventHandleOne(),new EventHandleTow()).then(new EventHandleThree());\n```\n\n# Disruptor与ArrayBlockingQueue、LinkedBlockingQueue的比较\n| -----        | Disruptor                                                    | ArrayBlockingQueue                                           | LinkedBlockingQueue                                          |\n| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 实现原理     | 固定大小的环形的ringbuffer存放元素                           | 固定大小的数组存放元素，通过插入、取出两个下标协同循环使用数组 | 用链表存放元素，大小不固定                                   |\n| 锁           | 无锁，多生产者之间有sequence竞争，采用比锁轻量的CAS操作      | 有锁，且读和写是同一个锁，锁粒度最大                         | 有锁，读锁和写锁分开                                         |\n| gc           | 元素重用，gc较少                                             | 元素重用，gc较少                                             | 元素不重用，gc较多                                           |\n| 其他         | 考虑cpu cacheline，避免false sharing，多种等待策略，可根据具体情况选用。比如自旋、wait、自旋一定时间然后wait等。 | 等待时线程wait，条件满足时，notify，线程切换较多             | 等待时线程wait，条件满足时，notify，线程切换较多             |\n| 适用场景     | 1、性能最好2、消费者其实是一种广播的方式，即每个元素，每个消费者都要消费 | 1、多并发时性能不好。2、典型消费者-生产者模式，一个元素只给一个消费者消费 | 1、并发性比ArrayBlockingQueue好，但gc较多。2、典型消费者-生产者模式，一个元素只给一个消费者消费 |\n| 一对一消费   | 16,355,904 tps/sec                                           | 4,641,233 tps/sec                                            | 4,633,706 tps/sec                                            |\n| 三对一消费   | 15,499,070 tps/sec                                           | 8,055,421 tps/sec                                            | 5,997,361 tps/sec                                            |\n| 10对一消费   | 17,624,251 tps/sec                                           | 4,310,716 tps/sec                                            | 5,670,863 tps/sec                                            |\n| 100对一消费  | 16,952,026 tps/sec                                           | 537,634 tps/sec                                              | 5,701,254 tps/sec                                            |\n| 10000对1消费 | 10,060,362 tps/sec                                           | 84,906 tps/sec                                               | 5,252,101 tps/sec                                            |\n\n大家感兴趣可以运行测试代码，Disruptor 性能测试代码：[https://github.com/okeeper/disruptorTest.git](https://github.com/okeeper/disruptorTest.git)\n\n# 总结\n凡事都不是选最好的，而是要选适合自己的。\n同样，我们系统也要根据我们业务需要选择适合的技术。Disruptor，总结就是：如果非业务性能特殊需要，无必要使用Disruptor，如每秒600万订单处理，大多时候我们的JDK5的java.util.concurrent包已经够我们使用了，因为Disruptor会增加我们的成本（学习成本、维护成本以及硬件资源消耗）。\n\n参考文章:[剖析Disruptor为什么会这么快(2)：神奇的缓存行填充](http://www.importnew.com/19896.html)","slug":"学习/高性能无锁阻塞队列——Disruptor","published":1,"updated":"2022-08-25T11:05:48.895Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczj0001lvwm1fpyx87p7","content":"<p>这是我年初在公司内部技术分享讲Disruptor的PPT,整理下放到博客里面。</p>\n<h1 id=\"什么是Disruptor\"><a href=\"#什么是Disruptor\" class=\"headerlink\" title=\"什么是Disruptor\"></a>什么是Disruptor</h1><p>Disruptor 是一个用于在线程间通信的高效低延时的消息组件，它像个增强的队列，能够在无锁的情况下实现异步并发操作,它是纯内存组件。</p>\n<p>它的特点如下：</p>\n<ul>\n<li>高性能、无锁，实现每秒千万级别的异步业务处理能力</li>\n<li>它除了能实现队列基本功能，还能实现顺序消费，或者复杂的并行和依赖结合的消费方式</li>\n<li>能实现一对多、多对一、多对多的广播或抢占试消费</li>\n</ul>\n<h1 id=\"为什么高性能，快速？？？\"><a href=\"#为什么高性能，快速？？？\" class=\"headerlink\" title=\"为什么高性能，快速？？？\"></a>为什么高性能，快速？？？</h1><ul>\n<li>使用RingBuffer数据结构，实现内存复用，减少重新分配空间带来的时间空间损耗</li>\n<li>使用CPU底层CAS（Compare And Swap :比较并交换）指令和内存屏障实现读写无锁化，并使用读写指针序列缓存行补齐方式达到真正的读写分离</li>\n<li>阻塞等待策略，使用Busy Spin(疯狂死循环)，是多核架构最快的通讯方式，同时也是最耗cpu的通讯方式，典型的牺牲硬件来换取速率</li>\n</ul>\n<h1 id=\"Disruptor数据结构\"><a href=\"#Disruptor数据结构\" class=\"headerlink\" title=\"Disruptor数据结构\"></a>Disruptor数据结构</h1><p>Disruptor底层是一个固定大小的环形数组，每个读或写线程自己维护一个可读可写序列对象Sequence,并保证每个序列在不同的内存缓存行中（cache line）,避免伪共享，实现真正的无锁的读写分离，如图：</p>\n<p><img src=\"../images/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A0%E9%94%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Disruptor/getImage-20220825184418757.png\" alt><br>假设环形数组长度为L=8</p>\n<p>当生产者写入一个元素时，对应写的Sequence下标w++;<br>当消费者读取一个元素时，对应读的Sequence下标r++;<br>当且r &lt; w &lt; r+L时，数组正常写入及消费<br>当且w=r时，数组为空，消费者阻塞，生产者可以从w+1%L的位置开始重复写入<br>当且w=r+L时，数组写满，生产者阻塞，消费者可以从r+1%L的位置开始读取</p>\n<blockquote>\n<p>关于<strong>缓存行伪共享</strong><br>我们知道CPU为了加快访问内存数据，设置了很多CPU高速缓存，当CPU要访问一个内存数据时，先从主内存中缓存一个Cache Line(缓存行，CPU高速缓存存取数据的最小单位是一个缓存行，Hotspot JVM最小单位是64字节，而有的是128字节，不同虚拟机对此处理不一样)，而当一个缓存内的某个变量值改变时，其他缓存了此变量相邻的变量也将将失效，因为它们在一个缓存行中。这就是所谓的内存伪共享，虽然两个线程引用的变量不同，但是由于使用的是同一个缓存行的变量，也将受影响，从而影响CPU的执行速率。<br><img src=\"../images/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A0%E9%94%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Disruptor/getImage-20220825184418828.png\" alt><br>在Disruptor中，为了实现真正的读写分离互不影响，也就是用于读写分离的两个Sequence对象使用缓存行填充的“笨方法”来避免这种伪共享。实现的方法就是将一个Sequence对象填充满一个缓存行，而避免其他无关的对象变量影响其使用速率。<br>实现原理：<br>我们知道一个在Java中一个对象的在内存中的大小取决于这个对象的成员变量大小，如下<br><img src=\"../images/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A0%E9%94%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Disruptor/getImage-20220825184418735.png\" alt><br>需要使用一个long类型的成员变量value，一个long类型是8个字节，除了这个long类型value的下标外，定义14个long类型的变量p1、p2…p15，再加上一个对象的对象头大小是8字节,所以最终一个对象在在内存中的大小刚好是128字节，如果是64字节的 Line Cache就占用两个缓存行，128字节的Line cache就占用一个缓存行，在多线程情况下，排除了无关对象对这个Sequence对象的更新缓存失效影响。由于JDK7开始JVM会对对象的无效变量（未使用的变量）作优化处理，这里使用继承的方式，否则这种方式的缓存行填充是无效的，从JDK8开始已经原生支持缓存行填充，只需要一个注解:</p>\n</blockquote>\n<pre><code>@Contended\npublic class VolatileLong {\n    public volatile long value = 0L;  \n}</code></pre><blockquote>\n<p>并且在java启动参数中设定<code>XX:-RestrictContended</code>，<code>@Contended</code>注释才会生效。</p>\n</blockquote>\n<h1 id=\"Disruptor的其他特性\"><a href=\"#Disruptor的其他特性\" class=\"headerlink\" title=\"Disruptor的其他特性\"></a>Disruptor的其他特性</h1><h2 id=\"Disruptor-并行消费的结果依赖（等待）\"><a href=\"#Disruptor-并行消费的结果依赖（等待）\" class=\"headerlink\" title=\"Disruptor 并行消费的结果依赖（等待）\"></a>Disruptor 并行消费的结果依赖（等待）</h2><p><img src=\"https://leanote.com/api/file/getImage?fileId=5a27e543ab644163f00002e7\" alt></p>\n<p>从中图可以看出需求是介样子的：生产者生产数据经过C1,C2处理完成后再到C3。<br>假设如下场景：<br>1、交易网关收到交易(P1)把交易数据发到RingBuffer中，<br>2、负责处理增值业务的消费者C1和负责数据存储的消费者C2负责处理交易<br>3、负责发送JMS消息的消费者C3在C1和C2处理完成后再进行处理。<br>使用以下代码就可以实现：</p>\n<pre><code>disruptor.handleEventsWith(new EventHandleOne(),new EventHandleTow()).then(new EventHandleThree());</code></pre><h1 id=\"Disruptor与ArrayBlockingQueue、LinkedBlockingQueue的比较\"><a href=\"#Disruptor与ArrayBlockingQueue、LinkedBlockingQueue的比较\" class=\"headerlink\" title=\"Disruptor与ArrayBlockingQueue、LinkedBlockingQueue的比较\"></a>Disruptor与ArrayBlockingQueue、LinkedBlockingQueue的比较</h1><table>\n<thead>\n<tr>\n<th>—–</th>\n<th>Disruptor</th>\n<th>ArrayBlockingQueue</th>\n<th>LinkedBlockingQueue</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>实现原理</td>\n<td>固定大小的环形的ringbuffer存放元素</td>\n<td>固定大小的数组存放元素，通过插入、取出两个下标协同循环使用数组</td>\n<td>用链表存放元素，大小不固定</td>\n</tr>\n<tr>\n<td>锁</td>\n<td>无锁，多生产者之间有sequence竞争，采用比锁轻量的CAS操作</td>\n<td>有锁，且读和写是同一个锁，锁粒度最大</td>\n<td>有锁，读锁和写锁分开</td>\n</tr>\n<tr>\n<td>gc</td>\n<td>元素重用，gc较少</td>\n<td>元素重用，gc较少</td>\n<td>元素不重用，gc较多</td>\n</tr>\n<tr>\n<td>其他</td>\n<td>考虑cpu cacheline，避免false sharing，多种等待策略，可根据具体情况选用。比如自旋、wait、自旋一定时间然后wait等。</td>\n<td>等待时线程wait，条件满足时，notify，线程切换较多</td>\n<td>等待时线程wait，条件满足时，notify，线程切换较多</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>1、性能最好2、消费者其实是一种广播的方式，即每个元素，每个消费者都要消费</td>\n<td>1、多并发时性能不好。2、典型消费者-生产者模式，一个元素只给一个消费者消费</td>\n<td>1、并发性比ArrayBlockingQueue好，但gc较多。2、典型消费者-生产者模式，一个元素只给一个消费者消费</td>\n</tr>\n<tr>\n<td>一对一消费</td>\n<td>16,355,904 tps/sec</td>\n<td>4,641,233 tps/sec</td>\n<td>4,633,706 tps/sec</td>\n</tr>\n<tr>\n<td>三对一消费</td>\n<td>15,499,070 tps/sec</td>\n<td>8,055,421 tps/sec</td>\n<td>5,997,361 tps/sec</td>\n</tr>\n<tr>\n<td>10对一消费</td>\n<td>17,624,251 tps/sec</td>\n<td>4,310,716 tps/sec</td>\n<td>5,670,863 tps/sec</td>\n</tr>\n<tr>\n<td>100对一消费</td>\n<td>16,952,026 tps/sec</td>\n<td>537,634 tps/sec</td>\n<td>5,701,254 tps/sec</td>\n</tr>\n<tr>\n<td>10000对1消费</td>\n<td>10,060,362 tps/sec</td>\n<td>84,906 tps/sec</td>\n<td>5,252,101 tps/sec</td>\n</tr>\n</tbody></table>\n<p>大家感兴趣可以运行测试代码，Disruptor 性能测试代码：<a href=\"https://github.com/okeeper/disruptorTest.git\" target=\"_blank\" rel=\"noopener\">https://github.com/okeeper/disruptorTest.git</a></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>凡事都不是选最好的，而是要选适合自己的。<br>同样，我们系统也要根据我们业务需要选择适合的技术。Disruptor，总结就是：如果非业务性能特殊需要，无必要使用Disruptor，如每秒600万订单处理，大多时候我们的JDK5的java.util.concurrent包已经够我们使用了，因为Disruptor会增加我们的成本（学习成本、维护成本以及硬件资源消耗）。</p>\n<p>参考文章:<a href=\"http://www.importnew.com/19896.html\" target=\"_blank\" rel=\"noopener\">剖析Disruptor为什么会这么快(2)：神奇的缓存行填充</a></p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<p>这是我年初在公司内部技术分享讲Disruptor的PPT,整理下放到博客里面。</p>\n<h1 id=\"什么是Disruptor\"><a href=\"#什么是Disruptor\" class=\"headerlink\" title=\"什么是Disruptor\"></a>什么是Disruptor</h1><p>Disruptor 是一个用于在线程间通信的高效低延时的消息组件，它像个增强的队列，能够在无锁的情况下实现异步并发操作,它是纯内存组件。</p>\n<p>它的特点如下：</p>\n<ul>\n<li>高性能、无锁，实现每秒千万级别的异步业务处理能力</li>\n<li>它除了能实现队列基本功能，还能实现顺序消费，或者复杂的并行和依赖结合的消费方式</li>\n<li>能实现一对多、多对一、多对多的广播或抢占试消费</li>\n</ul>\n<h1 id=\"为什么高性能，快速？？？\"><a href=\"#为什么高性能，快速？？？\" class=\"headerlink\" title=\"为什么高性能，快速？？？\"></a>为什么高性能，快速？？？</h1><ul>\n<li>使用RingBuffer数据结构，实现内存复用，减少重新分配空间带来的时间空间损耗</li>\n<li>使用CPU底层CAS（Compare And Swap :比较并交换）指令和内存屏障实现读写无锁化，并使用读写指针序列缓存行补齐方式达到真正的读写分离</li>\n<li>阻塞等待策略，使用Busy Spin(疯狂死循环)，是多核架构最快的通讯方式，同时也是最耗cpu的通讯方式，典型的牺牲硬件来换取速率</li>\n</ul>\n<h1 id=\"Disruptor数据结构\"><a href=\"#Disruptor数据结构\" class=\"headerlink\" title=\"Disruptor数据结构\"></a>Disruptor数据结构</h1><p>Disruptor底层是一个固定大小的环形数组，每个读或写线程自己维护一个可读可写序列对象Sequence,并保证每个序列在不同的内存缓存行中（cache line）,避免伪共享，实现真正的无锁的读写分离，如图：</p>\n<p><img src=\"../images/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A0%E9%94%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Disruptor/getImage-20220825184418757.png\" alt><br>假设环形数组长度为L=8</p>\n<p>当生产者写入一个元素时，对应写的Sequence下标w++;<br>当消费者读取一个元素时，对应读的Sequence下标r++;<br>当且r &lt; w &lt; r+L时，数组正常写入及消费<br>当且w=r时，数组为空，消费者阻塞，生产者可以从w+1%L的位置开始重复写入<br>当且w=r+L时，数组写满，生产者阻塞，消费者可以从r+1%L的位置开始读取</p>\n<blockquote>\n<p>关于<strong>缓存行伪共享</strong><br>我们知道CPU为了加快访问内存数据，设置了很多CPU高速缓存，当CPU要访问一个内存数据时，先从主内存中缓存一个Cache Line(缓存行，CPU高速缓存存取数据的最小单位是一个缓存行，Hotspot JVM最小单位是64字节，而有的是128字节，不同虚拟机对此处理不一样)，而当一个缓存内的某个变量值改变时，其他缓存了此变量相邻的变量也将将失效，因为它们在一个缓存行中。这就是所谓的内存伪共享，虽然两个线程引用的变量不同，但是由于使用的是同一个缓存行的变量，也将受影响，从而影响CPU的执行速率。<br><img src=\"../images/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A0%E9%94%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Disruptor/getImage-20220825184418828.png\" alt><br>在Disruptor中，为了实现真正的读写分离互不影响，也就是用于读写分离的两个Sequence对象使用缓存行填充的“笨方法”来避免这种伪共享。实现的方法就是将一个Sequence对象填充满一个缓存行，而避免其他无关的对象变量影响其使用速率。<br>实现原理：<br>我们知道一个在Java中一个对象的在内存中的大小取决于这个对象的成员变量大小，如下<br><img src=\"../images/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A0%E9%94%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Disruptor/getImage-20220825184418735.png\" alt><br>需要使用一个long类型的成员变量value，一个long类型是8个字节，除了这个long类型value的下标外，定义14个long类型的变量p1、p2…p15，再加上一个对象的对象头大小是8字节,所以最终一个对象在在内存中的大小刚好是128字节，如果是64字节的 Line Cache就占用两个缓存行，128字节的Line cache就占用一个缓存行，在多线程情况下，排除了无关对象对这个Sequence对象的更新缓存失效影响。由于JDK7开始JVM会对对象的无效变量（未使用的变量）作优化处理，这里使用继承的方式，否则这种方式的缓存行填充是无效的，从JDK8开始已经原生支持缓存行填充，只需要一个注解:</p>\n</blockquote>\n<pre><code>@Contended\npublic class VolatileLong {\n    public volatile long value = 0L;  \n}</code></pre><blockquote>\n<p>并且在java启动参数中设定<code>XX:-RestrictContended</code>，<code>@Contended</code>注释才会生效。</p>\n</blockquote>\n<h1 id=\"Disruptor的其他特性\"><a href=\"#Disruptor的其他特性\" class=\"headerlink\" title=\"Disruptor的其他特性\"></a>Disruptor的其他特性</h1><h2 id=\"Disruptor-并行消费的结果依赖（等待）\"><a href=\"#Disruptor-并行消费的结果依赖（等待）\" class=\"headerlink\" title=\"Disruptor 并行消费的结果依赖（等待）\"></a>Disruptor 并行消费的结果依赖（等待）</h2><p><img src=\"https://leanote.com/api/file/getImage?fileId=5a27e543ab644163f00002e7\" alt></p>\n<p>从中图可以看出需求是介样子的：生产者生产数据经过C1,C2处理完成后再到C3。<br>假设如下场景：<br>1、交易网关收到交易(P1)把交易数据发到RingBuffer中，<br>2、负责处理增值业务的消费者C1和负责数据存储的消费者C2负责处理交易<br>3、负责发送JMS消息的消费者C3在C1和C2处理完成后再进行处理。<br>使用以下代码就可以实现：</p>\n<pre><code>disruptor.handleEventsWith(new EventHandleOne(),new EventHandleTow()).then(new EventHandleThree());</code></pre><h1 id=\"Disruptor与ArrayBlockingQueue、LinkedBlockingQueue的比较\"><a href=\"#Disruptor与ArrayBlockingQueue、LinkedBlockingQueue的比较\" class=\"headerlink\" title=\"Disruptor与ArrayBlockingQueue、LinkedBlockingQueue的比较\"></a>Disruptor与ArrayBlockingQueue、LinkedBlockingQueue的比较</h1><table>\n<thead>\n<tr>\n<th>—–</th>\n<th>Disruptor</th>\n<th>ArrayBlockingQueue</th>\n<th>LinkedBlockingQueue</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>实现原理</td>\n<td>固定大小的环形的ringbuffer存放元素</td>\n<td>固定大小的数组存放元素，通过插入、取出两个下标协同循环使用数组</td>\n<td>用链表存放元素，大小不固定</td>\n</tr>\n<tr>\n<td>锁</td>\n<td>无锁，多生产者之间有sequence竞争，采用比锁轻量的CAS操作</td>\n<td>有锁，且读和写是同一个锁，锁粒度最大</td>\n<td>有锁，读锁和写锁分开</td>\n</tr>\n<tr>\n<td>gc</td>\n<td>元素重用，gc较少</td>\n<td>元素重用，gc较少</td>\n<td>元素不重用，gc较多</td>\n</tr>\n<tr>\n<td>其他</td>\n<td>考虑cpu cacheline，避免false sharing，多种等待策略，可根据具体情况选用。比如自旋、wait、自旋一定时间然后wait等。</td>\n<td>等待时线程wait，条件满足时，notify，线程切换较多</td>\n<td>等待时线程wait，条件满足时，notify，线程切换较多</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>1、性能最好2、消费者其实是一种广播的方式，即每个元素，每个消费者都要消费</td>\n<td>1、多并发时性能不好。2、典型消费者-生产者模式，一个元素只给一个消费者消费</td>\n<td>1、并发性比ArrayBlockingQueue好，但gc较多。2、典型消费者-生产者模式，一个元素只给一个消费者消费</td>\n</tr>\n<tr>\n<td>一对一消费</td>\n<td>16,355,904 tps/sec</td>\n<td>4,641,233 tps/sec</td>\n<td>4,633,706 tps/sec</td>\n</tr>\n<tr>\n<td>三对一消费</td>\n<td>15,499,070 tps/sec</td>\n<td>8,055,421 tps/sec</td>\n<td>5,997,361 tps/sec</td>\n</tr>\n<tr>\n<td>10对一消费</td>\n<td>17,624,251 tps/sec</td>\n<td>4,310,716 tps/sec</td>\n<td>5,670,863 tps/sec</td>\n</tr>\n<tr>\n<td>100对一消费</td>\n<td>16,952,026 tps/sec</td>\n<td>537,634 tps/sec</td>\n<td>5,701,254 tps/sec</td>\n</tr>\n<tr>\n<td>10000对1消费</td>\n<td>10,060,362 tps/sec</td>\n<td>84,906 tps/sec</td>\n<td>5,252,101 tps/sec</td>\n</tr>\n</tbody></table>\n<p>大家感兴趣可以运行测试代码，Disruptor 性能测试代码：<a href=\"https://github.com/okeeper/disruptorTest.git\" target=\"_blank\" rel=\"noopener\">https://github.com/okeeper/disruptorTest.git</a></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>凡事都不是选最好的，而是要选适合自己的。<br>同样，我们系统也要根据我们业务需要选择适合的技术。Disruptor，总结就是：如果非业务性能特殊需要，无必要使用Disruptor，如每秒600万订单处理，大多时候我们的JDK5的java.util.concurrent包已经够我们使用了，因为Disruptor会增加我们的成本（学习成本、维护成本以及硬件资源消耗）。</p>\n<p>参考文章:<a href=\"http://www.importnew.com/19896.html\" target=\"_blank\" rel=\"noopener\">剖析Disruptor为什么会这么快(2)：神奇的缓存行填充</a></p>\n"},{"title":"HTTP及HTTPS的理解","date":"2020-04-30T03:25:00.000Z","author":"okeeper","_content":"\n# HTTP\nHTTP全称叫超文本传输协议(HyperText Transfer Protocol),是用于WWW(万网)服务器与浏览器客户端的一种通讯协议\n## TCP/IP\n关于计算机通讯，需要了解的一些背景知识，TCP/IP.\n我们经常说TCP/IP，为什么要一起说，因为这两者有着密切的关系，其实它包含两个协议：\n\n- TCP: TCP 负责将数据包在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组\n- IP：负责将TCP分隔的IP包发送传输到指定ip的机器上，IP包之间的传输不保证顺序性，在TCP重组时才还原数据顺序\n\n所以说TCP/IP是传输协议的上下层关系。\n## 关于HTTP\n而HTTP则是在TCP/IP基础上的进一步封装的协议，属于应用层协议.网络传输的协议关系图如下：\n![](../images/HTTP及HTTPS的理解/getImage-20220825184529465.png)\n\n网络传输的协议，两边刚好是相反的:\n![](../images/HTTP及HTTPS的理解/getImage-20220825184529221.png)\n## HTTP原理\nHTTP请求主要分为以下几个步奏：\n1. 域名解析，查找对应DNS服务器域名解析找到对应的IP\n2. 封装TCP/IP通讯数据包，建立连接（3三次握手协议），HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接\n3. 封装HTTP请求数据包，请求头信息，请求参数等。\n4. 等待服务器响应，服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码\n5. 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码\n    Connection:keep-alive\n   TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求，这就是长连接的原理\n\n\n关于HTTP的超时时间，`connectTimeout`、`requestConnectTimeout`、`readTimeout`、`socketTimeout`\n\n- `connectTimeout` 是指上面的第2步，建立TCP/IP连接的超时时间\n- `requestConnectTimeout` 是指上面第3步，发送请求头发送http请求的超时时间\n- `readTimeout` 是指从发送http请求开始等待响应内容的总超时时间,指上面步骤的第4步\n- `socketTimeout` 响应内容有可能是分成几个socket数据包传输的，而这个socketTimeout的意思就是每个socket传输的超时时间\n\n例如下图：\nreadTimeout设为6s,socketTimeout设为4秒，发送http报文之后响应\n时间超时为6s,响应内容abc分三次socket传输,每次间隔超时时间为4s，所以总共花费6s是不会抛出`socket timeout`\n![](../images/HTTP及HTTPS的理解/getImage-20220825184529343.png)\n\n## JAVA中使用http\nJava 访问http通过\n\n# HTTPS\nHTTPS简单的说就是，http的安全版\n\n\n## HTTPS基本原理\n\n![](../images/HTTP及HTTPS的理解/getImage-20220825184528912.png)\n\n过程大致如下：\n1. SSL客户端通过TCP和服务器建立连接之后（443端口），并且在一般的tcp连接协商（握手）过程中请求证书。\n即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥）。                 \n2. Client在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。\n3. 如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。\n\n参考文章：\nHTTPS介绍：https://imququ.com/post/how-to-decrypt-https.html\n[http://blog.csdn.net/hguisu/article/details/8680808](http://blog.csdn.net/hguisu/article/details/8680808)","source":"_posts/学习/HTTP及HTTPS的理解.md","raw":"---\ntitle: HTTP及HTTPS的理解\ndate: 2020-4-30 11:25:00\nauthor: okeeper\ncategories: 学习\ntags:\n  - HTTP\n  - HTTPS\n  - 学习\n---\n\n# HTTP\nHTTP全称叫超文本传输协议(HyperText Transfer Protocol),是用于WWW(万网)服务器与浏览器客户端的一种通讯协议\n## TCP/IP\n关于计算机通讯，需要了解的一些背景知识，TCP/IP.\n我们经常说TCP/IP，为什么要一起说，因为这两者有着密切的关系，其实它包含两个协议：\n\n- TCP: TCP 负责将数据包在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组\n- IP：负责将TCP分隔的IP包发送传输到指定ip的机器上，IP包之间的传输不保证顺序性，在TCP重组时才还原数据顺序\n\n所以说TCP/IP是传输协议的上下层关系。\n## 关于HTTP\n而HTTP则是在TCP/IP基础上的进一步封装的协议，属于应用层协议.网络传输的协议关系图如下：\n![](../images/HTTP及HTTPS的理解/getImage-20220825184529465.png)\n\n网络传输的协议，两边刚好是相反的:\n![](../images/HTTP及HTTPS的理解/getImage-20220825184529221.png)\n## HTTP原理\nHTTP请求主要分为以下几个步奏：\n1. 域名解析，查找对应DNS服务器域名解析找到对应的IP\n2. 封装TCP/IP通讯数据包，建立连接（3三次握手协议），HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接\n3. 封装HTTP请求数据包，请求头信息，请求参数等。\n4. 等待服务器响应，服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码\n5. 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码\n    Connection:keep-alive\n   TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求，这就是长连接的原理\n\n\n关于HTTP的超时时间，`connectTimeout`、`requestConnectTimeout`、`readTimeout`、`socketTimeout`\n\n- `connectTimeout` 是指上面的第2步，建立TCP/IP连接的超时时间\n- `requestConnectTimeout` 是指上面第3步，发送请求头发送http请求的超时时间\n- `readTimeout` 是指从发送http请求开始等待响应内容的总超时时间,指上面步骤的第4步\n- `socketTimeout` 响应内容有可能是分成几个socket数据包传输的，而这个socketTimeout的意思就是每个socket传输的超时时间\n\n例如下图：\nreadTimeout设为6s,socketTimeout设为4秒，发送http报文之后响应\n时间超时为6s,响应内容abc分三次socket传输,每次间隔超时时间为4s，所以总共花费6s是不会抛出`socket timeout`\n![](../images/HTTP及HTTPS的理解/getImage-20220825184529343.png)\n\n## JAVA中使用http\nJava 访问http通过\n\n# HTTPS\nHTTPS简单的说就是，http的安全版\n\n\n## HTTPS基本原理\n\n![](../images/HTTP及HTTPS的理解/getImage-20220825184528912.png)\n\n过程大致如下：\n1. SSL客户端通过TCP和服务器建立连接之后（443端口），并且在一般的tcp连接协商（握手）过程中请求证书。\n即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥）。                 \n2. Client在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。\n3. 如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。\n\n参考文章：\nHTTPS介绍：https://imququ.com/post/how-to-decrypt-https.html\n[http://blog.csdn.net/hguisu/article/details/8680808](http://blog.csdn.net/hguisu/article/details/8680808)","slug":"学习/HTTP及HTTPS的理解","published":1,"updated":"2022-08-25T11:05:03.812Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczj2001pvwm150i466p3","content":"<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><p>HTTP全称叫超文本传输协议(HyperText Transfer Protocol),是用于WWW(万网)服务器与浏览器客户端的一种通讯协议</p>\n<h2 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h2><p>关于计算机通讯，需要了解的一些背景知识，TCP/IP.<br>我们经常说TCP/IP，为什么要一起说，因为这两者有着密切的关系，其实它包含两个协议：</p>\n<ul>\n<li>TCP: TCP 负责将数据包在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组</li>\n<li>IP：负责将TCP分隔的IP包发送传输到指定ip的机器上，IP包之间的传输不保证顺序性，在TCP重组时才还原数据顺序</li>\n</ul>\n<p>所以说TCP/IP是传输协议的上下层关系。</p>\n<h2 id=\"关于HTTP\"><a href=\"#关于HTTP\" class=\"headerlink\" title=\"关于HTTP\"></a>关于HTTP</h2><p>而HTTP则是在TCP/IP基础上的进一步封装的协议，属于应用层协议.网络传输的协议关系图如下：<br><img src=\"../images/HTTP%E5%8F%8AHTTPS%E7%9A%84%E7%90%86%E8%A7%A3/getImage-20220825184529465.png\" alt></p>\n<p>网络传输的协议，两边刚好是相反的:<br><img src=\"../images/HTTP%E5%8F%8AHTTPS%E7%9A%84%E7%90%86%E8%A7%A3/getImage-20220825184529221.png\" alt></p>\n<h2 id=\"HTTP原理\"><a href=\"#HTTP原理\" class=\"headerlink\" title=\"HTTP原理\"></a>HTTP原理</h2><p>HTTP请求主要分为以下几个步奏：</p>\n<ol>\n<li>域名解析，查找对应DNS服务器域名解析找到对应的IP</li>\n<li>封装TCP/IP通讯数据包，建立连接（3三次握手协议），HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接</li>\n<li>封装HTTP请求数据包，请求头信息，请求参数等。</li>\n<li>等待服务器响应，服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码</li>\n<li>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码<br> Connection:keep-alive<br>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求，这就是长连接的原理</li>\n</ol>\n<p>关于HTTP的超时时间，<code>connectTimeout</code>、<code>requestConnectTimeout</code>、<code>readTimeout</code>、<code>socketTimeout</code></p>\n<ul>\n<li><code>connectTimeout</code> 是指上面的第2步，建立TCP/IP连接的超时时间</li>\n<li><code>requestConnectTimeout</code> 是指上面第3步，发送请求头发送http请求的超时时间</li>\n<li><code>readTimeout</code> 是指从发送http请求开始等待响应内容的总超时时间,指上面步骤的第4步</li>\n<li><code>socketTimeout</code> 响应内容有可能是分成几个socket数据包传输的，而这个socketTimeout的意思就是每个socket传输的超时时间</li>\n</ul>\n<p>例如下图：<br>readTimeout设为6s,socketTimeout设为4秒，发送http报文之后响应<br>时间超时为6s,响应内容abc分三次socket传输,每次间隔超时时间为4s，所以总共花费6s是不会抛出<code>socket timeout</code><br><img src=\"../images/HTTP%E5%8F%8AHTTPS%E7%9A%84%E7%90%86%E8%A7%A3/getImage-20220825184529343.png\" alt></p>\n<h2 id=\"JAVA中使用http\"><a href=\"#JAVA中使用http\" class=\"headerlink\" title=\"JAVA中使用http\"></a>JAVA中使用http</h2><p>Java 访问http通过</p>\n<h1 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h1><p>HTTPS简单的说就是，http的安全版</p>\n<h2 id=\"HTTPS基本原理\"><a href=\"#HTTPS基本原理\" class=\"headerlink\" title=\"HTTPS基本原理\"></a>HTTPS基本原理</h2><p><img src=\"../images/HTTP%E5%8F%8AHTTPS%E7%9A%84%E7%90%86%E8%A7%A3/getImage-20220825184528912.png\" alt></p>\n<p>过程大致如下：</p>\n<ol>\n<li>SSL客户端通过TCP和服务器建立连接之后（443端口），并且在一般的tcp连接协商（握手）过程中请求证书。<br>即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥）。                 </li>\n<li>Client在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。</li>\n<li>如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。</li>\n</ol>\n<p>参考文章：<br>HTTPS介绍：<a href=\"https://imququ.com/post/how-to-decrypt-https.html\" target=\"_blank\" rel=\"noopener\">https://imququ.com/post/how-to-decrypt-https.html</a><br><a href=\"http://blog.csdn.net/hguisu/article/details/8680808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/hguisu/article/details/8680808</a></p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><p>HTTP全称叫超文本传输协议(HyperText Transfer Protocol),是用于WWW(万网)服务器与浏览器客户端的一种通讯协议</p>\n<h2 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h2><p>关于计算机通讯，需要了解的一些背景知识，TCP/IP.<br>我们经常说TCP/IP，为什么要一起说，因为这两者有着密切的关系，其实它包含两个协议：</p>\n<ul>\n<li>TCP: TCP 负责将数据包在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组</li>\n<li>IP：负责将TCP分隔的IP包发送传输到指定ip的机器上，IP包之间的传输不保证顺序性，在TCP重组时才还原数据顺序</li>\n</ul>\n<p>所以说TCP/IP是传输协议的上下层关系。</p>\n<h2 id=\"关于HTTP\"><a href=\"#关于HTTP\" class=\"headerlink\" title=\"关于HTTP\"></a>关于HTTP</h2><p>而HTTP则是在TCP/IP基础上的进一步封装的协议，属于应用层协议.网络传输的协议关系图如下：<br><img src=\"../images/HTTP%E5%8F%8AHTTPS%E7%9A%84%E7%90%86%E8%A7%A3/getImage-20220825184529465.png\" alt></p>\n<p>网络传输的协议，两边刚好是相反的:<br><img src=\"../images/HTTP%E5%8F%8AHTTPS%E7%9A%84%E7%90%86%E8%A7%A3/getImage-20220825184529221.png\" alt></p>\n<h2 id=\"HTTP原理\"><a href=\"#HTTP原理\" class=\"headerlink\" title=\"HTTP原理\"></a>HTTP原理</h2><p>HTTP请求主要分为以下几个步奏：</p>\n<ol>\n<li>域名解析，查找对应DNS服务器域名解析找到对应的IP</li>\n<li>封装TCP/IP通讯数据包，建立连接（3三次握手协议），HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接</li>\n<li>封装HTTP请求数据包，请求头信息，请求参数等。</li>\n<li>等待服务器响应，服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码</li>\n<li>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码<br> Connection:keep-alive<br>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求，这就是长连接的原理</li>\n</ol>\n<p>关于HTTP的超时时间，<code>connectTimeout</code>、<code>requestConnectTimeout</code>、<code>readTimeout</code>、<code>socketTimeout</code></p>\n<ul>\n<li><code>connectTimeout</code> 是指上面的第2步，建立TCP/IP连接的超时时间</li>\n<li><code>requestConnectTimeout</code> 是指上面第3步，发送请求头发送http请求的超时时间</li>\n<li><code>readTimeout</code> 是指从发送http请求开始等待响应内容的总超时时间,指上面步骤的第4步</li>\n<li><code>socketTimeout</code> 响应内容有可能是分成几个socket数据包传输的，而这个socketTimeout的意思就是每个socket传输的超时时间</li>\n</ul>\n<p>例如下图：<br>readTimeout设为6s,socketTimeout设为4秒，发送http报文之后响应<br>时间超时为6s,响应内容abc分三次socket传输,每次间隔超时时间为4s，所以总共花费6s是不会抛出<code>socket timeout</code><br><img src=\"../images/HTTP%E5%8F%8AHTTPS%E7%9A%84%E7%90%86%E8%A7%A3/getImage-20220825184529343.png\" alt></p>\n<h2 id=\"JAVA中使用http\"><a href=\"#JAVA中使用http\" class=\"headerlink\" title=\"JAVA中使用http\"></a>JAVA中使用http</h2><p>Java 访问http通过</p>\n<h1 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h1><p>HTTPS简单的说就是，http的安全版</p>\n<h2 id=\"HTTPS基本原理\"><a href=\"#HTTPS基本原理\" class=\"headerlink\" title=\"HTTPS基本原理\"></a>HTTPS基本原理</h2><p><img src=\"../images/HTTP%E5%8F%8AHTTPS%E7%9A%84%E7%90%86%E8%A7%A3/getImage-20220825184528912.png\" alt></p>\n<p>过程大致如下：</p>\n<ol>\n<li>SSL客户端通过TCP和服务器建立连接之后（443端口），并且在一般的tcp连接协商（握手）过程中请求证书。<br>即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥）。                 </li>\n<li>Client在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。</li>\n<li>如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。</li>\n</ol>\n<p>参考文章：<br>HTTPS介绍：<a href=\"https://imququ.com/post/how-to-decrypt-https.html\" target=\"_blank\" rel=\"noopener\">https://imququ.com/post/how-to-decrypt-https.html</a><br><a href=\"http://blog.csdn.net/hguisu/article/details/8680808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/hguisu/article/details/8680808</a></p>\n"},{"title":"关于Unicode  UTF-8 、UTF-16字符集编码的理解","date":"2020-04-30T03:25:00.000Z","author":"okeeper","_content":"\n # 最近学习NIO文件读写的时候，就生成了一个疑问，程序怎么知道文件使用了什么编码，因为底层程序看到的都是二进制的字节码如：\n```\n中文 | utf-8二进制编码\n人   | 11100100 10111010 10111010 \n```\n程序怎么知道通过这是一个通过3个字节编码的`人`字呢，于是查询了相关资料：\n\n要解释这个问题，我们先来了解下ASCII码、GB2312、GBK、Unicode编码的关系和定义\n# 1. ASSCII码,见[ASCII码对照表](http://tool.oschina.net/commons?type=4)\n是一种使用一个字节(8位二进制)表示字母、数字和字符的一种编码，如字母`A`表示为使用十进制值为`65`的表示，转换为二进制就是`1000001`,我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。\n上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。\nASCII码一共规定了128个字符的编码，比如空格\"SPACE\"是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。\n\n# 2. `GB2312` ，全称是GB2312-80《信息交换用汉字编码字符集 基本集》，是中国标准化组织发布的，见[GB2312编码规则](http://www.qqxiuzi.cn/zh/hanzi-gb2312-bianma.php)\n   在计算机只有英文的时代，可能使用`ASCII`码就已经够了，但是随着计算机的普及和全球化，别国的语言肯定也是要计算机编码化的，所以就出现了`GB2312`编码规则。`GB2312`是使用固定两个字节来表示简体中文和英文、数字、中文符号、英文符号的一种编码规则。所以如果使用`GB2312`编码时，英文也是使用两个字节来编码的，这无疑是一种浪费\n\n   而`GBK`则是在`GB23312`的基础上添加了繁体中文的扩展\n\n# 3. `Unicode`\n\n正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。\n可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。\n\n再次强调一下,Unicode只是为全世界的每一个文字符号都定义了一个数值对照\n\n# 4. `UTF-8`\n\n为什么会有`UTF-8`编码，我们来看下`Unicode`编码的定义和存在的问题：\n\n需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。\n比如，汉字\"严\"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n那么第一个问题：怎么样使用二进制的表示来存储我们的编码呢，是和GBK一样使用固定的字节来存？如果这样的话就必须以最长的字节表示为单位，那么应为字母、数字都得使用3个字节或者4个字节来存储，这显然是不能够接受的，这对存储空间是极大的浪费。\n根据第一个问题，我们是否能够使用变长的存储方式来存unicode编码呢，如果可以，怎么在读取的时候区分一个字符是使用一个字节表示（比如字母、数字），还是使用3个字节表示的中文呢？\n\n所以最初期，由于存在Unicode存在这些问题的存在\n它们造成的结果是：1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。\n2）Unicode在很长一段时间内无法推广，直到互联网的出现。\n\n我们来看下`UTF-8`是怎么实现unicode编码的。\nUTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\nUTF-8的编码规则很简单，只有二条：\n1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。\n2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。\n```\nUnicode符号范围 | UTF-8编码方式\n(十六进制) | （二进制）\n--------------------+---------------------------------------------\n0000 0000 ~ 0000 007F | 0xxxxxxx\n0000 0080 ~ 0000 07FF | 110xxxxx 10xxxxxx\n0000 0800 ~ 0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n0001 0000 ~ 0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n```\n跟据上表，解读UTF-8编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。\n下面，还是以汉字\"严\"为例，演示如何实现UTF-8编码。\n已知\"漲\"的unicode是`\\u6f32`,6f32二进制为`110111100110010`，根据上表，可以发现4E25处在第三行的范围内（0000 0800 ~ 0000 FFFF），因此\"漲\"的UTF-8编码需要三个字节，即格式是`1110xxxx 10xxxxxx 10xxxxxx`。然后，从`漲`的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，\"漲\"的UTF-8编码是1110`0110` 101`11100` 10`110010`，转换成十六进制就是`e6bcb2`。\n所以理论上讲UTF-8 可以表示2^31个字符，所以还有很多符号表情可以开发编入unicode中。\n\n*其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。*\n\n#5. 使用java打印出所有中文代码\n```\n   下标         中文    unicode          unicode十进制值           unicode二进制      utf-8编码二进制            utf-8十六进制      长度字节数\n    0          葦     \\u6f32                28466                110111100110010    11101000 10010001 10100110           e891a6          3\n    1          葧     \\u6f33                28467                110111100110011    11101000 10010001 10100111           e891a7          3\n    2          葨     \\u6f34                28468                110111100110100    11101000 10010001 10101000           e891a8          3\n    3          葩     \\u6f35                28469                110111100110101    11101000 10010001 10101001           e891a9          3\n    4          葰     \\u6f36                28470                110111100110110    11101000 10010001 10110000           e891b0          3\n    5          葱     \\u6f37                28471                110111100110111    11101000 10010001 10110001           e891b1          3\n    6          葲     \\u6f38                28472                110111100111000    11101000 10010001 10110010           e891b2          3\n    7          葳     \\u6f39                28473                110111100111001    11101000 10010001 10110011           e891b3          3\n    8          葴     \\u6f3a                28474                110111100111010    11101000 10010001 10110100           e891b4          3\n    9          葵     \\u6f3b                28475                110111100111011    11101000 10010001 10110101           e891b5          3\n```\n\njava代码如下：\n```\n  @Test\n    public void writeAllChinese() {\n        int start = 0x6f32;\n        int index = 0;\n\n        System.out.printf(\"%5s %10s %10s %20s %20s %15s %20s %10s\\n\",\"下标\",\"中文\" ,\"unicode\" ,\"unicode十进制值\" ,\"unicode二进制\" , \"utf-8编码二进制\", \"utf-8十六进制\" ,\"长度字节数\");\n        while (start < 0x6f32 + 10) {\n            String unicode = \"\\\\u\" + Integer.toHexString(start);\n            char c = (char) Integer.parseInt((start+\"\"),16);\n            String chinese = String.valueOf(c);\n\n            byte[] bytes = chinese.getBytes();\n            System.out.printf(\"%5s %10s %10s %20s %30s %30s %15s %10s\\n\",index,chinese ,unicode ,start ,Integer.toBinaryString(start) , getBinaryString(bytes), Integer.toHexString(Integer.valueOf(getBinaryString(bytes).replace(\" \",\"\"),2)) ,bytes.length);\n            start++;\n            index++;\n        }\n    }\n\n    public static String getBinaryString(byte bytes[]) {\n        String s = \"\";\n        for(byte b : bytes) {\n            /**\n             * 由于java 虚拟机为了方便整数的加减，使用了补码(反码+1)来表示,方便数值的符号直接参与二进制的加减，这样省去了很多计算步骤\n             * 所以在java中使用String#getBytes()返回的字节数值是反码的表示方法；\n             * 又由于Int 在java中表示是4个字节32位的，在控制台进行输出的时候，jvm把11001111之前进行了补补全然后再取补码，等到的就是11111111111111111111111110111110\n             * 所以需要在使用 与 运算将取 反码  0xff = 11111111\n             */\n            s = s + Integer.toBinaryString(b & 0xff) +  \" \";\n            //s = s + Integer.toBinaryString(b) +  \" \";\n        }\n        return s;\n    }\n```","source":"_posts/学习/关于Unicode  UTF-8 、UTF-16字符集编码的理解.md","raw":"---\ntitle: 关于Unicode  UTF-8 、UTF-16字符集编码的理解\ndate: 2020-4-30 11:25:00\nauthor: okeeper\ncategories: 学习\ntags:\n  - Unicode\n  - 字符集\n  - 学习\n---\n\n # 最近学习NIO文件读写的时候，就生成了一个疑问，程序怎么知道文件使用了什么编码，因为底层程序看到的都是二进制的字节码如：\n```\n中文 | utf-8二进制编码\n人   | 11100100 10111010 10111010 \n```\n程序怎么知道通过这是一个通过3个字节编码的`人`字呢，于是查询了相关资料：\n\n要解释这个问题，我们先来了解下ASCII码、GB2312、GBK、Unicode编码的关系和定义\n# 1. ASSCII码,见[ASCII码对照表](http://tool.oschina.net/commons?type=4)\n是一种使用一个字节(8位二进制)表示字母、数字和字符的一种编码，如字母`A`表示为使用十进制值为`65`的表示，转换为二进制就是`1000001`,我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。\n上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。\nASCII码一共规定了128个字符的编码，比如空格\"SPACE\"是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。\n\n# 2. `GB2312` ，全称是GB2312-80《信息交换用汉字编码字符集 基本集》，是中国标准化组织发布的，见[GB2312编码规则](http://www.qqxiuzi.cn/zh/hanzi-gb2312-bianma.php)\n   在计算机只有英文的时代，可能使用`ASCII`码就已经够了，但是随着计算机的普及和全球化，别国的语言肯定也是要计算机编码化的，所以就出现了`GB2312`编码规则。`GB2312`是使用固定两个字节来表示简体中文和英文、数字、中文符号、英文符号的一种编码规则。所以如果使用`GB2312`编码时，英文也是使用两个字节来编码的，这无疑是一种浪费\n\n   而`GBK`则是在`GB23312`的基础上添加了繁体中文的扩展\n\n# 3. `Unicode`\n\n正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。\n可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。\n\n再次强调一下,Unicode只是为全世界的每一个文字符号都定义了一个数值对照\n\n# 4. `UTF-8`\n\n为什么会有`UTF-8`编码，我们来看下`Unicode`编码的定义和存在的问题：\n\n需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。\n比如，汉字\"严\"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n那么第一个问题：怎么样使用二进制的表示来存储我们的编码呢，是和GBK一样使用固定的字节来存？如果这样的话就必须以最长的字节表示为单位，那么应为字母、数字都得使用3个字节或者4个字节来存储，这显然是不能够接受的，这对存储空间是极大的浪费。\n根据第一个问题，我们是否能够使用变长的存储方式来存unicode编码呢，如果可以，怎么在读取的时候区分一个字符是使用一个字节表示（比如字母、数字），还是使用3个字节表示的中文呢？\n\n所以最初期，由于存在Unicode存在这些问题的存在\n它们造成的结果是：1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。\n2）Unicode在很长一段时间内无法推广，直到互联网的出现。\n\n我们来看下`UTF-8`是怎么实现unicode编码的。\nUTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\nUTF-8的编码规则很简单，只有二条：\n1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。\n2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。\n```\nUnicode符号范围 | UTF-8编码方式\n(十六进制) | （二进制）\n--------------------+---------------------------------------------\n0000 0000 ~ 0000 007F | 0xxxxxxx\n0000 0080 ~ 0000 07FF | 110xxxxx 10xxxxxx\n0000 0800 ~ 0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n0001 0000 ~ 0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n```\n跟据上表，解读UTF-8编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。\n下面，还是以汉字\"严\"为例，演示如何实现UTF-8编码。\n已知\"漲\"的unicode是`\\u6f32`,6f32二进制为`110111100110010`，根据上表，可以发现4E25处在第三行的范围内（0000 0800 ~ 0000 FFFF），因此\"漲\"的UTF-8编码需要三个字节，即格式是`1110xxxx 10xxxxxx 10xxxxxx`。然后，从`漲`的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，\"漲\"的UTF-8编码是1110`0110` 101`11100` 10`110010`，转换成十六进制就是`e6bcb2`。\n所以理论上讲UTF-8 可以表示2^31个字符，所以还有很多符号表情可以开发编入unicode中。\n\n*其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。*\n\n#5. 使用java打印出所有中文代码\n```\n   下标         中文    unicode          unicode十进制值           unicode二进制      utf-8编码二进制            utf-8十六进制      长度字节数\n    0          葦     \\u6f32                28466                110111100110010    11101000 10010001 10100110           e891a6          3\n    1          葧     \\u6f33                28467                110111100110011    11101000 10010001 10100111           e891a7          3\n    2          葨     \\u6f34                28468                110111100110100    11101000 10010001 10101000           e891a8          3\n    3          葩     \\u6f35                28469                110111100110101    11101000 10010001 10101001           e891a9          3\n    4          葰     \\u6f36                28470                110111100110110    11101000 10010001 10110000           e891b0          3\n    5          葱     \\u6f37                28471                110111100110111    11101000 10010001 10110001           e891b1          3\n    6          葲     \\u6f38                28472                110111100111000    11101000 10010001 10110010           e891b2          3\n    7          葳     \\u6f39                28473                110111100111001    11101000 10010001 10110011           e891b3          3\n    8          葴     \\u6f3a                28474                110111100111010    11101000 10010001 10110100           e891b4          3\n    9          葵     \\u6f3b                28475                110111100111011    11101000 10010001 10110101           e891b5          3\n```\n\njava代码如下：\n```\n  @Test\n    public void writeAllChinese() {\n        int start = 0x6f32;\n        int index = 0;\n\n        System.out.printf(\"%5s %10s %10s %20s %20s %15s %20s %10s\\n\",\"下标\",\"中文\" ,\"unicode\" ,\"unicode十进制值\" ,\"unicode二进制\" , \"utf-8编码二进制\", \"utf-8十六进制\" ,\"长度字节数\");\n        while (start < 0x6f32 + 10) {\n            String unicode = \"\\\\u\" + Integer.toHexString(start);\n            char c = (char) Integer.parseInt((start+\"\"),16);\n            String chinese = String.valueOf(c);\n\n            byte[] bytes = chinese.getBytes();\n            System.out.printf(\"%5s %10s %10s %20s %30s %30s %15s %10s\\n\",index,chinese ,unicode ,start ,Integer.toBinaryString(start) , getBinaryString(bytes), Integer.toHexString(Integer.valueOf(getBinaryString(bytes).replace(\" \",\"\"),2)) ,bytes.length);\n            start++;\n            index++;\n        }\n    }\n\n    public static String getBinaryString(byte bytes[]) {\n        String s = \"\";\n        for(byte b : bytes) {\n            /**\n             * 由于java 虚拟机为了方便整数的加减，使用了补码(反码+1)来表示,方便数值的符号直接参与二进制的加减，这样省去了很多计算步骤\n             * 所以在java中使用String#getBytes()返回的字节数值是反码的表示方法；\n             * 又由于Int 在java中表示是4个字节32位的，在控制台进行输出的时候，jvm把11001111之前进行了补补全然后再取补码，等到的就是11111111111111111111111110111110\n             * 所以需要在使用 与 运算将取 反码  0xff = 11111111\n             */\n            s = s + Integer.toBinaryString(b & 0xff) +  \" \";\n            //s = s + Integer.toBinaryString(b) +  \" \";\n        }\n        return s;\n    }\n```","slug":"学习/关于Unicode  UTF-8 、UTF-16字符集编码的理解","published":1,"updated":"2022-08-25T11:05:03.809Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczj3001rvwm1kft0xvhm","content":"<h1 id=\"最近学习NIO文件读写的时候，就生成了一个疑问，程序怎么知道文件使用了什么编码，因为底层程序看到的都是二进制的字节码如：\"><a href=\"#最近学习NIO文件读写的时候，就生成了一个疑问，程序怎么知道文件使用了什么编码，因为底层程序看到的都是二进制的字节码如：\" class=\"headerlink\" title=\"最近学习NIO文件读写的时候，就生成了一个疑问，程序怎么知道文件使用了什么编码，因为底层程序看到的都是二进制的字节码如：\"></a>最近学习NIO文件读写的时候，就生成了一个疑问，程序怎么知道文件使用了什么编码，因为底层程序看到的都是二进制的字节码如：</h1><pre><code>中文 | utf-8二进制编码\n人   | 11100100 10111010 10111010 </code></pre><p>程序怎么知道通过这是一个通过3个字节编码的<code>人</code>字呢，于是查询了相关资料：</p>\n<p>要解释这个问题，我们先来了解下ASCII码、GB2312、GBK、Unicode编码的关系和定义</p>\n<h1 id=\"1-ASSCII码-见ASCII码对照表\"><a href=\"#1-ASSCII码-见ASCII码对照表\" class=\"headerlink\" title=\"1. ASSCII码,见ASCII码对照表\"></a>1. ASSCII码,见<a href=\"http://tool.oschina.net/commons?type=4\" target=\"_blank\" rel=\"noopener\">ASCII码对照表</a></h1><p>是一种使用一个字节(8位二进制)表示字母、数字和字符的一种编码，如字母<code>A</code>表示为使用十进制值为<code>65</code>的表示，转换为二进制就是<code>1000001</code>,我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。<br>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。<br>ASCII码一共规定了128个字符的编码，比如空格”SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。</p>\n<h1 id=\"2-GB2312-，全称是GB2312-80《信息交换用汉字编码字符集-基本集》，是中国标准化组织发布的，见GB2312编码规则\"><a href=\"#2-GB2312-，全称是GB2312-80《信息交换用汉字编码字符集-基本集》，是中国标准化组织发布的，见GB2312编码规则\" class=\"headerlink\" title=\"2. GB2312 ，全称是GB2312-80《信息交换用汉字编码字符集 基本集》，是中国标准化组织发布的，见GB2312编码规则\"></a>2. <code>GB2312</code> ，全称是GB2312-80《信息交换用汉字编码字符集 基本集》，是中国标准化组织发布的，见<a href=\"http://www.qqxiuzi.cn/zh/hanzi-gb2312-bianma.php\" target=\"_blank\" rel=\"noopener\">GB2312编码规则</a></h1><p>   在计算机只有英文的时代，可能使用<code>ASCII</code>码就已经够了，但是随着计算机的普及和全球化，别国的语言肯定也是要计算机编码化的，所以就出现了<code>GB2312</code>编码规则。<code>GB2312</code>是使用固定两个字节来表示简体中文和英文、数字、中文符号、英文符号的一种编码规则。所以如果使用<code>GB2312</code>编码时，英文也是使用两个字节来编码的，这无疑是一种浪费</p>\n<p>   而<code>GBK</code>则是在<code>GB23312</code>的基础上添加了繁体中文的扩展</p>\n<h1 id=\"3-Unicode\"><a href=\"#3-Unicode\" class=\"headerlink\" title=\"3. Unicode\"></a>3. <code>Unicode</code></h1><p>正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。<br>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p>\n<p>再次强调一下,Unicode只是为全世界的每一个文字符号都定义了一个数值对照</p>\n<h1 id=\"4-UTF-8\"><a href=\"#4-UTF-8\" class=\"headerlink\" title=\"4. UTF-8\"></a>4. <code>UTF-8</code></h1><p>为什么会有<code>UTF-8</code>编码，我们来看下<code>Unicode</code>编码的定义和存在的问题：</p>\n<p>需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。<br>比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。<br>那么第一个问题：怎么样使用二进制的表示来存储我们的编码呢，是和GBK一样使用固定的字节来存？如果这样的话就必须以最长的字节表示为单位，那么应为字母、数字都得使用3个字节或者4个字节来存储，这显然是不能够接受的，这对存储空间是极大的浪费。<br>根据第一个问题，我们是否能够使用变长的存储方式来存unicode编码呢，如果可以，怎么在读取的时候区分一个字符是使用一个字节表示（比如字母、数字），还是使用3个字节表示的中文呢？</p>\n<p>所以最初期，由于存在Unicode存在这些问题的存在<br>它们造成的结果是：1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。<br>2）Unicode在很长一段时间内无法推广，直到互联网的出现。</p>\n<p>我们来看下<code>UTF-8</code>是怎么实现unicode编码的。<br>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。<br>UTF-8的编码规则很简单，只有二条：<br>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。<br>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>\n<pre><code>Unicode符号范围 | UTF-8编码方式\n(十六进制) | （二进制）\n--------------------+---------------------------------------------\n0000 0000 ~ 0000 007F | 0xxxxxxx\n0000 0080 ~ 0000 07FF | 110xxxxx 10xxxxxx\n0000 0800 ~ 0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n0001 0000 ~ 0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code></pre><p>跟据上表，解读UTF-8编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。<br>下面，还是以汉字”严”为例，演示如何实现UTF-8编码。<br>已知”漲”的unicode是<code>\\u6f32</code>,6f32二进制为<code>110111100110010</code>，根据上表，可以发现4E25处在第三行的范围内（0000 0800 ~ 0000 FFFF），因此”漲”的UTF-8编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>漲</code>的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”漲”的UTF-8编码是1110<code>0110</code> 101<code>11100</code> 10<code>110010</code>，转换成十六进制就是<code>e6bcb2</code>。<br>所以理论上讲UTF-8 可以表示2^31个字符，所以还有很多符号表情可以开发编入unicode中。</p>\n<p><em>其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。</em></p>\n<p>#5. 使用java打印出所有中文代码</p>\n<pre><code>   下标         中文    unicode          unicode十进制值           unicode二进制      utf-8编码二进制            utf-8十六进制      长度字节数\n    0          葦     \\u6f32                28466                110111100110010    11101000 10010001 10100110           e891a6          3\n    1          葧     \\u6f33                28467                110111100110011    11101000 10010001 10100111           e891a7          3\n    2          葨     \\u6f34                28468                110111100110100    11101000 10010001 10101000           e891a8          3\n    3          葩     \\u6f35                28469                110111100110101    11101000 10010001 10101001           e891a9          3\n    4          葰     \\u6f36                28470                110111100110110    11101000 10010001 10110000           e891b0          3\n    5          葱     \\u6f37                28471                110111100110111    11101000 10010001 10110001           e891b1          3\n    6          葲     \\u6f38                28472                110111100111000    11101000 10010001 10110010           e891b2          3\n    7          葳     \\u6f39                28473                110111100111001    11101000 10010001 10110011           e891b3          3\n    8          葴     \\u6f3a                28474                110111100111010    11101000 10010001 10110100           e891b4          3\n    9          葵     \\u6f3b                28475                110111100111011    11101000 10010001 10110101           e891b5          3</code></pre><p>java代码如下：</p>\n<pre><code>  @Test\n    public void writeAllChinese() {\n        int start = 0x6f32;\n        int index = 0;\n\n        System.out.printf(&quot;%5s %10s %10s %20s %20s %15s %20s %10s\\n&quot;,&quot;下标&quot;,&quot;中文&quot; ,&quot;unicode&quot; ,&quot;unicode十进制值&quot; ,&quot;unicode二进制&quot; , &quot;utf-8编码二进制&quot;, &quot;utf-8十六进制&quot; ,&quot;长度字节数&quot;);\n        while (start &lt; 0x6f32 + 10) {\n            String unicode = &quot;\\\\u&quot; + Integer.toHexString(start);\n            char c = (char) Integer.parseInt((start+&quot;&quot;),16);\n            String chinese = String.valueOf(c);\n\n            byte[] bytes = chinese.getBytes();\n            System.out.printf(&quot;%5s %10s %10s %20s %30s %30s %15s %10s\\n&quot;,index,chinese ,unicode ,start ,Integer.toBinaryString(start) , getBinaryString(bytes), Integer.toHexString(Integer.valueOf(getBinaryString(bytes).replace(&quot; &quot;,&quot;&quot;),2)) ,bytes.length);\n            start++;\n            index++;\n        }\n    }\n\n    public static String getBinaryString(byte bytes[]) {\n        String s = &quot;&quot;;\n        for(byte b : bytes) {\n            /**\n             * 由于java 虚拟机为了方便整数的加减，使用了补码(反码+1)来表示,方便数值的符号直接参与二进制的加减，这样省去了很多计算步骤\n             * 所以在java中使用String#getBytes()返回的字节数值是反码的表示方法；\n             * 又由于Int 在java中表示是4个字节32位的，在控制台进行输出的时候，jvm把11001111之前进行了补补全然后再取补码，等到的就是11111111111111111111111110111110\n             * 所以需要在使用 与 运算将取 反码  0xff = 11111111\n             */\n            s = s + Integer.toBinaryString(b &amp; 0xff) +  &quot; &quot;;\n            //s = s + Integer.toBinaryString(b) +  &quot; &quot;;\n        }\n        return s;\n    }</code></pre>","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"最近学习NIO文件读写的时候，就生成了一个疑问，程序怎么知道文件使用了什么编码，因为底层程序看到的都是二进制的字节码如：\"><a href=\"#最近学习NIO文件读写的时候，就生成了一个疑问，程序怎么知道文件使用了什么编码，因为底层程序看到的都是二进制的字节码如：\" class=\"headerlink\" title=\"最近学习NIO文件读写的时候，就生成了一个疑问，程序怎么知道文件使用了什么编码，因为底层程序看到的都是二进制的字节码如：\"></a>最近学习NIO文件读写的时候，就生成了一个疑问，程序怎么知道文件使用了什么编码，因为底层程序看到的都是二进制的字节码如：</h1><pre><code>中文 | utf-8二进制编码\n人   | 11100100 10111010 10111010 </code></pre><p>程序怎么知道通过这是一个通过3个字节编码的<code>人</code>字呢，于是查询了相关资料：</p>\n<p>要解释这个问题，我们先来了解下ASCII码、GB2312、GBK、Unicode编码的关系和定义</p>\n<h1 id=\"1-ASSCII码-见ASCII码对照表\"><a href=\"#1-ASSCII码-见ASCII码对照表\" class=\"headerlink\" title=\"1. ASSCII码,见ASCII码对照表\"></a>1. ASSCII码,见<a href=\"http://tool.oschina.net/commons?type=4\" target=\"_blank\" rel=\"noopener\">ASCII码对照表</a></h1><p>是一种使用一个字节(8位二进制)表示字母、数字和字符的一种编码，如字母<code>A</code>表示为使用十进制值为<code>65</code>的表示，转换为二进制就是<code>1000001</code>,我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。<br>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。<br>ASCII码一共规定了128个字符的编码，比如空格”SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。</p>\n<h1 id=\"2-GB2312-，全称是GB2312-80《信息交换用汉字编码字符集-基本集》，是中国标准化组织发布的，见GB2312编码规则\"><a href=\"#2-GB2312-，全称是GB2312-80《信息交换用汉字编码字符集-基本集》，是中国标准化组织发布的，见GB2312编码规则\" class=\"headerlink\" title=\"2. GB2312 ，全称是GB2312-80《信息交换用汉字编码字符集 基本集》，是中国标准化组织发布的，见GB2312编码规则\"></a>2. <code>GB2312</code> ，全称是GB2312-80《信息交换用汉字编码字符集 基本集》，是中国标准化组织发布的，见<a href=\"http://www.qqxiuzi.cn/zh/hanzi-gb2312-bianma.php\" target=\"_blank\" rel=\"noopener\">GB2312编码规则</a></h1><p>   在计算机只有英文的时代，可能使用<code>ASCII</code>码就已经够了，但是随着计算机的普及和全球化，别国的语言肯定也是要计算机编码化的，所以就出现了<code>GB2312</code>编码规则。<code>GB2312</code>是使用固定两个字节来表示简体中文和英文、数字、中文符号、英文符号的一种编码规则。所以如果使用<code>GB2312</code>编码时，英文也是使用两个字节来编码的，这无疑是一种浪费</p>\n<p>   而<code>GBK</code>则是在<code>GB23312</code>的基础上添加了繁体中文的扩展</p>\n<h1 id=\"3-Unicode\"><a href=\"#3-Unicode\" class=\"headerlink\" title=\"3. Unicode\"></a>3. <code>Unicode</code></h1><p>正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。<br>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p>\n<p>再次强调一下,Unicode只是为全世界的每一个文字符号都定义了一个数值对照</p>\n<h1 id=\"4-UTF-8\"><a href=\"#4-UTF-8\" class=\"headerlink\" title=\"4. UTF-8\"></a>4. <code>UTF-8</code></h1><p>为什么会有<code>UTF-8</code>编码，我们来看下<code>Unicode</code>编码的定义和存在的问题：</p>\n<p>需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。<br>比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。<br>那么第一个问题：怎么样使用二进制的表示来存储我们的编码呢，是和GBK一样使用固定的字节来存？如果这样的话就必须以最长的字节表示为单位，那么应为字母、数字都得使用3个字节或者4个字节来存储，这显然是不能够接受的，这对存储空间是极大的浪费。<br>根据第一个问题，我们是否能够使用变长的存储方式来存unicode编码呢，如果可以，怎么在读取的时候区分一个字符是使用一个字节表示（比如字母、数字），还是使用3个字节表示的中文呢？</p>\n<p>所以最初期，由于存在Unicode存在这些问题的存在<br>它们造成的结果是：1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。<br>2）Unicode在很长一段时间内无法推广，直到互联网的出现。</p>\n<p>我们来看下<code>UTF-8</code>是怎么实现unicode编码的。<br>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。<br>UTF-8的编码规则很简单，只有二条：<br>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。<br>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>\n<pre><code>Unicode符号范围 | UTF-8编码方式\n(十六进制) | （二进制）\n--------------------+---------------------------------------------\n0000 0000 ~ 0000 007F | 0xxxxxxx\n0000 0080 ~ 0000 07FF | 110xxxxx 10xxxxxx\n0000 0800 ~ 0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n0001 0000 ~ 0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code></pre><p>跟据上表，解读UTF-8编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。<br>下面，还是以汉字”严”为例，演示如何实现UTF-8编码。<br>已知”漲”的unicode是<code>\\u6f32</code>,6f32二进制为<code>110111100110010</code>，根据上表，可以发现4E25处在第三行的范围内（0000 0800 ~ 0000 FFFF），因此”漲”的UTF-8编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>漲</code>的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”漲”的UTF-8编码是1110<code>0110</code> 101<code>11100</code> 10<code>110010</code>，转换成十六进制就是<code>e6bcb2</code>。<br>所以理论上讲UTF-8 可以表示2^31个字符，所以还有很多符号表情可以开发编入unicode中。</p>\n<p><em>其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。</em></p>\n<p>#5. 使用java打印出所有中文代码</p>\n<pre><code>   下标         中文    unicode          unicode十进制值           unicode二进制      utf-8编码二进制            utf-8十六进制      长度字节数\n    0          葦     \\u6f32                28466                110111100110010    11101000 10010001 10100110           e891a6          3\n    1          葧     \\u6f33                28467                110111100110011    11101000 10010001 10100111           e891a7          3\n    2          葨     \\u6f34                28468                110111100110100    11101000 10010001 10101000           e891a8          3\n    3          葩     \\u6f35                28469                110111100110101    11101000 10010001 10101001           e891a9          3\n    4          葰     \\u6f36                28470                110111100110110    11101000 10010001 10110000           e891b0          3\n    5          葱     \\u6f37                28471                110111100110111    11101000 10010001 10110001           e891b1          3\n    6          葲     \\u6f38                28472                110111100111000    11101000 10010001 10110010           e891b2          3\n    7          葳     \\u6f39                28473                110111100111001    11101000 10010001 10110011           e891b3          3\n    8          葴     \\u6f3a                28474                110111100111010    11101000 10010001 10110100           e891b4          3\n    9          葵     \\u6f3b                28475                110111100111011    11101000 10010001 10110101           e891b5          3</code></pre><p>java代码如下：</p>\n<pre><code>  @Test\n    public void writeAllChinese() {\n        int start = 0x6f32;\n        int index = 0;\n\n        System.out.printf(&quot;%5s %10s %10s %20s %20s %15s %20s %10s\\n&quot;,&quot;下标&quot;,&quot;中文&quot; ,&quot;unicode&quot; ,&quot;unicode十进制值&quot; ,&quot;unicode二进制&quot; , &quot;utf-8编码二进制&quot;, &quot;utf-8十六进制&quot; ,&quot;长度字节数&quot;);\n        while (start &lt; 0x6f32 + 10) {\n            String unicode = &quot;\\\\u&quot; + Integer.toHexString(start);\n            char c = (char) Integer.parseInt((start+&quot;&quot;),16);\n            String chinese = String.valueOf(c);\n\n            byte[] bytes = chinese.getBytes();\n            System.out.printf(&quot;%5s %10s %10s %20s %30s %30s %15s %10s\\n&quot;,index,chinese ,unicode ,start ,Integer.toBinaryString(start) , getBinaryString(bytes), Integer.toHexString(Integer.valueOf(getBinaryString(bytes).replace(&quot; &quot;,&quot;&quot;),2)) ,bytes.length);\n            start++;\n            index++;\n        }\n    }\n\n    public static String getBinaryString(byte bytes[]) {\n        String s = &quot;&quot;;\n        for(byte b : bytes) {\n            /**\n             * 由于java 虚拟机为了方便整数的加减，使用了补码(反码+1)来表示,方便数值的符号直接参与二进制的加减，这样省去了很多计算步骤\n             * 所以在java中使用String#getBytes()返回的字节数值是反码的表示方法；\n             * 又由于Int 在java中表示是4个字节32位的，在控制台进行输出的时候，jvm把11001111之前进行了补补全然后再取补码，等到的就是11111111111111111111111110111110\n             * 所以需要在使用 与 运算将取 反码  0xff = 11111111\n             */\n            s = s + Integer.toBinaryString(b &amp; 0xff) +  &quot; &quot;;\n            //s = s + Integer.toBinaryString(b) +  &quot; &quot;;\n        }\n        return s;\n    }</code></pre>"},{"_content":"默认idea 是已经安装好了maven插件的，在File>settings>能搜索到maven的相关配置\n但是有时候它会莫名其妙的不见了或消失\n检查Plugins是否启用了maven\n![](../images/Idea maven 插件安装/getImage-20220825183122891.png)","source":"_posts/软件笔记/Idea maven 插件安装.md","raw":"默认idea 是已经安装好了maven插件的，在File>settings>能搜索到maven的相关配置\n但是有时候它会莫名其妙的不见了或消失\n检查Plugins是否启用了maven\n![](../images/Idea maven 插件安装/getImage-20220825183122891.png)","slug":"软件笔记/Idea maven 插件安装","published":1,"date":"2022-08-25T10:31:00.007Z","updated":"2022-08-25T10:31:24.183Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczj4001wvwm1jbu10fp6","content":"<p>默认idea 是已经安装好了maven插件的，在File&gt;settings&gt;能搜索到maven的相关配置<br>但是有时候它会莫名其妙的不见了或消失<br>检查Plugins是否启用了maven<br>![](../images/Idea maven 插件安装/getImage-20220825183122891.png)</p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<p>默认idea 是已经安装好了maven插件的，在File&gt;settings&gt;能搜索到maven的相关配置<br>但是有时候它会莫名其妙的不见了或消失<br>检查Plugins是否启用了maven<br>![](../images/Idea maven 插件安装/getImage-20220825183122891.png)</p>\n"},{"_content":"# 1. List转Map\n\n```\n/**\n * List -> Map\n * 需要注意的是：\n * toMap 如果集合对象有重复的key，会报错Duplicate key ....\n *  apple1,apple12的id都为1。\n *  可以用 (k1,k2)->k1 来设置，如果有重复的key,则保留key1,舍弃key2\n */\nMap<Integer, Apple> appleMap = appleList.stream().collect(Collectors.toMap(Apple::getId, a -> a,(k1,k2)->k1));\n```\n\n# List分组成Map\n\n```\n//List 以ID分组 Map<Integer,List<Apple>>\nMap<Integer, List<Apple>> groupBy = appleList.stream().collect(Collectors.groupingBy(Apple::getId));\n \nSystem.err.println(\"groupBy:\"+groupBy);\n{1=[Apple{id=1, name='苹果1', money=3.25, num=10}, Apple{id=1, name='苹果2', money=1.35, num=20}], 2=[Apple{id=2, name='香蕉', money=2.89, num=30}], 3=[Apple{id=3, name='荔枝', money=9.99, num=40}]}\n\n```\n\n# 3. Map转List\n\n```\nList<Long> skuIdList = order.getItemList().stream().map(OrderItemDTO::getSkuId).collect(Collectors.toList());\n```\n\n# 4. 统计求和\n\n```\n\n//计算 总金额\nBigDecimal totalMoney = appleList.stream().map(Apple::getMoney).reduce(BigDecimal.ZERO, BigDecimal::add);\nSystem.err.println(\"totalMoney:\"+totalMoney);  //totalMoney:17.48\n```\n\n# 5. 最大值、最小值\n\n```\n\nOptional<Dish> maxDish = Dish.menu.stream().\n      collect(Collectors.maxBy(Comparator.comparing(Dish::getCalories)));\nmaxDish.ifPresent(System.out::println);\n \nOptional<Dish> minDish = Dish.menu.stream().\n      collect(Collectors.minBy(Comparator.comparing(Dish::getCalories)));\n\n```\n\n\n# 6. 过滤Map\n\n```\n//Map -> Stream -> Filter -> MAP\n\tMap<Integer, String> collect = map.entrySet().stream()\n\t\t.filter(x -> x.getKey() == 2)\n\t\t.collect(Collectors.toMap(x -> x.getKey(), x -> x.getValue()));\n```","source":"_posts/软件笔记/Java 8常用转换.md","raw":"# 1. List转Map\n\n```\n/**\n * List -> Map\n * 需要注意的是：\n * toMap 如果集合对象有重复的key，会报错Duplicate key ....\n *  apple1,apple12的id都为1。\n *  可以用 (k1,k2)->k1 来设置，如果有重复的key,则保留key1,舍弃key2\n */\nMap<Integer, Apple> appleMap = appleList.stream().collect(Collectors.toMap(Apple::getId, a -> a,(k1,k2)->k1));\n```\n\n# List分组成Map\n\n```\n//List 以ID分组 Map<Integer,List<Apple>>\nMap<Integer, List<Apple>> groupBy = appleList.stream().collect(Collectors.groupingBy(Apple::getId));\n \nSystem.err.println(\"groupBy:\"+groupBy);\n{1=[Apple{id=1, name='苹果1', money=3.25, num=10}, Apple{id=1, name='苹果2', money=1.35, num=20}], 2=[Apple{id=2, name='香蕉', money=2.89, num=30}], 3=[Apple{id=3, name='荔枝', money=9.99, num=40}]}\n\n```\n\n# 3. Map转List\n\n```\nList<Long> skuIdList = order.getItemList().stream().map(OrderItemDTO::getSkuId).collect(Collectors.toList());\n```\n\n# 4. 统计求和\n\n```\n\n//计算 总金额\nBigDecimal totalMoney = appleList.stream().map(Apple::getMoney).reduce(BigDecimal.ZERO, BigDecimal::add);\nSystem.err.println(\"totalMoney:\"+totalMoney);  //totalMoney:17.48\n```\n\n# 5. 最大值、最小值\n\n```\n\nOptional<Dish> maxDish = Dish.menu.stream().\n      collect(Collectors.maxBy(Comparator.comparing(Dish::getCalories)));\nmaxDish.ifPresent(System.out::println);\n \nOptional<Dish> minDish = Dish.menu.stream().\n      collect(Collectors.minBy(Comparator.comparing(Dish::getCalories)));\n\n```\n\n\n# 6. 过滤Map\n\n```\n//Map -> Stream -> Filter -> MAP\n\tMap<Integer, String> collect = map.entrySet().stream()\n\t\t.filter(x -> x.getKey() == 2)\n\t\t.collect(Collectors.toMap(x -> x.getKey(), x -> x.getValue()));\n```","slug":"软件笔记/Java 8常用转换","published":1,"date":"2022-08-25T10:39:33.482Z","updated":"2022-08-25T10:39:41.333Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczj6001zvwm1hw1tfpi4","content":"<h1 id=\"1-List转Map\"><a href=\"#1-List转Map\" class=\"headerlink\" title=\"1. List转Map\"></a>1. List转Map</h1><pre><code>/**\n * List -&gt; Map\n * 需要注意的是：\n * toMap 如果集合对象有重复的key，会报错Duplicate key ....\n *  apple1,apple12的id都为1。\n *  可以用 (k1,k2)-&gt;k1 来设置，如果有重复的key,则保留key1,舍弃key2\n */\nMap&lt;Integer, Apple&gt; appleMap = appleList.stream().collect(Collectors.toMap(Apple::getId, a -&gt; a,(k1,k2)-&gt;k1));</code></pre><h1 id=\"List分组成Map\"><a href=\"#List分组成Map\" class=\"headerlink\" title=\"List分组成Map\"></a>List分组成Map</h1><pre><code>//List 以ID分组 Map&lt;Integer,List&lt;Apple&gt;&gt;\nMap&lt;Integer, List&lt;Apple&gt;&gt; groupBy = appleList.stream().collect(Collectors.groupingBy(Apple::getId));\n\nSystem.err.println(&quot;groupBy:&quot;+groupBy);\n{1=[Apple{id=1, name=&#39;苹果1&#39;, money=3.25, num=10}, Apple{id=1, name=&#39;苹果2&#39;, money=1.35, num=20}], 2=[Apple{id=2, name=&#39;香蕉&#39;, money=2.89, num=30}], 3=[Apple{id=3, name=&#39;荔枝&#39;, money=9.99, num=40}]}\n</code></pre><h1 id=\"3-Map转List\"><a href=\"#3-Map转List\" class=\"headerlink\" title=\"3. Map转List\"></a>3. Map转List</h1><pre><code>List&lt;Long&gt; skuIdList = order.getItemList().stream().map(OrderItemDTO::getSkuId).collect(Collectors.toList());</code></pre><h1 id=\"4-统计求和\"><a href=\"#4-统计求和\" class=\"headerlink\" title=\"4. 统计求和\"></a>4. 统计求和</h1><pre><code>\n//计算 总金额\nBigDecimal totalMoney = appleList.stream().map(Apple::getMoney).reduce(BigDecimal.ZERO, BigDecimal::add);\nSystem.err.println(&quot;totalMoney:&quot;+totalMoney);  //totalMoney:17.48</code></pre><h1 id=\"5-最大值、最小值\"><a href=\"#5-最大值、最小值\" class=\"headerlink\" title=\"5. 最大值、最小值\"></a>5. 最大值、最小值</h1><pre><code>\nOptional&lt;Dish&gt; maxDish = Dish.menu.stream().\n      collect(Collectors.maxBy(Comparator.comparing(Dish::getCalories)));\nmaxDish.ifPresent(System.out::println);\n\nOptional&lt;Dish&gt; minDish = Dish.menu.stream().\n      collect(Collectors.minBy(Comparator.comparing(Dish::getCalories)));\n</code></pre><h1 id=\"6-过滤Map\"><a href=\"#6-过滤Map\" class=\"headerlink\" title=\"6. 过滤Map\"></a>6. 过滤Map</h1><pre><code>//Map -&gt; Stream -&gt; Filter -&gt; MAP\n    Map&lt;Integer, String&gt; collect = map.entrySet().stream()\n        .filter(x -&gt; x.getKey() == 2)\n        .collect(Collectors.toMap(x -&gt; x.getKey(), x -&gt; x.getValue()));</code></pre>","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"1-List转Map\"><a href=\"#1-List转Map\" class=\"headerlink\" title=\"1. List转Map\"></a>1. List转Map</h1><pre><code>/**\n * List -&gt; Map\n * 需要注意的是：\n * toMap 如果集合对象有重复的key，会报错Duplicate key ....\n *  apple1,apple12的id都为1。\n *  可以用 (k1,k2)-&gt;k1 来设置，如果有重复的key,则保留key1,舍弃key2\n */\nMap&lt;Integer, Apple&gt; appleMap = appleList.stream().collect(Collectors.toMap(Apple::getId, a -&gt; a,(k1,k2)-&gt;k1));</code></pre><h1 id=\"List分组成Map\"><a href=\"#List分组成Map\" class=\"headerlink\" title=\"List分组成Map\"></a>List分组成Map</h1><pre><code>//List 以ID分组 Map&lt;Integer,List&lt;Apple&gt;&gt;\nMap&lt;Integer, List&lt;Apple&gt;&gt; groupBy = appleList.stream().collect(Collectors.groupingBy(Apple::getId));\n\nSystem.err.println(&quot;groupBy:&quot;+groupBy);\n{1=[Apple{id=1, name=&#39;苹果1&#39;, money=3.25, num=10}, Apple{id=1, name=&#39;苹果2&#39;, money=1.35, num=20}], 2=[Apple{id=2, name=&#39;香蕉&#39;, money=2.89, num=30}], 3=[Apple{id=3, name=&#39;荔枝&#39;, money=9.99, num=40}]}\n</code></pre><h1 id=\"3-Map转List\"><a href=\"#3-Map转List\" class=\"headerlink\" title=\"3. Map转List\"></a>3. Map转List</h1><pre><code>List&lt;Long&gt; skuIdList = order.getItemList().stream().map(OrderItemDTO::getSkuId).collect(Collectors.toList());</code></pre><h1 id=\"4-统计求和\"><a href=\"#4-统计求和\" class=\"headerlink\" title=\"4. 统计求和\"></a>4. 统计求和</h1><pre><code>\n//计算 总金额\nBigDecimal totalMoney = appleList.stream().map(Apple::getMoney).reduce(BigDecimal.ZERO, BigDecimal::add);\nSystem.err.println(&quot;totalMoney:&quot;+totalMoney);  //totalMoney:17.48</code></pre><h1 id=\"5-最大值、最小值\"><a href=\"#5-最大值、最小值\" class=\"headerlink\" title=\"5. 最大值、最小值\"></a>5. 最大值、最小值</h1><pre><code>\nOptional&lt;Dish&gt; maxDish = Dish.menu.stream().\n      collect(Collectors.maxBy(Comparator.comparing(Dish::getCalories)));\nmaxDish.ifPresent(System.out::println);\n\nOptional&lt;Dish&gt; minDish = Dish.menu.stream().\n      collect(Collectors.minBy(Comparator.comparing(Dish::getCalories)));\n</code></pre><h1 id=\"6-过滤Map\"><a href=\"#6-过滤Map\" class=\"headerlink\" title=\"6. 过滤Map\"></a>6. 过滤Map</h1><pre><code>//Map -&gt; Stream -&gt; Filter -&gt; MAP\n    Map&lt;Integer, String&gt; collect = map.entrySet().stream()\n        .filter(x -&gt; x.getKey() == 2)\n        .collect(Collectors.toMap(x -&gt; x.getKey(), x -&gt; x.getValue()));</code></pre>"},{"_content":"1.下载redis安装包\n\n```\ncd /root/software\nwget http://download.redis.io/releases/redis-3.2.4.tar.gz\ntar -zxvf redis-3.2.4.tar.gz　\n```\n\n2.编译安装\n```\n#先确保安装了make命令\n#make是gcc的编译器，VPS买来必定要安装\n#安装：\nyum -y install gcc automake autoconf libtool make\n#安装g++:\nyum install gcc gcc-c++\n\ncd redis-3.2.4\nmake && make install\n```\n\n3.将 redis-trib.rb 复制到 /usr/local/bin 目录下,能在任意目录访问到此命令\n```\ncd src\ncp redis-trib.rb /usr/local/bin/\n```\n\n4.创建目录存放redis节点的配置文件\n```\nmkdir /opt/redis-cluster/\n\n#redis集群节点至少要6个\nmkdir 7000 7002 7003 7004 7005\n\n#复制redis.conf到各个节点目录\ncp redis-3.2.4/redis.conf /opt/redis-cluster/7000\n\n```\n5.然后编辑 redis.conf修改每个节点的配置,修改以下属性\n```\nport  7000                                        //端口7000,7002,7003        \nbind 本机ip                                       //默认ip为127.0.0.1 需要改为其他节点机器可访问的ip 否则创建集群时无法访问对应的端口，无法创建集群\ndaemonize    yes                               //redis后台运行\npidfile  /var/run/redis_7000.pid          //pidfile文件对应7000,7001,7002\ncluster-enabled  yes                           //开启集群  把注释#去掉\nappendonly  yes                           //aof日志开启  有需要就开启，它会每次写操作都记录一条日志　\n```\n\n6.启动节点\n```\nredis-server redis_cluster/7000/redis.conf\nredis-server redis_cluster/7001/redis.conf\nredis-server redis_cluster/7002/redis.conf\n```\n检查 redis 启动情况\n```\n[root@localhost 7005]# ps -ef|grep redis\nroot     23002     1  0 11:41 ?        00:00:05 redis-server 192.168.10.10:7000 [cluster]\nroot     26165     1  0 11:45 ?        00:00:05 redis-server 192.168.10.10:7001 [cluster]\nroot     26609     1  0 12:03 ?        00:00:04 redis-server 192.168.10.10:7002 [cluster]\nroot     27943     1  0 13:46 ?        00:00:00 redis-server 192.168.10.10:7003 [cluster]\nroot     28008     1  0 13:47 ?        00:00:00 redis-server 192.168.10.10:7004 [cluster]\nroot     28031     1  0 13:48 ?        00:00:00 redis-server 192.168.10.10:7005 [cluster]\nroot     28036 18197  0 13:48 pts/0    00:00:00 grep --color=auto redis\n```\n```\n#查看端口监听\nnetstat -tnlp | grep redis\n```\n![](https://leanote.com/api/file/getImage?fileId=58b6679aab64410ab8008a0f)\n\n7.将redis节点加入集群\n```\nredis-trib.rb  create  --replicas  1  192.168.10.10:7000 192.168.10.10:7001  192.168.10.10:7002 192.168.10.10:7003 192.168.10.10:7004  192.168.10.10:7005\n```\n运行以上命令时，必须要先安装ruby环境，因为这个命令时ruby写的\n安装命令如下：\n\n```\nyum -y install ruby ruby-devel rubygems rpm-build\ngem install redis\n```\n重新运行命令如果出现以下图片则表示集群安装成功，记得中途还需输入yes\n![](https://leanote.com/api/file/getImage?fileId=58b6679aab64410ab8008a0d)\n\n8.集群验证\n简单说下redis集群的原理：\nredis cluster在设计的时候，就考虑到了去中心化，去中间件，也就是说，集群中的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。\n\nRedis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做哈希槽 (hash slot)的方式来分配的。redis cluster 默认分配了 16384 个slot，当我们set一个key 时，会用CRC16算法来取模得到所属的slot，然后将这个key 分到哈希槽区间的节点上，具体算法就是：CRC16(key) % 16384。所以我们在测试的时候看到set 和 get 的时候，直接跳转到了7000端口的节点。\n\nRedis 集群会把数据存在一个 master 节点，然后在这个 master 和其对应的salve 之间进行数据同步。当读取数据时，也根据一致性哈希算法到对应的 master 节点获取数据。只有当一个master 挂掉之后，才会启动一个对应的 salve 节点，充当 master 。\n\n需要注意的是：必须要6个或以上的主节点，否则在创建集群时会失败，并且当存活的主节点数小于总节点数的一半时，整个集群就无法提供服务了。\n\n所以使用redis-cli客户端命令连接redis时，随便指定集群中的任意节点都可以访问到整个集群的数据，运行命令是多加一个`-c`参数\n```\nredis-cli -h 192.168.10.10 -c -p 7002\n```\n![](https://leanote.com/api/file/getImage?fileId=58b6679aab64410ab8008a10)\n\n![](https://leanote.com/api/file/getImage?fileId=58b6679aab64410ab8008a0e)\n\n到此安装完成。\n\n# 遇到问题\n\n遇到以下问题时：\n```\n[root@localhost 7004]# /soft/redis-3.2.4/src/redis-trib.rb  create  --replicas  1  192.168.10.10:7000 192.168.10.10:7001  192.168.10.10:7002 192.168.10.10:7003 192.168.10.10:7004  192.168.10.10:7005\n>>> Creating cluster\n[ERR] Node 192.168.10.10:7005 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0.\n\n```\n解决方法：\n```\n#查找进程并kill掉\n[root@localhost 7005]# ps -ef|grep redis                             \nroot     23753     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7000 [cluster]\nroot     23758     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7001 [cluster]\nroot     23763     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7002 [cluster]\nroot     23768     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7003 [cluster]\nroot     23778     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7005 [cluster]\nroot     23846     1  0 16:34 ?        00:00:00 /soft/redis-3.2.4/src/redis-server 192.168.10.10:7004 [cluster]\n\nkill 23846\n\n#删除/opt/redis-cluster/7004/下除redis.conf的文件\nrm -f appendonly.aof  dump.rdb  nodes.conf\n或者\nrm -f !(redis.conf)\n\n#然后重新启动7004\ncd /opt/redis-cluster/7004\n/soft/redis-3.2.4/src/redis-server redis.conf\n\n/soft/redis-3.2.4/src/redis-trib.rb  create  --replicas  1  192.168.10.10:7000 192.168.10.10:7001  192.168.10.10:7002 192.168.10.10:7003 192.168.10.10:7004  192.168.10.10:7005\n\n```","source":"_posts/软件笔记/Centos 下Redis 安装以及集群搭建.md","raw":"1.下载redis安装包\n\n```\ncd /root/software\nwget http://download.redis.io/releases/redis-3.2.4.tar.gz\ntar -zxvf redis-3.2.4.tar.gz　\n```\n\n2.编译安装\n```\n#先确保安装了make命令\n#make是gcc的编译器，VPS买来必定要安装\n#安装：\nyum -y install gcc automake autoconf libtool make\n#安装g++:\nyum install gcc gcc-c++\n\ncd redis-3.2.4\nmake && make install\n```\n\n3.将 redis-trib.rb 复制到 /usr/local/bin 目录下,能在任意目录访问到此命令\n```\ncd src\ncp redis-trib.rb /usr/local/bin/\n```\n\n4.创建目录存放redis节点的配置文件\n```\nmkdir /opt/redis-cluster/\n\n#redis集群节点至少要6个\nmkdir 7000 7002 7003 7004 7005\n\n#复制redis.conf到各个节点目录\ncp redis-3.2.4/redis.conf /opt/redis-cluster/7000\n\n```\n5.然后编辑 redis.conf修改每个节点的配置,修改以下属性\n```\nport  7000                                        //端口7000,7002,7003        \nbind 本机ip                                       //默认ip为127.0.0.1 需要改为其他节点机器可访问的ip 否则创建集群时无法访问对应的端口，无法创建集群\ndaemonize    yes                               //redis后台运行\npidfile  /var/run/redis_7000.pid          //pidfile文件对应7000,7001,7002\ncluster-enabled  yes                           //开启集群  把注释#去掉\nappendonly  yes                           //aof日志开启  有需要就开启，它会每次写操作都记录一条日志　\n```\n\n6.启动节点\n```\nredis-server redis_cluster/7000/redis.conf\nredis-server redis_cluster/7001/redis.conf\nredis-server redis_cluster/7002/redis.conf\n```\n检查 redis 启动情况\n```\n[root@localhost 7005]# ps -ef|grep redis\nroot     23002     1  0 11:41 ?        00:00:05 redis-server 192.168.10.10:7000 [cluster]\nroot     26165     1  0 11:45 ?        00:00:05 redis-server 192.168.10.10:7001 [cluster]\nroot     26609     1  0 12:03 ?        00:00:04 redis-server 192.168.10.10:7002 [cluster]\nroot     27943     1  0 13:46 ?        00:00:00 redis-server 192.168.10.10:7003 [cluster]\nroot     28008     1  0 13:47 ?        00:00:00 redis-server 192.168.10.10:7004 [cluster]\nroot     28031     1  0 13:48 ?        00:00:00 redis-server 192.168.10.10:7005 [cluster]\nroot     28036 18197  0 13:48 pts/0    00:00:00 grep --color=auto redis\n```\n```\n#查看端口监听\nnetstat -tnlp | grep redis\n```\n![](https://leanote.com/api/file/getImage?fileId=58b6679aab64410ab8008a0f)\n\n7.将redis节点加入集群\n```\nredis-trib.rb  create  --replicas  1  192.168.10.10:7000 192.168.10.10:7001  192.168.10.10:7002 192.168.10.10:7003 192.168.10.10:7004  192.168.10.10:7005\n```\n运行以上命令时，必须要先安装ruby环境，因为这个命令时ruby写的\n安装命令如下：\n\n```\nyum -y install ruby ruby-devel rubygems rpm-build\ngem install redis\n```\n重新运行命令如果出现以下图片则表示集群安装成功，记得中途还需输入yes\n![](https://leanote.com/api/file/getImage?fileId=58b6679aab64410ab8008a0d)\n\n8.集群验证\n简单说下redis集群的原理：\nredis cluster在设计的时候，就考虑到了去中心化，去中间件，也就是说，集群中的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。\n\nRedis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做哈希槽 (hash slot)的方式来分配的。redis cluster 默认分配了 16384 个slot，当我们set一个key 时，会用CRC16算法来取模得到所属的slot，然后将这个key 分到哈希槽区间的节点上，具体算法就是：CRC16(key) % 16384。所以我们在测试的时候看到set 和 get 的时候，直接跳转到了7000端口的节点。\n\nRedis 集群会把数据存在一个 master 节点，然后在这个 master 和其对应的salve 之间进行数据同步。当读取数据时，也根据一致性哈希算法到对应的 master 节点获取数据。只有当一个master 挂掉之后，才会启动一个对应的 salve 节点，充当 master 。\n\n需要注意的是：必须要6个或以上的主节点，否则在创建集群时会失败，并且当存活的主节点数小于总节点数的一半时，整个集群就无法提供服务了。\n\n所以使用redis-cli客户端命令连接redis时，随便指定集群中的任意节点都可以访问到整个集群的数据，运行命令是多加一个`-c`参数\n```\nredis-cli -h 192.168.10.10 -c -p 7002\n```\n![](https://leanote.com/api/file/getImage?fileId=58b6679aab64410ab8008a10)\n\n![](https://leanote.com/api/file/getImage?fileId=58b6679aab64410ab8008a0e)\n\n到此安装完成。\n\n# 遇到问题\n\n遇到以下问题时：\n```\n[root@localhost 7004]# /soft/redis-3.2.4/src/redis-trib.rb  create  --replicas  1  192.168.10.10:7000 192.168.10.10:7001  192.168.10.10:7002 192.168.10.10:7003 192.168.10.10:7004  192.168.10.10:7005\n>>> Creating cluster\n[ERR] Node 192.168.10.10:7005 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0.\n\n```\n解决方法：\n```\n#查找进程并kill掉\n[root@localhost 7005]# ps -ef|grep redis                             \nroot     23753     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7000 [cluster]\nroot     23758     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7001 [cluster]\nroot     23763     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7002 [cluster]\nroot     23768     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7003 [cluster]\nroot     23778     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7005 [cluster]\nroot     23846     1  0 16:34 ?        00:00:00 /soft/redis-3.2.4/src/redis-server 192.168.10.10:7004 [cluster]\n\nkill 23846\n\n#删除/opt/redis-cluster/7004/下除redis.conf的文件\nrm -f appendonly.aof  dump.rdb  nodes.conf\n或者\nrm -f !(redis.conf)\n\n#然后重新启动7004\ncd /opt/redis-cluster/7004\n/soft/redis-3.2.4/src/redis-server redis.conf\n\n/soft/redis-3.2.4/src/redis-trib.rb  create  --replicas  1  192.168.10.10:7000 192.168.10.10:7001  192.168.10.10:7002 192.168.10.10:7003 192.168.10.10:7004  192.168.10.10:7005\n\n```","slug":"软件笔记/Centos 下Redis 安装以及集群搭建","published":1,"date":"2022-08-25T10:46:39.149Z","updated":"2022-08-25T10:46:54.806Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczj70023vwm152qpdnar","content":"<p>1.下载redis安装包</p>\n<pre><code>cd /root/software\nwget http://download.redis.io/releases/redis-3.2.4.tar.gz\ntar -zxvf redis-3.2.4.tar.gz　</code></pre><p>2.编译安装</p>\n<pre><code>#先确保安装了make命令\n#make是gcc的编译器，VPS买来必定要安装\n#安装：\nyum -y install gcc automake autoconf libtool make\n#安装g++:\nyum install gcc gcc-c++\n\ncd redis-3.2.4\nmake &amp;&amp; make install</code></pre><p>3.将 redis-trib.rb 复制到 /usr/local/bin 目录下,能在任意目录访问到此命令</p>\n<pre><code>cd src\ncp redis-trib.rb /usr/local/bin/</code></pre><p>4.创建目录存放redis节点的配置文件</p>\n<pre><code>mkdir /opt/redis-cluster/\n\n#redis集群节点至少要6个\nmkdir 7000 7002 7003 7004 7005\n\n#复制redis.conf到各个节点目录\ncp redis-3.2.4/redis.conf /opt/redis-cluster/7000\n</code></pre><p>5.然后编辑 redis.conf修改每个节点的配置,修改以下属性</p>\n<pre><code>port  7000                                        //端口7000,7002,7003        \nbind 本机ip                                       //默认ip为127.0.0.1 需要改为其他节点机器可访问的ip 否则创建集群时无法访问对应的端口，无法创建集群\ndaemonize    yes                               //redis后台运行\npidfile  /var/run/redis_7000.pid          //pidfile文件对应7000,7001,7002\ncluster-enabled  yes                           //开启集群  把注释#去掉\nappendonly  yes                           //aof日志开启  有需要就开启，它会每次写操作都记录一条日志　</code></pre><p>6.启动节点</p>\n<pre><code>redis-server redis_cluster/7000/redis.conf\nredis-server redis_cluster/7001/redis.conf\nredis-server redis_cluster/7002/redis.conf</code></pre><p>检查 redis 启动情况</p>\n<pre><code>[root@localhost 7005]# ps -ef|grep redis\nroot     23002     1  0 11:41 ?        00:00:05 redis-server 192.168.10.10:7000 [cluster]\nroot     26165     1  0 11:45 ?        00:00:05 redis-server 192.168.10.10:7001 [cluster]\nroot     26609     1  0 12:03 ?        00:00:04 redis-server 192.168.10.10:7002 [cluster]\nroot     27943     1  0 13:46 ?        00:00:00 redis-server 192.168.10.10:7003 [cluster]\nroot     28008     1  0 13:47 ?        00:00:00 redis-server 192.168.10.10:7004 [cluster]\nroot     28031     1  0 13:48 ?        00:00:00 redis-server 192.168.10.10:7005 [cluster]\nroot     28036 18197  0 13:48 pts/0    00:00:00 grep --color=auto redis</code></pre><pre><code>#查看端口监听\nnetstat -tnlp | grep redis</code></pre><p><img src=\"https://leanote.com/api/file/getImage?fileId=58b6679aab64410ab8008a0f\" alt></p>\n<p>7.将redis节点加入集群</p>\n<pre><code>redis-trib.rb  create  --replicas  1  192.168.10.10:7000 192.168.10.10:7001  192.168.10.10:7002 192.168.10.10:7003 192.168.10.10:7004  192.168.10.10:7005</code></pre><p>运行以上命令时，必须要先安装ruby环境，因为这个命令时ruby写的<br>安装命令如下：</p>\n<pre><code>yum -y install ruby ruby-devel rubygems rpm-build\ngem install redis</code></pre><p>重新运行命令如果出现以下图片则表示集群安装成功，记得中途还需输入yes<br><img src=\"https://leanote.com/api/file/getImage?fileId=58b6679aab64410ab8008a0d\" alt></p>\n<p>8.集群验证<br>简单说下redis集群的原理：<br>redis cluster在设计的时候，就考虑到了去中心化，去中间件，也就是说，集群中的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</p>\n<p>Redis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做哈希槽 (hash slot)的方式来分配的。redis cluster 默认分配了 16384 个slot，当我们set一个key 时，会用CRC16算法来取模得到所属的slot，然后将这个key 分到哈希槽区间的节点上，具体算法就是：CRC16(key) % 16384。所以我们在测试的时候看到set 和 get 的时候，直接跳转到了7000端口的节点。</p>\n<p>Redis 集群会把数据存在一个 master 节点，然后在这个 master 和其对应的salve 之间进行数据同步。当读取数据时，也根据一致性哈希算法到对应的 master 节点获取数据。只有当一个master 挂掉之后，才会启动一个对应的 salve 节点，充当 master 。</p>\n<p>需要注意的是：必须要6个或以上的主节点，否则在创建集群时会失败，并且当存活的主节点数小于总节点数的一半时，整个集群就无法提供服务了。</p>\n<p>所以使用redis-cli客户端命令连接redis时，随便指定集群中的任意节点都可以访问到整个集群的数据，运行命令是多加一个<code>-c</code>参数</p>\n<pre><code>redis-cli -h 192.168.10.10 -c -p 7002</code></pre><p><img src=\"https://leanote.com/api/file/getImage?fileId=58b6679aab64410ab8008a10\" alt></p>\n<p><img src=\"https://leanote.com/api/file/getImage?fileId=58b6679aab64410ab8008a0e\" alt></p>\n<p>到此安装完成。</p>\n<h1 id=\"遇到问题\"><a href=\"#遇到问题\" class=\"headerlink\" title=\"遇到问题\"></a>遇到问题</h1><p>遇到以下问题时：</p>\n<pre><code>[root@localhost 7004]# /soft/redis-3.2.4/src/redis-trib.rb  create  --replicas  1  192.168.10.10:7000 192.168.10.10:7001  192.168.10.10:7002 192.168.10.10:7003 192.168.10.10:7004  192.168.10.10:7005\n&gt;&gt;&gt; Creating cluster\n[ERR] Node 192.168.10.10:7005 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0.\n</code></pre><p>解决方法：</p>\n<pre><code>#查找进程并kill掉\n[root@localhost 7005]# ps -ef|grep redis                             \nroot     23753     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7000 [cluster]\nroot     23758     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7001 [cluster]\nroot     23763     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7002 [cluster]\nroot     23768     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7003 [cluster]\nroot     23778     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7005 [cluster]\nroot     23846     1  0 16:34 ?        00:00:00 /soft/redis-3.2.4/src/redis-server 192.168.10.10:7004 [cluster]\n\nkill 23846\n\n#删除/opt/redis-cluster/7004/下除redis.conf的文件\nrm -f appendonly.aof  dump.rdb  nodes.conf\n或者\nrm -f !(redis.conf)\n\n#然后重新启动7004\ncd /opt/redis-cluster/7004\n/soft/redis-3.2.4/src/redis-server redis.conf\n\n/soft/redis-3.2.4/src/redis-trib.rb  create  --replicas  1  192.168.10.10:7000 192.168.10.10:7001  192.168.10.10:7002 192.168.10.10:7003 192.168.10.10:7004  192.168.10.10:7005\n</code></pre>","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<p>1.下载redis安装包</p>\n<pre><code>cd /root/software\nwget http://download.redis.io/releases/redis-3.2.4.tar.gz\ntar -zxvf redis-3.2.4.tar.gz　</code></pre><p>2.编译安装</p>\n<pre><code>#先确保安装了make命令\n#make是gcc的编译器，VPS买来必定要安装\n#安装：\nyum -y install gcc automake autoconf libtool make\n#安装g++:\nyum install gcc gcc-c++\n\ncd redis-3.2.4\nmake &amp;&amp; make install</code></pre><p>3.将 redis-trib.rb 复制到 /usr/local/bin 目录下,能在任意目录访问到此命令</p>\n<pre><code>cd src\ncp redis-trib.rb /usr/local/bin/</code></pre><p>4.创建目录存放redis节点的配置文件</p>\n<pre><code>mkdir /opt/redis-cluster/\n\n#redis集群节点至少要6个\nmkdir 7000 7002 7003 7004 7005\n\n#复制redis.conf到各个节点目录\ncp redis-3.2.4/redis.conf /opt/redis-cluster/7000\n</code></pre><p>5.然后编辑 redis.conf修改每个节点的配置,修改以下属性</p>\n<pre><code>port  7000                                        //端口7000,7002,7003        \nbind 本机ip                                       //默认ip为127.0.0.1 需要改为其他节点机器可访问的ip 否则创建集群时无法访问对应的端口，无法创建集群\ndaemonize    yes                               //redis后台运行\npidfile  /var/run/redis_7000.pid          //pidfile文件对应7000,7001,7002\ncluster-enabled  yes                           //开启集群  把注释#去掉\nappendonly  yes                           //aof日志开启  有需要就开启，它会每次写操作都记录一条日志　</code></pre><p>6.启动节点</p>\n<pre><code>redis-server redis_cluster/7000/redis.conf\nredis-server redis_cluster/7001/redis.conf\nredis-server redis_cluster/7002/redis.conf</code></pre><p>检查 redis 启动情况</p>\n<pre><code>[root@localhost 7005]# ps -ef|grep redis\nroot     23002     1  0 11:41 ?        00:00:05 redis-server 192.168.10.10:7000 [cluster]\nroot     26165     1  0 11:45 ?        00:00:05 redis-server 192.168.10.10:7001 [cluster]\nroot     26609     1  0 12:03 ?        00:00:04 redis-server 192.168.10.10:7002 [cluster]\nroot     27943     1  0 13:46 ?        00:00:00 redis-server 192.168.10.10:7003 [cluster]\nroot     28008     1  0 13:47 ?        00:00:00 redis-server 192.168.10.10:7004 [cluster]\nroot     28031     1  0 13:48 ?        00:00:00 redis-server 192.168.10.10:7005 [cluster]\nroot     28036 18197  0 13:48 pts/0    00:00:00 grep --color=auto redis</code></pre><pre><code>#查看端口监听\nnetstat -tnlp | grep redis</code></pre><p><img src=\"https://leanote.com/api/file/getImage?fileId=58b6679aab64410ab8008a0f\" alt></p>\n<p>7.将redis节点加入集群</p>\n<pre><code>redis-trib.rb  create  --replicas  1  192.168.10.10:7000 192.168.10.10:7001  192.168.10.10:7002 192.168.10.10:7003 192.168.10.10:7004  192.168.10.10:7005</code></pre><p>运行以上命令时，必须要先安装ruby环境，因为这个命令时ruby写的<br>安装命令如下：</p>\n<pre><code>yum -y install ruby ruby-devel rubygems rpm-build\ngem install redis</code></pre><p>重新运行命令如果出现以下图片则表示集群安装成功，记得中途还需输入yes<br><img src=\"https://leanote.com/api/file/getImage?fileId=58b6679aab64410ab8008a0d\" alt></p>\n<p>8.集群验证<br>简单说下redis集群的原理：<br>redis cluster在设计的时候，就考虑到了去中心化，去中间件，也就是说，集群中的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</p>\n<p>Redis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做哈希槽 (hash slot)的方式来分配的。redis cluster 默认分配了 16384 个slot，当我们set一个key 时，会用CRC16算法来取模得到所属的slot，然后将这个key 分到哈希槽区间的节点上，具体算法就是：CRC16(key) % 16384。所以我们在测试的时候看到set 和 get 的时候，直接跳转到了7000端口的节点。</p>\n<p>Redis 集群会把数据存在一个 master 节点，然后在这个 master 和其对应的salve 之间进行数据同步。当读取数据时，也根据一致性哈希算法到对应的 master 节点获取数据。只有当一个master 挂掉之后，才会启动一个对应的 salve 节点，充当 master 。</p>\n<p>需要注意的是：必须要6个或以上的主节点，否则在创建集群时会失败，并且当存活的主节点数小于总节点数的一半时，整个集群就无法提供服务了。</p>\n<p>所以使用redis-cli客户端命令连接redis时，随便指定集群中的任意节点都可以访问到整个集群的数据，运行命令是多加一个<code>-c</code>参数</p>\n<pre><code>redis-cli -h 192.168.10.10 -c -p 7002</code></pre><p><img src=\"https://leanote.com/api/file/getImage?fileId=58b6679aab64410ab8008a10\" alt></p>\n<p><img src=\"https://leanote.com/api/file/getImage?fileId=58b6679aab64410ab8008a0e\" alt></p>\n<p>到此安装完成。</p>\n<h1 id=\"遇到问题\"><a href=\"#遇到问题\" class=\"headerlink\" title=\"遇到问题\"></a>遇到问题</h1><p>遇到以下问题时：</p>\n<pre><code>[root@localhost 7004]# /soft/redis-3.2.4/src/redis-trib.rb  create  --replicas  1  192.168.10.10:7000 192.168.10.10:7001  192.168.10.10:7002 192.168.10.10:7003 192.168.10.10:7004  192.168.10.10:7005\n&gt;&gt;&gt; Creating cluster\n[ERR] Node 192.168.10.10:7005 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0.\n</code></pre><p>解决方法：</p>\n<pre><code>#查找进程并kill掉\n[root@localhost 7005]# ps -ef|grep redis                             \nroot     23753     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7000 [cluster]\nroot     23758     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7001 [cluster]\nroot     23763     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7002 [cluster]\nroot     23768     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7003 [cluster]\nroot     23778     1  0 16:31 ?        00:00:00 /soft/redis-3.2.4/src//redis-server 192.168.10.10:7005 [cluster]\nroot     23846     1  0 16:34 ?        00:00:00 /soft/redis-3.2.4/src/redis-server 192.168.10.10:7004 [cluster]\n\nkill 23846\n\n#删除/opt/redis-cluster/7004/下除redis.conf的文件\nrm -f appendonly.aof  dump.rdb  nodes.conf\n或者\nrm -f !(redis.conf)\n\n#然后重新启动7004\ncd /opt/redis-cluster/7004\n/soft/redis-3.2.4/src/redis-server redis.conf\n\n/soft/redis-3.2.4/src/redis-trib.rb  create  --replicas  1  192.168.10.10:7000 192.168.10.10:7001  192.168.10.10:7002 192.168.10.10:7003 192.168.10.10:7004  192.168.10.10:7005\n</code></pre>"},{"_content":"JDK下载地址：\nhttps://github.com/frekele/oracle-java/releases\n\nidea激活：\nhttps://juejin.im/post/5df8a5a5e51d4557f0460990\n\nmaven环境变量配置：\nhttps://www.cnblogs.com/tanjiyuan/p/11010998.html","source":"_posts/软件笔记/Java开发环境准备.md","raw":"JDK下载地址：\nhttps://github.com/frekele/oracle-java/releases\n\nidea激活：\nhttps://juejin.im/post/5df8a5a5e51d4557f0460990\n\nmaven环境变量配置：\nhttps://www.cnblogs.com/tanjiyuan/p/11010998.html","slug":"软件笔记/Java开发环境准备","published":1,"date":"2022-08-25T10:47:13.550Z","updated":"2022-08-25T10:47:37.517Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczj80026vwm1q8cmcqp0","content":"<p>JDK下载地址：<br><a href=\"https://github.com/frekele/oracle-java/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/frekele/oracle-java/releases</a></p>\n<p>idea激活：<br><a href=\"https://juejin.im/post/5df8a5a5e51d4557f0460990\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5df8a5a5e51d4557f0460990</a></p>\n<p>maven环境变量配置：<br><a href=\"https://www.cnblogs.com/tanjiyuan/p/11010998.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/tanjiyuan/p/11010998.html</a></p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<p>JDK下载地址：<br><a href=\"https://github.com/frekele/oracle-java/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/frekele/oracle-java/releases</a></p>\n<p>idea激活：<br><a href=\"https://juejin.im/post/5df8a5a5e51d4557f0460990\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5df8a5a5e51d4557f0460990</a></p>\n<p>maven环境变量配置：<br><a href=\"https://www.cnblogs.com/tanjiyuan/p/11010998.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/tanjiyuan/p/11010998.html</a></p>\n"},{"_content":"## 背景\n\n  我们在开发过程中，通常都会定义大量的JavaBean，然后通过IDE去生成其属性的构造器、getter、setter、equals、hashcode、toString方法，当要对某个属性进行改变时，比如命名、类型等，都需要重新去生成上面提到的这些方法，那Java中有没有一种方式能够避免这种重复的劳动呢？答案是有，lombok插件\n  \n## Idea插件安装lombok\n1. File > Settings > Plugins > Browse repositories... > Search for \"lombok\" > Install Plugin\n2. 在使用项目中引入lombok 的类库\n```\n<dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <version>1.16.10</version>\n        <scope>provided</scope>\n    </dependency>\n```\n\n## 使用\n\n**@Getter / @Setter**\n\n  可以作用在类上和属性上，放在类上，会对所有的非静态(non-static)属性生成Getter/Setter方法，放在属性上，会对该属性生成Getter/Setter方法。并可以指定Getter/Setter方法的访问级别。\n\n**@EqualsAndHashCode**\n\n  默认情况下，会使用所有非瞬态(non-transient)和非静态(non-static)字段来生成equals和hascode方法，也可以指定具体使用哪些属性。\n\n**@ToString**\n\n  生成toString方法，默认情况下，会输出类名、所有属性，属性会按照顺序输出，以逗号分割。\n\n**@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor**\n\n  无参构造器、部分参数构造器、全参构造器，当我们需要重载多个构造器的时候，Lombok就无能为力了。\n\n**@Data**\n\n  @ToString, @EqualsAndHashCode, 所有属性的@Getter, 所有non-final属性的@Setter和@RequiredArgsConstructor的组合，通常情况下，我们使用这个注解就足够了。\n  \n  ## 原理\n  该插件的原理是在编码过程中屏蔽bean的getter/setter 方法，在编译成class的时候插件自动根据注解生成对应的gettter/setter 方法，我们通过发编译源码发现\n  \n```\n@Data\npublic class Test {\n    private String id;\n    private String name;\n\n    public void test(){\n        this.getId();\n    }\n}\n```\n编译后等价于\n\n```\npublic class Test {\n    private String id;\n    private String name;\n\n    public void test() {\n        this.getId();\n    }\n\n    public Test() {\n    }\n\n    public String getId() {\n        return this.id;\n    }\n\n    public String getName() {\n        return this.name;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public boolean equals(Object o) {\n        if(o == this) {\n            return true;\n        } else if(!(o instanceof Test)) {\n            return false;\n        } else {\n            Test other = (Test)o;\n            if(!other.canEqual(this)) {\n                return false;\n            } else {\n                String this$id = this.getId();\n                String other$id = other.getId();\n                if(this$id == null) {\n                    if(other$id != null) {\n                        return false;\n                    }\n                } else if(!this$id.equals(other$id)) {\n                    return false;\n                }\n\n                String this$name = this.getName();\n                String other$name = other.getName();\n                if(this$name == null) {\n                    if(other$name == null) {\n                        return true;\n                    }\n                } else if(this$name.equals(other$name)) {\n                    return true;\n                }\n\n                return false;\n            }\n        }\n    }\n\n    protected boolean canEqual(Object other) {\n        return other instanceof Test;\n    }\n\n    public int hashCode() {\n        boolean PRIME = true;\n        byte result = 1;\n        String $id = this.getId();\n        int result1 = result * 59 + ($id == null?43:$id.hashCode());\n        String $name = this.getName();\n        result1 = result1 * 59 + ($name == null?43:$name.hashCode());\n        return result1;\n    }\n\n    public String toString() {\n        return \"Test(id=\" + this.getId() + \", name=\" + this.getName() + \")\";\n    }\n}\n\n```","source":"_posts/软件笔记/Java bean的Getter Setter 自动编译生成工具Lombok.md","raw":"## 背景\n\n  我们在开发过程中，通常都会定义大量的JavaBean，然后通过IDE去生成其属性的构造器、getter、setter、equals、hashcode、toString方法，当要对某个属性进行改变时，比如命名、类型等，都需要重新去生成上面提到的这些方法，那Java中有没有一种方式能够避免这种重复的劳动呢？答案是有，lombok插件\n  \n## Idea插件安装lombok\n1. File > Settings > Plugins > Browse repositories... > Search for \"lombok\" > Install Plugin\n2. 在使用项目中引入lombok 的类库\n```\n<dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <version>1.16.10</version>\n        <scope>provided</scope>\n    </dependency>\n```\n\n## 使用\n\n**@Getter / @Setter**\n\n  可以作用在类上和属性上，放在类上，会对所有的非静态(non-static)属性生成Getter/Setter方法，放在属性上，会对该属性生成Getter/Setter方法。并可以指定Getter/Setter方法的访问级别。\n\n**@EqualsAndHashCode**\n\n  默认情况下，会使用所有非瞬态(non-transient)和非静态(non-static)字段来生成equals和hascode方法，也可以指定具体使用哪些属性。\n\n**@ToString**\n\n  生成toString方法，默认情况下，会输出类名、所有属性，属性会按照顺序输出，以逗号分割。\n\n**@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor**\n\n  无参构造器、部分参数构造器、全参构造器，当我们需要重载多个构造器的时候，Lombok就无能为力了。\n\n**@Data**\n\n  @ToString, @EqualsAndHashCode, 所有属性的@Getter, 所有non-final属性的@Setter和@RequiredArgsConstructor的组合，通常情况下，我们使用这个注解就足够了。\n  \n  ## 原理\n  该插件的原理是在编码过程中屏蔽bean的getter/setter 方法，在编译成class的时候插件自动根据注解生成对应的gettter/setter 方法，我们通过发编译源码发现\n  \n```\n@Data\npublic class Test {\n    private String id;\n    private String name;\n\n    public void test(){\n        this.getId();\n    }\n}\n```\n编译后等价于\n\n```\npublic class Test {\n    private String id;\n    private String name;\n\n    public void test() {\n        this.getId();\n    }\n\n    public Test() {\n    }\n\n    public String getId() {\n        return this.id;\n    }\n\n    public String getName() {\n        return this.name;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public boolean equals(Object o) {\n        if(o == this) {\n            return true;\n        } else if(!(o instanceof Test)) {\n            return false;\n        } else {\n            Test other = (Test)o;\n            if(!other.canEqual(this)) {\n                return false;\n            } else {\n                String this$id = this.getId();\n                String other$id = other.getId();\n                if(this$id == null) {\n                    if(other$id != null) {\n                        return false;\n                    }\n                } else if(!this$id.equals(other$id)) {\n                    return false;\n                }\n\n                String this$name = this.getName();\n                String other$name = other.getName();\n                if(this$name == null) {\n                    if(other$name == null) {\n                        return true;\n                    }\n                } else if(this$name.equals(other$name)) {\n                    return true;\n                }\n\n                return false;\n            }\n        }\n    }\n\n    protected boolean canEqual(Object other) {\n        return other instanceof Test;\n    }\n\n    public int hashCode() {\n        boolean PRIME = true;\n        byte result = 1;\n        String $id = this.getId();\n        int result1 = result * 59 + ($id == null?43:$id.hashCode());\n        String $name = this.getName();\n        result1 = result1 * 59 + ($name == null?43:$name.hashCode());\n        return result1;\n    }\n\n    public String toString() {\n        return \"Test(id=\" + this.getId() + \", name=\" + this.getName() + \")\";\n    }\n}\n\n```","slug":"软件笔记/Java bean的Getter Setter 自动编译生成工具Lombok","published":1,"date":"2022-08-25T10:31:51.336Z","updated":"2022-08-25T10:32:04.988Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczj90029vwm1uihdfoo7","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>  我们在开发过程中，通常都会定义大量的JavaBean，然后通过IDE去生成其属性的构造器、getter、setter、equals、hashcode、toString方法，当要对某个属性进行改变时，比如命名、类型等，都需要重新去生成上面提到的这些方法，那Java中有没有一种方式能够避免这种重复的劳动呢？答案是有，lombok插件\n  </p>\n<h2 id=\"Idea插件安装lombok\"><a href=\"#Idea插件安装lombok\" class=\"headerlink\" title=\"Idea插件安装lombok\"></a>Idea插件安装lombok</h2><ol>\n<li>File &gt; Settings &gt; Plugins &gt; Browse repositories… &gt; Search for “lombok” &gt; Install Plugin</li>\n<li>在使用项目中引入lombok 的类库<pre><code>&lt;dependency&gt;\n     &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n     &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n     &lt;version&gt;1.16.10&lt;/version&gt;\n     &lt;scope&gt;provided&lt;/scope&gt;\n &lt;/dependency&gt;</code></pre></li>\n</ol>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p><strong>@Getter / @Setter</strong></p>\n<p>  可以作用在类上和属性上，放在类上，会对所有的非静态(non-static)属性生成Getter/Setter方法，放在属性上，会对该属性生成Getter/Setter方法。并可以指定Getter/Setter方法的访问级别。</p>\n<p><strong>@EqualsAndHashCode</strong></p>\n<p>  默认情况下，会使用所有非瞬态(non-transient)和非静态(non-static)字段来生成equals和hascode方法，也可以指定具体使用哪些属性。</p>\n<p><strong>@ToString</strong></p>\n<p>  生成toString方法，默认情况下，会输出类名、所有属性，属性会按照顺序输出，以逗号分割。</p>\n<p><strong>@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor</strong></p>\n<p>  无参构造器、部分参数构造器、全参构造器，当我们需要重载多个构造器的时候，Lombok就无能为力了。</p>\n<p><strong>@Data</strong></p>\n<p>  @ToString, @EqualsAndHashCode, 所有属性的@Getter, 所有non-final属性的@Setter和@RequiredArgsConstructor的组合，通常情况下，我们使用这个注解就足够了。<br>  <br>  ## 原理<br>  该插件的原理是在编码过程中屏蔽bean的getter/setter 方法，在编译成class的时候插件自动根据注解生成对应的gettter/setter 方法，我们通过发编译源码发现\n  </p>\n<pre><code>@Data\npublic class Test {\n    private String id;\n    private String name;\n\n    public void test(){\n        this.getId();\n    }\n}</code></pre><p>编译后等价于</p>\n<pre><code>public class Test {\n    private String id;\n    private String name;\n\n    public void test() {\n        this.getId();\n    }\n\n    public Test() {\n    }\n\n    public String getId() {\n        return this.id;\n    }\n\n    public String getName() {\n        return this.name;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public boolean equals(Object o) {\n        if(o == this) {\n            return true;\n        } else if(!(o instanceof Test)) {\n            return false;\n        } else {\n            Test other = (Test)o;\n            if(!other.canEqual(this)) {\n                return false;\n            } else {\n                String this$id = this.getId();\n                String other$id = other.getId();\n                if(this$id == null) {\n                    if(other$id != null) {\n                        return false;\n                    }\n                } else if(!this$id.equals(other$id)) {\n                    return false;\n                }\n\n                String this$name = this.getName();\n                String other$name = other.getName();\n                if(this$name == null) {\n                    if(other$name == null) {\n                        return true;\n                    }\n                } else if(this$name.equals(other$name)) {\n                    return true;\n                }\n\n                return false;\n            }\n        }\n    }\n\n    protected boolean canEqual(Object other) {\n        return other instanceof Test;\n    }\n\n    public int hashCode() {\n        boolean PRIME = true;\n        byte result = 1;\n        String $id = this.getId();\n        int result1 = result * 59 + ($id == null?43:$id.hashCode());\n        String $name = this.getName();\n        result1 = result1 * 59 + ($name == null?43:$name.hashCode());\n        return result1;\n    }\n\n    public String toString() {\n        return &quot;Test(id=&quot; + this.getId() + &quot;, name=&quot; + this.getName() + &quot;)&quot;;\n    }\n}\n</code></pre>","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>  我们在开发过程中，通常都会定义大量的JavaBean，然后通过IDE去生成其属性的构造器、getter、setter、equals、hashcode、toString方法，当要对某个属性进行改变时，比如命名、类型等，都需要重新去生成上面提到的这些方法，那Java中有没有一种方式能够避免这种重复的劳动呢？答案是有，lombok插件\n  </p>\n<h2 id=\"Idea插件安装lombok\"><a href=\"#Idea插件安装lombok\" class=\"headerlink\" title=\"Idea插件安装lombok\"></a>Idea插件安装lombok</h2><ol>\n<li>File &gt; Settings &gt; Plugins &gt; Browse repositories… &gt; Search for “lombok” &gt; Install Plugin</li>\n<li>在使用项目中引入lombok 的类库<pre><code>&lt;dependency&gt;\n     &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n     &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n     &lt;version&gt;1.16.10&lt;/version&gt;\n     &lt;scope&gt;provided&lt;/scope&gt;\n &lt;/dependency&gt;</code></pre></li>\n</ol>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p><strong>@Getter / @Setter</strong></p>\n<p>  可以作用在类上和属性上，放在类上，会对所有的非静态(non-static)属性生成Getter/Setter方法，放在属性上，会对该属性生成Getter/Setter方法。并可以指定Getter/Setter方法的访问级别。</p>\n<p><strong>@EqualsAndHashCode</strong></p>\n<p>  默认情况下，会使用所有非瞬态(non-transient)和非静态(non-static)字段来生成equals和hascode方法，也可以指定具体使用哪些属性。</p>\n<p><strong>@ToString</strong></p>\n<p>  生成toString方法，默认情况下，会输出类名、所有属性，属性会按照顺序输出，以逗号分割。</p>\n<p><strong>@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor</strong></p>\n<p>  无参构造器、部分参数构造器、全参构造器，当我们需要重载多个构造器的时候，Lombok就无能为力了。</p>\n<p><strong>@Data</strong></p>\n<p>  @ToString, @EqualsAndHashCode, 所有属性的@Getter, 所有non-final属性的@Setter和@RequiredArgsConstructor的组合，通常情况下，我们使用这个注解就足够了。<br>  <br>  ## 原理<br>  该插件的原理是在编码过程中屏蔽bean的getter/setter 方法，在编译成class的时候插件自动根据注解生成对应的gettter/setter 方法，我们通过发编译源码发现\n  </p>\n<pre><code>@Data\npublic class Test {\n    private String id;\n    private String name;\n\n    public void test(){\n        this.getId();\n    }\n}</code></pre><p>编译后等价于</p>\n<pre><code>public class Test {\n    private String id;\n    private String name;\n\n    public void test() {\n        this.getId();\n    }\n\n    public Test() {\n    }\n\n    public String getId() {\n        return this.id;\n    }\n\n    public String getName() {\n        return this.name;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public boolean equals(Object o) {\n        if(o == this) {\n            return true;\n        } else if(!(o instanceof Test)) {\n            return false;\n        } else {\n            Test other = (Test)o;\n            if(!other.canEqual(this)) {\n                return false;\n            } else {\n                String this$id = this.getId();\n                String other$id = other.getId();\n                if(this$id == null) {\n                    if(other$id != null) {\n                        return false;\n                    }\n                } else if(!this$id.equals(other$id)) {\n                    return false;\n                }\n\n                String this$name = this.getName();\n                String other$name = other.getName();\n                if(this$name == null) {\n                    if(other$name == null) {\n                        return true;\n                    }\n                } else if(this$name.equals(other$name)) {\n                    return true;\n                }\n\n                return false;\n            }\n        }\n    }\n\n    protected boolean canEqual(Object other) {\n        return other instanceof Test;\n    }\n\n    public int hashCode() {\n        boolean PRIME = true;\n        byte result = 1;\n        String $id = this.getId();\n        int result1 = result * 59 + ($id == null?43:$id.hashCode());\n        String $name = this.getName();\n        result1 = result1 * 59 + ($name == null?43:$name.hashCode());\n        return result1;\n    }\n\n    public String toString() {\n        return &quot;Test(id=&quot; + this.getId() + &quot;, name=&quot; + this.getName() + &quot;)&quot;;\n    }\n}\n</code></pre>"},{"_content":"# Selenium安装环境搭建\nhttps://www.zybuluo.com/mwumli/note/222253\n\n\n\n## 遇到问题\n\n报-13权限问题时\n```\nsudo npm install --unsafe-perm -g polymer-cli\n```\n\nadb找不到设备时\n```\nadb kill-server\n\nadb start-server\n\nadb devices\n```\n\n# 元素定位\n\nfind_element_by_android_uiautomator\nhttps://blog.csdn.net/weixin_30824277/article/details/95229071\n\n\n\n# 三种等待方式详解\nhttp://blog.csdn.net/ping523/article/details/53419622\n\nhttp://www.cnblogs.com/BigFishFly/p/6380024.html","source":"_posts/软件笔记/Selenium.md","raw":"# Selenium安装环境搭建\nhttps://www.zybuluo.com/mwumli/note/222253\n\n\n\n## 遇到问题\n\n报-13权限问题时\n```\nsudo npm install --unsafe-perm -g polymer-cli\n```\n\nadb找不到设备时\n```\nadb kill-server\n\nadb start-server\n\nadb devices\n```\n\n# 元素定位\n\nfind_element_by_android_uiautomator\nhttps://blog.csdn.net/weixin_30824277/article/details/95229071\n\n\n\n# 三种等待方式详解\nhttp://blog.csdn.net/ping523/article/details/53419622\n\nhttp://www.cnblogs.com/BigFishFly/p/6380024.html","slug":"软件笔记/Selenium","published":1,"date":"2022-08-25T10:35:26.825Z","updated":"2022-08-25T10:37:21.749Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczja002cvwm1ju8si3x4","content":"<h1 id=\"Selenium安装环境搭建\"><a href=\"#Selenium安装环境搭建\" class=\"headerlink\" title=\"Selenium安装环境搭建\"></a>Selenium安装环境搭建</h1><p><a href=\"https://www.zybuluo.com/mwumli/note/222253\" target=\"_blank\" rel=\"noopener\">https://www.zybuluo.com/mwumli/note/222253</a></p>\n<h2 id=\"遇到问题\"><a href=\"#遇到问题\" class=\"headerlink\" title=\"遇到问题\"></a>遇到问题</h2><p>报-13权限问题时</p>\n<pre><code>sudo npm install --unsafe-perm -g polymer-cli</code></pre><p>adb找不到设备时</p>\n<pre><code>adb kill-server\n\nadb start-server\n\nadb devices</code></pre><h1 id=\"元素定位\"><a href=\"#元素定位\" class=\"headerlink\" title=\"元素定位\"></a>元素定位</h1><p>find_element_by_android_uiautomator<br><a href=\"https://blog.csdn.net/weixin_30824277/article/details/95229071\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_30824277/article/details/95229071</a></p>\n<h1 id=\"三种等待方式详解\"><a href=\"#三种等待方式详解\" class=\"headerlink\" title=\"三种等待方式详解\"></a>三种等待方式详解</h1><p><a href=\"http://blog.csdn.net/ping523/article/details/53419622\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/ping523/article/details/53419622</a></p>\n<p><a href=\"http://www.cnblogs.com/BigFishFly/p/6380024.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/BigFishFly/p/6380024.html</a></p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"Selenium安装环境搭建\"><a href=\"#Selenium安装环境搭建\" class=\"headerlink\" title=\"Selenium安装环境搭建\"></a>Selenium安装环境搭建</h1><p><a href=\"https://www.zybuluo.com/mwumli/note/222253\" target=\"_blank\" rel=\"noopener\">https://www.zybuluo.com/mwumli/note/222253</a></p>\n<h2 id=\"遇到问题\"><a href=\"#遇到问题\" class=\"headerlink\" title=\"遇到问题\"></a>遇到问题</h2><p>报-13权限问题时</p>\n<pre><code>sudo npm install --unsafe-perm -g polymer-cli</code></pre><p>adb找不到设备时</p>\n<pre><code>adb kill-server\n\nadb start-server\n\nadb devices</code></pre><h1 id=\"元素定位\"><a href=\"#元素定位\" class=\"headerlink\" title=\"元素定位\"></a>元素定位</h1><p>find_element_by_android_uiautomator<br><a href=\"https://blog.csdn.net/weixin_30824277/article/details/95229071\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_30824277/article/details/95229071</a></p>\n<h1 id=\"三种等待方式详解\"><a href=\"#三种等待方式详解\" class=\"headerlink\" title=\"三种等待方式详解\"></a>三种等待方式详解</h1><p><a href=\"http://blog.csdn.net/ping523/article/details/53419622\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/ping523/article/details/53419622</a></p>\n<p><a href=\"http://www.cnblogs.com/BigFishFly/p/6380024.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/BigFishFly/p/6380024.html</a></p>\n"},{"_content":"> Redis中有指定多个key批量删除的命令,却没有指定模糊key批量删除命令\n\n批量删除多个key\n```\ndel key1 key2\n```\n\n通过通配符\"*\"模糊匹配删除的lua脚本命令\n```\n# 模糊删除\neval \"local keys = redis.call('keys', ARGV[1]) for i=1,#keys,5000 do redis.call('del', unpack(keys, i, math.min(i+4999, #keys))) end return #keys\" 0 'key_*'\n```\n其中`key_*`就是要模糊匹配的key","source":"_posts/软件笔记/Redis批量删除命令.md","raw":"> Redis中有指定多个key批量删除的命令,却没有指定模糊key批量删除命令\n\n批量删除多个key\n```\ndel key1 key2\n```\n\n通过通配符\"*\"模糊匹配删除的lua脚本命令\n```\n# 模糊删除\neval \"local keys = redis.call('keys', ARGV[1]) for i=1,#keys,5000 do redis.call('del', unpack(keys, i, math.min(i+4999, #keys))) end return #keys\" 0 'key_*'\n```\n其中`key_*`就是要模糊匹配的key","slug":"软件笔记/Redis批量删除命令","published":1,"date":"2022-08-25T10:45:52.012Z","updated":"2022-08-25T10:45:58.981Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczjc002fvwm1qc8g429b","content":"<blockquote>\n<p>Redis中有指定多个key批量删除的命令,却没有指定模糊key批量删除命令</p>\n</blockquote>\n<p>批量删除多个key</p>\n<pre><code>del key1 key2</code></pre><p>通过通配符”*”模糊匹配删除的lua脚本命令</p>\n<pre><code># 模糊删除\neval &quot;local keys = redis.call(&#39;keys&#39;, ARGV[1]) for i=1,#keys,5000 do redis.call(&#39;del&#39;, unpack(keys, i, math.min(i+4999, #keys))) end return #keys&quot; 0 &#39;key_*&#39;</code></pre><p>其中<code>key_*</code>就是要模糊匹配的key</p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<blockquote>\n<p>Redis中有指定多个key批量删除的命令,却没有指定模糊key批量删除命令</p>\n</blockquote>\n<p>批量删除多个key</p>\n<pre><code>del key1 key2</code></pre><p>通过通配符”*”模糊匹配删除的lua脚本命令</p>\n<pre><code># 模糊删除\neval &quot;local keys = redis.call(&#39;keys&#39;, ARGV[1]) for i=1,#keys,5000 do redis.call(&#39;del&#39;, unpack(keys, i, math.min(i+4999, #keys))) end return #keys&quot; 0 &#39;key_*&#39;</code></pre><p>其中<code>key_*</code>就是要模糊匹配的key</p>\n"},{"_content":"一、本地rz sz安装\nhttps://github.com/aikuyun/iterm2-zmodem\n\n二、服务器端rz sz安装\nyum install lrzsz\n\nrz：从本地上传文件至服务器\nsz filename：从服务器下载文件至本地\n\n三、iTrm2配置\n参考这里：https://github.com/aikuyun/iterm2-zmodem\n\n二、使用#\n2.1 sz 命令发送文件到本地#\nsz filename\n2.2 rz 命令本地上传文件到服务器#\nrz","source":"_posts/软件笔记/iterm2 rz sz 安装.md","raw":"一、本地rz sz安装\nhttps://github.com/aikuyun/iterm2-zmodem\n\n二、服务器端rz sz安装\nyum install lrzsz\n\nrz：从本地上传文件至服务器\nsz filename：从服务器下载文件至本地\n\n三、iTrm2配置\n参考这里：https://github.com/aikuyun/iterm2-zmodem\n\n二、使用#\n2.1 sz 命令发送文件到本地#\nsz filename\n2.2 rz 命令本地上传文件到服务器#\nrz","slug":"软件笔记/iterm2 rz sz 安装","published":1,"date":"2022-08-25T10:25:37.297Z","updated":"2022-08-25T10:26:15.212Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczjd002hvwm1sw4vtdu4","content":"<p>一、本地rz sz安装<br><a href=\"https://github.com/aikuyun/iterm2-zmodem\" target=\"_blank\" rel=\"noopener\">https://github.com/aikuyun/iterm2-zmodem</a></p>\n<p>二、服务器端rz sz安装<br>yum install lrzsz</p>\n<p>rz：从本地上传文件至服务器<br>sz filename：从服务器下载文件至本地</p>\n<p>三、iTrm2配置<br>参考这里：<a href=\"https://github.com/aikuyun/iterm2-zmodem\" target=\"_blank\" rel=\"noopener\">https://github.com/aikuyun/iterm2-zmodem</a></p>\n<p>二、使用#<br>2.1 sz 命令发送文件到本地#<br>sz filename<br>2.2 rz 命令本地上传文件到服务器#<br>rz</p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<p>一、本地rz sz安装<br><a href=\"https://github.com/aikuyun/iterm2-zmodem\" target=\"_blank\" rel=\"noopener\">https://github.com/aikuyun/iterm2-zmodem</a></p>\n<p>二、服务器端rz sz安装<br>yum install lrzsz</p>\n<p>rz：从本地上传文件至服务器<br>sz filename：从服务器下载文件至本地</p>\n<p>三、iTrm2配置<br>参考这里：<a href=\"https://github.com/aikuyun/iterm2-zmodem\" target=\"_blank\" rel=\"noopener\">https://github.com/aikuyun/iterm2-zmodem</a></p>\n<p>二、使用#<br>2.1 sz 命令发送文件到本地#<br>sz filename<br>2.2 rz 命令本地上传文件到服务器#<br>rz</p>\n"},{"_content":"参考docker安装Elasticsearch官方文档\nhttps://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html\n\n# 获取镜像\n```\ndocker pull docker.elastic.co/kibana/kibana:7.16.0\n```\n\n# docker-compose启动\n\n## 新建docker-compose.yml文件\n```\nversion: '2.2'\nservices:\n  es01:\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.16.0\n    container_name: es01\n    environment:\n      - node.name=es01\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es02,es03\n      - cluster.initial_master_nodes=es01,es02,es03\n      - bootstrap.memory_lock=true\n      - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"\n#      - http.port=9200\n#      - node.master=true\n#      - node.data=true\n#      - node.ingest=true\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    volumes:\n      # - /Users/yue/data/elasticsearch-cluster/es01/config/elasticsearch.yml:/usr/share/elasticsearch/elasticsearch.yml\n      - /Users/yue/data/elasticsearch-cluster/es01/data:/usr/share/elasticsearch/data \n      - /Users/yue/data/elasticsearch-cluster/es01/logs:/usr/share/elasticsearch/logs\n#      - /Users/yue/data/elasticsearch-cluster/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml\n    ports:\n      - 9200:9200\n    networks:\n      - elastic\n\n  es02:\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.16.0\n    container_name: es02\n    environment:\n      - node.name=es02\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es01,es03\n      - cluster.initial_master_nodes=es01,es02,es03\n      - bootstrap.memory_lock=true\n      - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"\n#      - http.port=9201\n#      - node.master=true\n#      - node.data=true\n#      - node.ingest=true\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    volumes:\n      # - /Users/yue/data/elasticsearch-cluster/es02/config/elasticsearch.yml:/usr/share/elasticsearch/elasticsearch.yml\n      - /Users/yue/data/elasticsearch-cluster/es02/data:/usr/share/elasticsearch/data \n      - /Users/yue/data/elasticsearch-cluster/es02/logs:/usr/share/elasticsearch/logs\n #     - /Users/yue/data/elasticsearch-cluster/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml\n    ports:\n      - 9201:9200\n    networks:\n      - elastic\n\n  es03:\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.16.0\n    container_name: es03\n    environment:\n      - node.name=es03\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es01,es02\n      - cluster.initial_master_nodes=es01,es02,es03\n      - bootstrap.memory_lock=true\n      - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"\n#      - http.port=9202\n#      - node.master=true\n#      - node.data=true\n#      - node.ingest=true\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    volumes:\n      # - /Users/yue/data/elasticsearch-cluster/es03/config/elasticsearch.yml:/usr/share/elasticsearch/elasticsearch.yml\n      - /Users/yue/data/elasticsearch-cluster/es03/data:/usr/share/elasticsearch/data \n      - /Users/yue/data/elasticsearch-cluster/es03/logs:/usr/share/elasticsearch/logs\n#      - /Users/yue/data/elasticsearch-cluster/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml\n    ports:\n      - 9202:9200\n    networks:\n      - elastic\n\n  kib01:\n    image: docker.elastic.co/kibana/kibana:7.16.0\n    container_name: kib01\n    ports:\n      - 5601:5601\n    environment:\n      ELASTICSEARCH_URL: http://es01:9200\n      ELASTICSEARCH_HOSTS: '[\"http://es01:9200\",\"http://es02:9200\",\"http://es03:9200\"]'\n    networks:\n      - elastic\n  cerebro:\n    image: lmenezes/cerebro:latest\n    container_name: cerebro\n    ports:\n      - \"9000:9000\"\n    command:\n      - -Dhosts.0.host=http://es01:9200\n      - -Dhosts.1.host=http://es02:9200\n      - -Dhosts.2.host=http://es03:9200\n    networks:\n      - elastic\n\nvolumes:\n  data01:\n    driver: local\n  data02:\n    driver: local\n  data03:\n    driver: local\n\nnetworks:\n  elastic:\n    driver: bridge\n\n```\n\n## 启动\n\n```\ndocker-compose -f ./docker-compose.yml up d\n```\n\n> 有可能报错'failed to resolve host [es01] '\n> This sample docker-compose.yml file uses the ES_JAVA_OPTS environment variable to manually set the heap size to 512MB. We do not recommend using ES_JAVA_OPTS in production. See Manually set the heap size.\n> 解决办法，如果你用的市Mac左面版的docker,docker虚拟机内存默认是2G是不够的，调整到4G以上这个问题解决\n> ![](../images/docker ES安装/getImage-20220825184627503.png)\n\n# elasticsearch运维常用api\n\n\n## 查看实例健康状态\n```\nhttp://localhost:9200/_cat/health?v\n```\n![](https://leanote.com/api/file/getImage?fileId=61d832d4ab644142b460789c)\n\n## 查看集群健康状态\n```\nhttp://localhost:9200/_cluster/health?pretty\n```\n![](../images/docker ES安装/getImage-20220825184627531.png)\n\n## 查询分片状态\n```\nhttp://localhost:9200/_cat/shards/test*?v\n```\n\n# Elasticsearch的console常用api\n```\n\n```\n\n\n# 安装cerebro\ncerebro是Elasticsearch的可视化运维工具\n\ndocker 镜像获取\n```\n docker pull lmenezes/cerebro\n```\n\n启动\n```\n docker run -d --name cerebro -p 9000:9000 045d7f40bf06\n```\n\ncerebro可以看到每index的分片分布情况\n\n浏览器打开：http://localhost:9000/\n\n\n# 附件\n## 问题一：如果出现docker 容器假死需要强制stop时\n\n```\n停止所有的容器 docker stop $(docker ps -q)\n\n强制移除此容器 docker rm -f mysql1\n\n最后一招，强制重启docker服务\nservice 方式\n重启docker服务\nsudo service docker restart\n关闭docker\nsudo service docker stop\n```\n如果是Docker-Destop左面版，可以在设置中重启\n\n## 问题二：ELK出现unassigned_shards查看及删除\nES的data节点异常关闭，会导致副本出现unassigned shard，致使索引状态变为yellow，甚至是red。\n\n### 解决办法1：\n```\n# 查询所有分片数据\nGET _cat/shards\n\n# 或者查询集群健康状态\nGET _cluster/health\n出现unassigned_shards大于0时表示有异常分片数据\n```\n\n如果运气不好，遇到了主分片异常，上面的方法不管用，可以先用重试的方法尝试恢复\n```\n/_cluster/reroute?retry_failed=true\n```\n\n一般data节点异常退出，该方法都能解决。\n\n### 解决办法2：\n若不起作用，可以尝试重新分配主分片，不过可能会有部分数据丢失。\n\n```\nPOST /_cluster/reroute?pretty\n{\n    \"commands\" : [ {\n        \"allocate_stale_primary\" :\n            {\n              \"index\" : \"test\", \n              \"shard\" : 3,\n              \"node\" : \"192.168.1.1_9200\",\n              \"accept_data_loss\" : true\n            }\n        }\n    ]\n}\n```\n\n### 解决办法3：\n删除问题索引\n\n```\ncurl -XDELETE localhost:9200/索引名称\n```\n\n\n解决办法4：出现以上问题的原因除了同步异常外，还有一个原因可能是磁盘空间使用率大于85%。\nes中有个配置`cluster.routing.allocation.disk.watermark.low`默认是85%，系统磁盘空间使用率大于85%将出现此问题\n\n解决办法要么调整这个配置，要么清理磁盘\n```\nPUT /_cluster/settings\n{\n    \"transient\" : {\n        \"cluster.routing.allocation.disk.watermark.low\" : \"90%\"\n    }\n}\n```","source":"_posts/软件笔记/docker ES安装.md","raw":"参考docker安装Elasticsearch官方文档\nhttps://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html\n\n# 获取镜像\n```\ndocker pull docker.elastic.co/kibana/kibana:7.16.0\n```\n\n# docker-compose启动\n\n## 新建docker-compose.yml文件\n```\nversion: '2.2'\nservices:\n  es01:\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.16.0\n    container_name: es01\n    environment:\n      - node.name=es01\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es02,es03\n      - cluster.initial_master_nodes=es01,es02,es03\n      - bootstrap.memory_lock=true\n      - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"\n#      - http.port=9200\n#      - node.master=true\n#      - node.data=true\n#      - node.ingest=true\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    volumes:\n      # - /Users/yue/data/elasticsearch-cluster/es01/config/elasticsearch.yml:/usr/share/elasticsearch/elasticsearch.yml\n      - /Users/yue/data/elasticsearch-cluster/es01/data:/usr/share/elasticsearch/data \n      - /Users/yue/data/elasticsearch-cluster/es01/logs:/usr/share/elasticsearch/logs\n#      - /Users/yue/data/elasticsearch-cluster/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml\n    ports:\n      - 9200:9200\n    networks:\n      - elastic\n\n  es02:\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.16.0\n    container_name: es02\n    environment:\n      - node.name=es02\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es01,es03\n      - cluster.initial_master_nodes=es01,es02,es03\n      - bootstrap.memory_lock=true\n      - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"\n#      - http.port=9201\n#      - node.master=true\n#      - node.data=true\n#      - node.ingest=true\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    volumes:\n      # - /Users/yue/data/elasticsearch-cluster/es02/config/elasticsearch.yml:/usr/share/elasticsearch/elasticsearch.yml\n      - /Users/yue/data/elasticsearch-cluster/es02/data:/usr/share/elasticsearch/data \n      - /Users/yue/data/elasticsearch-cluster/es02/logs:/usr/share/elasticsearch/logs\n #     - /Users/yue/data/elasticsearch-cluster/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml\n    ports:\n      - 9201:9200\n    networks:\n      - elastic\n\n  es03:\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.16.0\n    container_name: es03\n    environment:\n      - node.name=es03\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es01,es02\n      - cluster.initial_master_nodes=es01,es02,es03\n      - bootstrap.memory_lock=true\n      - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"\n#      - http.port=9202\n#      - node.master=true\n#      - node.data=true\n#      - node.ingest=true\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    volumes:\n      # - /Users/yue/data/elasticsearch-cluster/es03/config/elasticsearch.yml:/usr/share/elasticsearch/elasticsearch.yml\n      - /Users/yue/data/elasticsearch-cluster/es03/data:/usr/share/elasticsearch/data \n      - /Users/yue/data/elasticsearch-cluster/es03/logs:/usr/share/elasticsearch/logs\n#      - /Users/yue/data/elasticsearch-cluster/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml\n    ports:\n      - 9202:9200\n    networks:\n      - elastic\n\n  kib01:\n    image: docker.elastic.co/kibana/kibana:7.16.0\n    container_name: kib01\n    ports:\n      - 5601:5601\n    environment:\n      ELASTICSEARCH_URL: http://es01:9200\n      ELASTICSEARCH_HOSTS: '[\"http://es01:9200\",\"http://es02:9200\",\"http://es03:9200\"]'\n    networks:\n      - elastic\n  cerebro:\n    image: lmenezes/cerebro:latest\n    container_name: cerebro\n    ports:\n      - \"9000:9000\"\n    command:\n      - -Dhosts.0.host=http://es01:9200\n      - -Dhosts.1.host=http://es02:9200\n      - -Dhosts.2.host=http://es03:9200\n    networks:\n      - elastic\n\nvolumes:\n  data01:\n    driver: local\n  data02:\n    driver: local\n  data03:\n    driver: local\n\nnetworks:\n  elastic:\n    driver: bridge\n\n```\n\n## 启动\n\n```\ndocker-compose -f ./docker-compose.yml up d\n```\n\n> 有可能报错'failed to resolve host [es01] '\n> This sample docker-compose.yml file uses the ES_JAVA_OPTS environment variable to manually set the heap size to 512MB. We do not recommend using ES_JAVA_OPTS in production. See Manually set the heap size.\n> 解决办法，如果你用的市Mac左面版的docker,docker虚拟机内存默认是2G是不够的，调整到4G以上这个问题解决\n> ![](../images/docker ES安装/getImage-20220825184627503.png)\n\n# elasticsearch运维常用api\n\n\n## 查看实例健康状态\n```\nhttp://localhost:9200/_cat/health?v\n```\n![](https://leanote.com/api/file/getImage?fileId=61d832d4ab644142b460789c)\n\n## 查看集群健康状态\n```\nhttp://localhost:9200/_cluster/health?pretty\n```\n![](../images/docker ES安装/getImage-20220825184627531.png)\n\n## 查询分片状态\n```\nhttp://localhost:9200/_cat/shards/test*?v\n```\n\n# Elasticsearch的console常用api\n```\n\n```\n\n\n# 安装cerebro\ncerebro是Elasticsearch的可视化运维工具\n\ndocker 镜像获取\n```\n docker pull lmenezes/cerebro\n```\n\n启动\n```\n docker run -d --name cerebro -p 9000:9000 045d7f40bf06\n```\n\ncerebro可以看到每index的分片分布情况\n\n浏览器打开：http://localhost:9000/\n\n\n# 附件\n## 问题一：如果出现docker 容器假死需要强制stop时\n\n```\n停止所有的容器 docker stop $(docker ps -q)\n\n强制移除此容器 docker rm -f mysql1\n\n最后一招，强制重启docker服务\nservice 方式\n重启docker服务\nsudo service docker restart\n关闭docker\nsudo service docker stop\n```\n如果是Docker-Destop左面版，可以在设置中重启\n\n## 问题二：ELK出现unassigned_shards查看及删除\nES的data节点异常关闭，会导致副本出现unassigned shard，致使索引状态变为yellow，甚至是red。\n\n### 解决办法1：\n```\n# 查询所有分片数据\nGET _cat/shards\n\n# 或者查询集群健康状态\nGET _cluster/health\n出现unassigned_shards大于0时表示有异常分片数据\n```\n\n如果运气不好，遇到了主分片异常，上面的方法不管用，可以先用重试的方法尝试恢复\n```\n/_cluster/reroute?retry_failed=true\n```\n\n一般data节点异常退出，该方法都能解决。\n\n### 解决办法2：\n若不起作用，可以尝试重新分配主分片，不过可能会有部分数据丢失。\n\n```\nPOST /_cluster/reroute?pretty\n{\n    \"commands\" : [ {\n        \"allocate_stale_primary\" :\n            {\n              \"index\" : \"test\", \n              \"shard\" : 3,\n              \"node\" : \"192.168.1.1_9200\",\n              \"accept_data_loss\" : true\n            }\n        }\n    ]\n}\n```\n\n### 解决办法3：\n删除问题索引\n\n```\ncurl -XDELETE localhost:9200/索引名称\n```\n\n\n解决办法4：出现以上问题的原因除了同步异常外，还有一个原因可能是磁盘空间使用率大于85%。\nes中有个配置`cluster.routing.allocation.disk.watermark.low`默认是85%，系统磁盘空间使用率大于85%将出现此问题\n\n解决办法要么调整这个配置，要么清理磁盘\n```\nPUT /_cluster/settings\n{\n    \"transient\" : {\n        \"cluster.routing.allocation.disk.watermark.low\" : \"90%\"\n    }\n}\n```","slug":"软件笔记/docker ES安装","published":1,"date":"2022-08-25T10:46:17.125Z","updated":"2022-08-25T10:46:28.805Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczjd002ivwm1u2eb3xfb","content":"<p>参考docker安装Elasticsearch官方文档<br><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html\" target=\"_blank\" rel=\"noopener\">https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html</a></p>\n<h1 id=\"获取镜像\"><a href=\"#获取镜像\" class=\"headerlink\" title=\"获取镜像\"></a>获取镜像</h1><pre><code>docker pull docker.elastic.co/kibana/kibana:7.16.0</code></pre><h1 id=\"docker-compose启动\"><a href=\"#docker-compose启动\" class=\"headerlink\" title=\"docker-compose启动\"></a>docker-compose启动</h1><h2 id=\"新建docker-compose-yml文件\"><a href=\"#新建docker-compose-yml文件\" class=\"headerlink\" title=\"新建docker-compose.yml文件\"></a>新建docker-compose.yml文件</h2><pre><code>version: &#39;2.2&#39;\nservices:\n  es01:\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.16.0\n    container_name: es01\n    environment:\n      - node.name=es01\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es02,es03\n      - cluster.initial_master_nodes=es01,es02,es03\n      - bootstrap.memory_lock=true\n      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;\n#      - http.port=9200\n#      - node.master=true\n#      - node.data=true\n#      - node.ingest=true\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    volumes:\n      # - /Users/yue/data/elasticsearch-cluster/es01/config/elasticsearch.yml:/usr/share/elasticsearch/elasticsearch.yml\n      - /Users/yue/data/elasticsearch-cluster/es01/data:/usr/share/elasticsearch/data \n      - /Users/yue/data/elasticsearch-cluster/es01/logs:/usr/share/elasticsearch/logs\n#      - /Users/yue/data/elasticsearch-cluster/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml\n    ports:\n      - 9200:9200\n    networks:\n      - elastic\n\n  es02:\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.16.0\n    container_name: es02\n    environment:\n      - node.name=es02\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es01,es03\n      - cluster.initial_master_nodes=es01,es02,es03\n      - bootstrap.memory_lock=true\n      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;\n#      - http.port=9201\n#      - node.master=true\n#      - node.data=true\n#      - node.ingest=true\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    volumes:\n      # - /Users/yue/data/elasticsearch-cluster/es02/config/elasticsearch.yml:/usr/share/elasticsearch/elasticsearch.yml\n      - /Users/yue/data/elasticsearch-cluster/es02/data:/usr/share/elasticsearch/data \n      - /Users/yue/data/elasticsearch-cluster/es02/logs:/usr/share/elasticsearch/logs\n #     - /Users/yue/data/elasticsearch-cluster/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml\n    ports:\n      - 9201:9200\n    networks:\n      - elastic\n\n  es03:\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.16.0\n    container_name: es03\n    environment:\n      - node.name=es03\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es01,es02\n      - cluster.initial_master_nodes=es01,es02,es03\n      - bootstrap.memory_lock=true\n      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;\n#      - http.port=9202\n#      - node.master=true\n#      - node.data=true\n#      - node.ingest=true\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    volumes:\n      # - /Users/yue/data/elasticsearch-cluster/es03/config/elasticsearch.yml:/usr/share/elasticsearch/elasticsearch.yml\n      - /Users/yue/data/elasticsearch-cluster/es03/data:/usr/share/elasticsearch/data \n      - /Users/yue/data/elasticsearch-cluster/es03/logs:/usr/share/elasticsearch/logs\n#      - /Users/yue/data/elasticsearch-cluster/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml\n    ports:\n      - 9202:9200\n    networks:\n      - elastic\n\n  kib01:\n    image: docker.elastic.co/kibana/kibana:7.16.0\n    container_name: kib01\n    ports:\n      - 5601:5601\n    environment:\n      ELASTICSEARCH_URL: http://es01:9200\n      ELASTICSEARCH_HOSTS: &#39;[&quot;http://es01:9200&quot;,&quot;http://es02:9200&quot;,&quot;http://es03:9200&quot;]&#39;\n    networks:\n      - elastic\n  cerebro:\n    image: lmenezes/cerebro:latest\n    container_name: cerebro\n    ports:\n      - &quot;9000:9000&quot;\n    command:\n      - -Dhosts.0.host=http://es01:9200\n      - -Dhosts.1.host=http://es02:9200\n      - -Dhosts.2.host=http://es03:9200\n    networks:\n      - elastic\n\nvolumes:\n  data01:\n    driver: local\n  data02:\n    driver: local\n  data03:\n    driver: local\n\nnetworks:\n  elastic:\n    driver: bridge\n</code></pre><h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><pre><code>docker-compose -f ./docker-compose.yml up d</code></pre><blockquote>\n<p>有可能报错’failed to resolve host [es01] ‘<br>This sample docker-compose.yml file uses the ES_JAVA_OPTS environment variable to manually set the heap size to 512MB. We do not recommend using ES_JAVA_OPTS in production. See Manually set the heap size.<br>解决办法，如果你用的市Mac左面版的docker,docker虚拟机内存默认是2G是不够的，调整到4G以上这个问题解决<br>![](../images/docker ES安装/getImage-20220825184627503.png)</p>\n</blockquote>\n<h1 id=\"elasticsearch运维常用api\"><a href=\"#elasticsearch运维常用api\" class=\"headerlink\" title=\"elasticsearch运维常用api\"></a>elasticsearch运维常用api</h1><h2 id=\"查看实例健康状态\"><a href=\"#查看实例健康状态\" class=\"headerlink\" title=\"查看实例健康状态\"></a>查看实例健康状态</h2><pre><code>http://localhost:9200/_cat/health?v</code></pre><p><img src=\"https://leanote.com/api/file/getImage?fileId=61d832d4ab644142b460789c\" alt></p>\n<h2 id=\"查看集群健康状态\"><a href=\"#查看集群健康状态\" class=\"headerlink\" title=\"查看集群健康状态\"></a>查看集群健康状态</h2><pre><code>http://localhost:9200/_cluster/health?pretty</code></pre><p>![](../images/docker ES安装/getImage-20220825184627531.png)</p>\n<h2 id=\"查询分片状态\"><a href=\"#查询分片状态\" class=\"headerlink\" title=\"查询分片状态\"></a>查询分片状态</h2><pre><code>http://localhost:9200/_cat/shards/test*?v</code></pre><h1 id=\"Elasticsearch的console常用api\"><a href=\"#Elasticsearch的console常用api\" class=\"headerlink\" title=\"Elasticsearch的console常用api\"></a>Elasticsearch的console常用api</h1><pre><code></code></pre><h1 id=\"安装cerebro\"><a href=\"#安装cerebro\" class=\"headerlink\" title=\"安装cerebro\"></a>安装cerebro</h1><p>cerebro是Elasticsearch的可视化运维工具</p>\n<p>docker 镜像获取</p>\n<pre><code> docker pull lmenezes/cerebro</code></pre><p>启动</p>\n<pre><code> docker run -d --name cerebro -p 9000:9000 045d7f40bf06</code></pre><p>cerebro可以看到每index的分片分布情况</p>\n<p>浏览器打开：<a href=\"http://localhost:9000/\" target=\"_blank\" rel=\"noopener\">http://localhost:9000/</a></p>\n<h1 id=\"附件\"><a href=\"#附件\" class=\"headerlink\" title=\"附件\"></a>附件</h1><h2 id=\"问题一：如果出现docker-容器假死需要强制stop时\"><a href=\"#问题一：如果出现docker-容器假死需要强制stop时\" class=\"headerlink\" title=\"问题一：如果出现docker 容器假死需要强制stop时\"></a>问题一：如果出现docker 容器假死需要强制stop时</h2><pre><code>停止所有的容器 docker stop $(docker ps -q)\n\n强制移除此容器 docker rm -f mysql1\n\n最后一招，强制重启docker服务\nservice 方式\n重启docker服务\nsudo service docker restart\n关闭docker\nsudo service docker stop</code></pre><p>如果是Docker-Destop左面版，可以在设置中重启</p>\n<h2 id=\"问题二：ELK出现unassigned-shards查看及删除\"><a href=\"#问题二：ELK出现unassigned-shards查看及删除\" class=\"headerlink\" title=\"问题二：ELK出现unassigned_shards查看及删除\"></a>问题二：ELK出现unassigned_shards查看及删除</h2><p>ES的data节点异常关闭，会导致副本出现unassigned shard，致使索引状态变为yellow，甚至是red。</p>\n<h3 id=\"解决办法1：\"><a href=\"#解决办法1：\" class=\"headerlink\" title=\"解决办法1：\"></a>解决办法1：</h3><pre><code># 查询所有分片数据\nGET _cat/shards\n\n# 或者查询集群健康状态\nGET _cluster/health\n出现unassigned_shards大于0时表示有异常分片数据</code></pre><p>如果运气不好，遇到了主分片异常，上面的方法不管用，可以先用重试的方法尝试恢复</p>\n<pre><code>/_cluster/reroute?retry_failed=true</code></pre><p>一般data节点异常退出，该方法都能解决。</p>\n<h3 id=\"解决办法2：\"><a href=\"#解决办法2：\" class=\"headerlink\" title=\"解决办法2：\"></a>解决办法2：</h3><p>若不起作用，可以尝试重新分配主分片，不过可能会有部分数据丢失。</p>\n<pre><code>POST /_cluster/reroute?pretty\n{\n    &quot;commands&quot; : [ {\n        &quot;allocate_stale_primary&quot; :\n            {\n              &quot;index&quot; : &quot;test&quot;, \n              &quot;shard&quot; : 3,\n              &quot;node&quot; : &quot;192.168.1.1_9200&quot;,\n              &quot;accept_data_loss&quot; : true\n            }\n        }\n    ]\n}</code></pre><h3 id=\"解决办法3：\"><a href=\"#解决办法3：\" class=\"headerlink\" title=\"解决办法3：\"></a>解决办法3：</h3><p>删除问题索引</p>\n<pre><code>curl -XDELETE localhost:9200/索引名称</code></pre><p>解决办法4：出现以上问题的原因除了同步异常外，还有一个原因可能是磁盘空间使用率大于85%。<br>es中有个配置<code>cluster.routing.allocation.disk.watermark.low</code>默认是85%，系统磁盘空间使用率大于85%将出现此问题</p>\n<p>解决办法要么调整这个配置，要么清理磁盘</p>\n<pre><code>PUT /_cluster/settings\n{\n    &quot;transient&quot; : {\n        &quot;cluster.routing.allocation.disk.watermark.low&quot; : &quot;90%&quot;\n    }\n}</code></pre>","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<p>参考docker安装Elasticsearch官方文档<br><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html\" target=\"_blank\" rel=\"noopener\">https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html</a></p>\n<h1 id=\"获取镜像\"><a href=\"#获取镜像\" class=\"headerlink\" title=\"获取镜像\"></a>获取镜像</h1><pre><code>docker pull docker.elastic.co/kibana/kibana:7.16.0</code></pre><h1 id=\"docker-compose启动\"><a href=\"#docker-compose启动\" class=\"headerlink\" title=\"docker-compose启动\"></a>docker-compose启动</h1><h2 id=\"新建docker-compose-yml文件\"><a href=\"#新建docker-compose-yml文件\" class=\"headerlink\" title=\"新建docker-compose.yml文件\"></a>新建docker-compose.yml文件</h2><pre><code>version: &#39;2.2&#39;\nservices:\n  es01:\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.16.0\n    container_name: es01\n    environment:\n      - node.name=es01\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es02,es03\n      - cluster.initial_master_nodes=es01,es02,es03\n      - bootstrap.memory_lock=true\n      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;\n#      - http.port=9200\n#      - node.master=true\n#      - node.data=true\n#      - node.ingest=true\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    volumes:\n      # - /Users/yue/data/elasticsearch-cluster/es01/config/elasticsearch.yml:/usr/share/elasticsearch/elasticsearch.yml\n      - /Users/yue/data/elasticsearch-cluster/es01/data:/usr/share/elasticsearch/data \n      - /Users/yue/data/elasticsearch-cluster/es01/logs:/usr/share/elasticsearch/logs\n#      - /Users/yue/data/elasticsearch-cluster/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml\n    ports:\n      - 9200:9200\n    networks:\n      - elastic\n\n  es02:\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.16.0\n    container_name: es02\n    environment:\n      - node.name=es02\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es01,es03\n      - cluster.initial_master_nodes=es01,es02,es03\n      - bootstrap.memory_lock=true\n      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;\n#      - http.port=9201\n#      - node.master=true\n#      - node.data=true\n#      - node.ingest=true\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    volumes:\n      # - /Users/yue/data/elasticsearch-cluster/es02/config/elasticsearch.yml:/usr/share/elasticsearch/elasticsearch.yml\n      - /Users/yue/data/elasticsearch-cluster/es02/data:/usr/share/elasticsearch/data \n      - /Users/yue/data/elasticsearch-cluster/es02/logs:/usr/share/elasticsearch/logs\n #     - /Users/yue/data/elasticsearch-cluster/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml\n    ports:\n      - 9201:9200\n    networks:\n      - elastic\n\n  es03:\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.16.0\n    container_name: es03\n    environment:\n      - node.name=es03\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es01,es02\n      - cluster.initial_master_nodes=es01,es02,es03\n      - bootstrap.memory_lock=true\n      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;\n#      - http.port=9202\n#      - node.master=true\n#      - node.data=true\n#      - node.ingest=true\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    volumes:\n      # - /Users/yue/data/elasticsearch-cluster/es03/config/elasticsearch.yml:/usr/share/elasticsearch/elasticsearch.yml\n      - /Users/yue/data/elasticsearch-cluster/es03/data:/usr/share/elasticsearch/data \n      - /Users/yue/data/elasticsearch-cluster/es03/logs:/usr/share/elasticsearch/logs\n#      - /Users/yue/data/elasticsearch-cluster/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml\n    ports:\n      - 9202:9200\n    networks:\n      - elastic\n\n  kib01:\n    image: docker.elastic.co/kibana/kibana:7.16.0\n    container_name: kib01\n    ports:\n      - 5601:5601\n    environment:\n      ELASTICSEARCH_URL: http://es01:9200\n      ELASTICSEARCH_HOSTS: &#39;[&quot;http://es01:9200&quot;,&quot;http://es02:9200&quot;,&quot;http://es03:9200&quot;]&#39;\n    networks:\n      - elastic\n  cerebro:\n    image: lmenezes/cerebro:latest\n    container_name: cerebro\n    ports:\n      - &quot;9000:9000&quot;\n    command:\n      - -Dhosts.0.host=http://es01:9200\n      - -Dhosts.1.host=http://es02:9200\n      - -Dhosts.2.host=http://es03:9200\n    networks:\n      - elastic\n\nvolumes:\n  data01:\n    driver: local\n  data02:\n    driver: local\n  data03:\n    driver: local\n\nnetworks:\n  elastic:\n    driver: bridge\n</code></pre><h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><pre><code>docker-compose -f ./docker-compose.yml up d</code></pre><blockquote>\n<p>有可能报错’failed to resolve host [es01] ‘<br>This sample docker-compose.yml file uses the ES_JAVA_OPTS environment variable to manually set the heap size to 512MB. We do not recommend using ES_JAVA_OPTS in production. See Manually set the heap size.<br>解决办法，如果你用的市Mac左面版的docker,docker虚拟机内存默认是2G是不够的，调整到4G以上这个问题解决<br>![](../images/docker ES安装/getImage-20220825184627503.png)</p>\n</blockquote>\n<h1 id=\"elasticsearch运维常用api\"><a href=\"#elasticsearch运维常用api\" class=\"headerlink\" title=\"elasticsearch运维常用api\"></a>elasticsearch运维常用api</h1><h2 id=\"查看实例健康状态\"><a href=\"#查看实例健康状态\" class=\"headerlink\" title=\"查看实例健康状态\"></a>查看实例健康状态</h2><pre><code>http://localhost:9200/_cat/health?v</code></pre><p><img src=\"https://leanote.com/api/file/getImage?fileId=61d832d4ab644142b460789c\" alt></p>\n<h2 id=\"查看集群健康状态\"><a href=\"#查看集群健康状态\" class=\"headerlink\" title=\"查看集群健康状态\"></a>查看集群健康状态</h2><pre><code>http://localhost:9200/_cluster/health?pretty</code></pre><p>![](../images/docker ES安装/getImage-20220825184627531.png)</p>\n<h2 id=\"查询分片状态\"><a href=\"#查询分片状态\" class=\"headerlink\" title=\"查询分片状态\"></a>查询分片状态</h2><pre><code>http://localhost:9200/_cat/shards/test*?v</code></pre><h1 id=\"Elasticsearch的console常用api\"><a href=\"#Elasticsearch的console常用api\" class=\"headerlink\" title=\"Elasticsearch的console常用api\"></a>Elasticsearch的console常用api</h1><pre><code></code></pre><h1 id=\"安装cerebro\"><a href=\"#安装cerebro\" class=\"headerlink\" title=\"安装cerebro\"></a>安装cerebro</h1><p>cerebro是Elasticsearch的可视化运维工具</p>\n<p>docker 镜像获取</p>\n<pre><code> docker pull lmenezes/cerebro</code></pre><p>启动</p>\n<pre><code> docker run -d --name cerebro -p 9000:9000 045d7f40bf06</code></pre><p>cerebro可以看到每index的分片分布情况</p>\n<p>浏览器打开：<a href=\"http://localhost:9000/\" target=\"_blank\" rel=\"noopener\">http://localhost:9000/</a></p>\n<h1 id=\"附件\"><a href=\"#附件\" class=\"headerlink\" title=\"附件\"></a>附件</h1><h2 id=\"问题一：如果出现docker-容器假死需要强制stop时\"><a href=\"#问题一：如果出现docker-容器假死需要强制stop时\" class=\"headerlink\" title=\"问题一：如果出现docker 容器假死需要强制stop时\"></a>问题一：如果出现docker 容器假死需要强制stop时</h2><pre><code>停止所有的容器 docker stop $(docker ps -q)\n\n强制移除此容器 docker rm -f mysql1\n\n最后一招，强制重启docker服务\nservice 方式\n重启docker服务\nsudo service docker restart\n关闭docker\nsudo service docker stop</code></pre><p>如果是Docker-Destop左面版，可以在设置中重启</p>\n<h2 id=\"问题二：ELK出现unassigned-shards查看及删除\"><a href=\"#问题二：ELK出现unassigned-shards查看及删除\" class=\"headerlink\" title=\"问题二：ELK出现unassigned_shards查看及删除\"></a>问题二：ELK出现unassigned_shards查看及删除</h2><p>ES的data节点异常关闭，会导致副本出现unassigned shard，致使索引状态变为yellow，甚至是red。</p>\n<h3 id=\"解决办法1：\"><a href=\"#解决办法1：\" class=\"headerlink\" title=\"解决办法1：\"></a>解决办法1：</h3><pre><code># 查询所有分片数据\nGET _cat/shards\n\n# 或者查询集群健康状态\nGET _cluster/health\n出现unassigned_shards大于0时表示有异常分片数据</code></pre><p>如果运气不好，遇到了主分片异常，上面的方法不管用，可以先用重试的方法尝试恢复</p>\n<pre><code>/_cluster/reroute?retry_failed=true</code></pre><p>一般data节点异常退出，该方法都能解决。</p>\n<h3 id=\"解决办法2：\"><a href=\"#解决办法2：\" class=\"headerlink\" title=\"解决办法2：\"></a>解决办法2：</h3><p>若不起作用，可以尝试重新分配主分片，不过可能会有部分数据丢失。</p>\n<pre><code>POST /_cluster/reroute?pretty\n{\n    &quot;commands&quot; : [ {\n        &quot;allocate_stale_primary&quot; :\n            {\n              &quot;index&quot; : &quot;test&quot;, \n              &quot;shard&quot; : 3,\n              &quot;node&quot; : &quot;192.168.1.1_9200&quot;,\n              &quot;accept_data_loss&quot; : true\n            }\n        }\n    ]\n}</code></pre><h3 id=\"解决办法3：\"><a href=\"#解决办法3：\" class=\"headerlink\" title=\"解决办法3：\"></a>解决办法3：</h3><p>删除问题索引</p>\n<pre><code>curl -XDELETE localhost:9200/索引名称</code></pre><p>解决办法4：出现以上问题的原因除了同步异常外，还有一个原因可能是磁盘空间使用率大于85%。<br>es中有个配置<code>cluster.routing.allocation.disk.watermark.low</code>默认是85%，系统磁盘空间使用率大于85%将出现此问题</p>\n<p>解决办法要么调整这个配置，要么清理磁盘</p>\n<pre><code>PUT /_cluster/settings\n{\n    &quot;transient&quot; : {\n        &quot;cluster.routing.allocation.disk.watermark.low&quot; : &quot;90%&quot;\n    }\n}</code></pre>"},{"_content":"# 软件准备\n## 一、下载Jmeter3.1\n\n下载地址：https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-3.1.zip\n其他版本：https://archive.apache.org/dist/jmeter/binaries/\n\n更高版本的Jmeter 5+好像有点问题，建议还是用这个版本吧\n\n## 二、下载dubbo官方的jmeter插件\n\n下载地址：https://gitee.com/ningyu/dist-jmeter-plugins-for-apache-dubbo/raw/master/2.7.7/jmeter-plugins-dubbo-2.7.7-jar-with-dependencies.jar\n官方用户指南：https://github.com/thubbo/jmeter-plugins-for-apache-dubbo/wiki/%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97\n\n## 三、解压Jmeter\n\n将jmeter-plugins-dubbo-2.7.7-jar-with-dependencies.jar放到`${JMETER_HOME}\\lib\\ext.`中\n\n## 四、启动Jmeter\n\n `${JMETER_HOME}\\jmeter.bat`\n\n# 五、使用Jmeter进行订单接口压测\n\n## 在测试计划中右键添加一个线程组，设置压测的线程数及并发数\n![](../images/Untitled/getImage-20220825182246944.png)\n![](../images/Untitled/getImage-20220825182247846.png)\n\n## 添加一个Dubbo Simple测试任务\n![](../images/Untitled/getImage-20220825182248427.png)\n\n将被测试的dubbo api加入`${JMETER_HOME}\\lib\\ext.`中，否则paramType将找不到类，paramValue填入入参DTO的json对象，注意不能有格式，否则解析不出来，这是个坑\n![](../images/Untitled/getImage-20220825182248165.png)\n\n## 添加请求查看树，方便查询每个请求的出入参；线程组>添加>监听器>查看结果树\n![](../images/Untitled/getImage-20220825182248034.png)\n\n## 添加测试结果汇总报告；线程组>添加>监听器>Summary Report\n![](../images/Untitled/getImage-20220825182247230.png)\n\n## 开始压测，点击启动\n![](../images/Untitled/getImage-20220825182248268.png)\n\n## 结果查看，压测过程中可以看到请求参数，压测完之后可以压测结果，一般需要经过多次压测且压测的线程和并发数多一点\n\n![](../images/Untitled/getImage-20220825182247269.png)\n\n# 六、dubbo服务器状态查看\n\n1. 使用telnet进入dubbo的console界面\n```\ntelnet 192.168.1.131 32101\n后回车\n```\n![](../images/Untitled/getImage-20220825182247523.png)\n`status -l` 查看线程状态\n![](../images/Untitled/getImage-20220825182247961.png)","source":"_posts/软件笔记/使用Jmeter进行Dubbo接口压测.md","raw":"# 软件准备\n## 一、下载Jmeter3.1\n\n下载地址：https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-3.1.zip\n其他版本：https://archive.apache.org/dist/jmeter/binaries/\n\n更高版本的Jmeter 5+好像有点问题，建议还是用这个版本吧\n\n## 二、下载dubbo官方的jmeter插件\n\n下载地址：https://gitee.com/ningyu/dist-jmeter-plugins-for-apache-dubbo/raw/master/2.7.7/jmeter-plugins-dubbo-2.7.7-jar-with-dependencies.jar\n官方用户指南：https://github.com/thubbo/jmeter-plugins-for-apache-dubbo/wiki/%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97\n\n## 三、解压Jmeter\n\n将jmeter-plugins-dubbo-2.7.7-jar-with-dependencies.jar放到`${JMETER_HOME}\\lib\\ext.`中\n\n## 四、启动Jmeter\n\n `${JMETER_HOME}\\jmeter.bat`\n\n# 五、使用Jmeter进行订单接口压测\n\n## 在测试计划中右键添加一个线程组，设置压测的线程数及并发数\n![](../images/Untitled/getImage-20220825182246944.png)\n![](../images/Untitled/getImage-20220825182247846.png)\n\n## 添加一个Dubbo Simple测试任务\n![](../images/Untitled/getImage-20220825182248427.png)\n\n将被测试的dubbo api加入`${JMETER_HOME}\\lib\\ext.`中，否则paramType将找不到类，paramValue填入入参DTO的json对象，注意不能有格式，否则解析不出来，这是个坑\n![](../images/Untitled/getImage-20220825182248165.png)\n\n## 添加请求查看树，方便查询每个请求的出入参；线程组>添加>监听器>查看结果树\n![](../images/Untitled/getImage-20220825182248034.png)\n\n## 添加测试结果汇总报告；线程组>添加>监听器>Summary Report\n![](../images/Untitled/getImage-20220825182247230.png)\n\n## 开始压测，点击启动\n![](../images/Untitled/getImage-20220825182248268.png)\n\n## 结果查看，压测过程中可以看到请求参数，压测完之后可以压测结果，一般需要经过多次压测且压测的线程和并发数多一点\n\n![](../images/Untitled/getImage-20220825182247269.png)\n\n# 六、dubbo服务器状态查看\n\n1. 使用telnet进入dubbo的console界面\n```\ntelnet 192.168.1.131 32101\n后回车\n```\n![](../images/Untitled/getImage-20220825182247523.png)\n`status -l` 查看线程状态\n![](../images/Untitled/getImage-20220825182247961.png)","slug":"软件笔记/使用Jmeter进行Dubbo接口压测","published":1,"date":"2022-08-25T10:22:26.993Z","updated":"2022-08-25T10:24:47.584Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczje002lvwm141ti3x2i","content":"<h1 id=\"软件准备\"><a href=\"#软件准备\" class=\"headerlink\" title=\"软件准备\"></a>软件准备</h1><h2 id=\"一、下载Jmeter3-1\"><a href=\"#一、下载Jmeter3-1\" class=\"headerlink\" title=\"一、下载Jmeter3.1\"></a>一、下载Jmeter3.1</h2><p>下载地址：<a href=\"https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-3.1.zip\" target=\"_blank\" rel=\"noopener\">https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-3.1.zip</a><br>其他版本：<a href=\"https://archive.apache.org/dist/jmeter/binaries/\" target=\"_blank\" rel=\"noopener\">https://archive.apache.org/dist/jmeter/binaries/</a></p>\n<p>更高版本的Jmeter 5+好像有点问题，建议还是用这个版本吧</p>\n<h2 id=\"二、下载dubbo官方的jmeter插件\"><a href=\"#二、下载dubbo官方的jmeter插件\" class=\"headerlink\" title=\"二、下载dubbo官方的jmeter插件\"></a>二、下载dubbo官方的jmeter插件</h2><p>下载地址：<a href=\"https://gitee.com/ningyu/dist-jmeter-plugins-for-apache-dubbo/raw/master/2.7.7/jmeter-plugins-dubbo-2.7.7-jar-with-dependencies.jar\" target=\"_blank\" rel=\"noopener\">https://gitee.com/ningyu/dist-jmeter-plugins-for-apache-dubbo/raw/master/2.7.7/jmeter-plugins-dubbo-2.7.7-jar-with-dependencies.jar</a><br>官方用户指南：<a href=\"https://github.com/thubbo/jmeter-plugins-for-apache-dubbo/wiki/%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97\" target=\"_blank\" rel=\"noopener\">https://github.com/thubbo/jmeter-plugins-for-apache-dubbo/wiki/%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97</a></p>\n<h2 id=\"三、解压Jmeter\"><a href=\"#三、解压Jmeter\" class=\"headerlink\" title=\"三、解压Jmeter\"></a>三、解压Jmeter</h2><p>将jmeter-plugins-dubbo-2.7.7-jar-with-dependencies.jar放到<code>${JMETER_HOME}\\lib\\ext.</code>中</p>\n<h2 id=\"四、启动Jmeter\"><a href=\"#四、启动Jmeter\" class=\"headerlink\" title=\"四、启动Jmeter\"></a>四、启动Jmeter</h2><p> <code>${JMETER_HOME}\\jmeter.bat</code></p>\n<h1 id=\"五、使用Jmeter进行订单接口压测\"><a href=\"#五、使用Jmeter进行订单接口压测\" class=\"headerlink\" title=\"五、使用Jmeter进行订单接口压测\"></a>五、使用Jmeter进行订单接口压测</h1><h2 id=\"在测试计划中右键添加一个线程组，设置压测的线程数及并发数\"><a href=\"#在测试计划中右键添加一个线程组，设置压测的线程数及并发数\" class=\"headerlink\" title=\"在测试计划中右键添加一个线程组，设置压测的线程数及并发数\"></a>在测试计划中右键添加一个线程组，设置压测的线程数及并发数</h2><p><img src=\"../images/Untitled/getImage-20220825182246944.png\" alt><br><img src=\"../images/Untitled/getImage-20220825182247846.png\" alt></p>\n<h2 id=\"添加一个Dubbo-Simple测试任务\"><a href=\"#添加一个Dubbo-Simple测试任务\" class=\"headerlink\" title=\"添加一个Dubbo Simple测试任务\"></a>添加一个Dubbo Simple测试任务</h2><p><img src=\"../images/Untitled/getImage-20220825182248427.png\" alt></p>\n<p>将被测试的dubbo api加入<code>${JMETER_HOME}\\lib\\ext.</code>中，否则paramType将找不到类，paramValue填入入参DTO的json对象，注意不能有格式，否则解析不出来，这是个坑<br><img src=\"../images/Untitled/getImage-20220825182248165.png\" alt></p>\n<h2 id=\"添加请求查看树，方便查询每个请求的出入参；线程组-gt-添加-gt-监听器-gt-查看结果树\"><a href=\"#添加请求查看树，方便查询每个请求的出入参；线程组-gt-添加-gt-监听器-gt-查看结果树\" class=\"headerlink\" title=\"添加请求查看树，方便查询每个请求的出入参；线程组&gt;添加&gt;监听器&gt;查看结果树\"></a>添加请求查看树，方便查询每个请求的出入参；线程组&gt;添加&gt;监听器&gt;查看结果树</h2><p><img src=\"../images/Untitled/getImage-20220825182248034.png\" alt></p>\n<h2 id=\"添加测试结果汇总报告；线程组-gt-添加-gt-监听器-gt-Summary-Report\"><a href=\"#添加测试结果汇总报告；线程组-gt-添加-gt-监听器-gt-Summary-Report\" class=\"headerlink\" title=\"添加测试结果汇总报告；线程组&gt;添加&gt;监听器&gt;Summary Report\"></a>添加测试结果汇总报告；线程组&gt;添加&gt;监听器&gt;Summary Report</h2><p><img src=\"../images/Untitled/getImage-20220825182247230.png\" alt></p>\n<h2 id=\"开始压测，点击启动\"><a href=\"#开始压测，点击启动\" class=\"headerlink\" title=\"开始压测，点击启动\"></a>开始压测，点击启动</h2><p><img src=\"../images/Untitled/getImage-20220825182248268.png\" alt></p>\n<h2 id=\"结果查看，压测过程中可以看到请求参数，压测完之后可以压测结果，一般需要经过多次压测且压测的线程和并发数多一点\"><a href=\"#结果查看，压测过程中可以看到请求参数，压测完之后可以压测结果，一般需要经过多次压测且压测的线程和并发数多一点\" class=\"headerlink\" title=\"结果查看，压测过程中可以看到请求参数，压测完之后可以压测结果，一般需要经过多次压测且压测的线程和并发数多一点\"></a>结果查看，压测过程中可以看到请求参数，压测完之后可以压测结果，一般需要经过多次压测且压测的线程和并发数多一点</h2><p><img src=\"../images/Untitled/getImage-20220825182247269.png\" alt></p>\n<h1 id=\"六、dubbo服务器状态查看\"><a href=\"#六、dubbo服务器状态查看\" class=\"headerlink\" title=\"六、dubbo服务器状态查看\"></a>六、dubbo服务器状态查看</h1><ol>\n<li>使用telnet进入dubbo的console界面<pre><code>telnet 192.168.1.131 32101\n后回车</code></pre><img src=\"../images/Untitled/getImage-20220825182247523.png\" alt><br><code>status -l</code> 查看线程状态<br><img src=\"../images/Untitled/getImage-20220825182247961.png\" alt></li>\n</ol>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"软件准备\"><a href=\"#软件准备\" class=\"headerlink\" title=\"软件准备\"></a>软件准备</h1><h2 id=\"一、下载Jmeter3-1\"><a href=\"#一、下载Jmeter3-1\" class=\"headerlink\" title=\"一、下载Jmeter3.1\"></a>一、下载Jmeter3.1</h2><p>下载地址：<a href=\"https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-3.1.zip\" target=\"_blank\" rel=\"noopener\">https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-3.1.zip</a><br>其他版本：<a href=\"https://archive.apache.org/dist/jmeter/binaries/\" target=\"_blank\" rel=\"noopener\">https://archive.apache.org/dist/jmeter/binaries/</a></p>\n<p>更高版本的Jmeter 5+好像有点问题，建议还是用这个版本吧</p>\n<h2 id=\"二、下载dubbo官方的jmeter插件\"><a href=\"#二、下载dubbo官方的jmeter插件\" class=\"headerlink\" title=\"二、下载dubbo官方的jmeter插件\"></a>二、下载dubbo官方的jmeter插件</h2><p>下载地址：<a href=\"https://gitee.com/ningyu/dist-jmeter-plugins-for-apache-dubbo/raw/master/2.7.7/jmeter-plugins-dubbo-2.7.7-jar-with-dependencies.jar\" target=\"_blank\" rel=\"noopener\">https://gitee.com/ningyu/dist-jmeter-plugins-for-apache-dubbo/raw/master/2.7.7/jmeter-plugins-dubbo-2.7.7-jar-with-dependencies.jar</a><br>官方用户指南：<a href=\"https://github.com/thubbo/jmeter-plugins-for-apache-dubbo/wiki/%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97\" target=\"_blank\" rel=\"noopener\">https://github.com/thubbo/jmeter-plugins-for-apache-dubbo/wiki/%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97</a></p>\n<h2 id=\"三、解压Jmeter\"><a href=\"#三、解压Jmeter\" class=\"headerlink\" title=\"三、解压Jmeter\"></a>三、解压Jmeter</h2><p>将jmeter-plugins-dubbo-2.7.7-jar-with-dependencies.jar放到<code>${JMETER_HOME}\\lib\\ext.</code>中</p>\n<h2 id=\"四、启动Jmeter\"><a href=\"#四、启动Jmeter\" class=\"headerlink\" title=\"四、启动Jmeter\"></a>四、启动Jmeter</h2><p> <code>${JMETER_HOME}\\jmeter.bat</code></p>\n<h1 id=\"五、使用Jmeter进行订单接口压测\"><a href=\"#五、使用Jmeter进行订单接口压测\" class=\"headerlink\" title=\"五、使用Jmeter进行订单接口压测\"></a>五、使用Jmeter进行订单接口压测</h1><h2 id=\"在测试计划中右键添加一个线程组，设置压测的线程数及并发数\"><a href=\"#在测试计划中右键添加一个线程组，设置压测的线程数及并发数\" class=\"headerlink\" title=\"在测试计划中右键添加一个线程组，设置压测的线程数及并发数\"></a>在测试计划中右键添加一个线程组，设置压测的线程数及并发数</h2><p><img src=\"../images/Untitled/getImage-20220825182246944.png\" alt><br><img src=\"../images/Untitled/getImage-20220825182247846.png\" alt></p>\n<h2 id=\"添加一个Dubbo-Simple测试任务\"><a href=\"#添加一个Dubbo-Simple测试任务\" class=\"headerlink\" title=\"添加一个Dubbo Simple测试任务\"></a>添加一个Dubbo Simple测试任务</h2><p><img src=\"../images/Untitled/getImage-20220825182248427.png\" alt></p>\n<p>将被测试的dubbo api加入<code>${JMETER_HOME}\\lib\\ext.</code>中，否则paramType将找不到类，paramValue填入入参DTO的json对象，注意不能有格式，否则解析不出来，这是个坑<br><img src=\"../images/Untitled/getImage-20220825182248165.png\" alt></p>\n<h2 id=\"添加请求查看树，方便查询每个请求的出入参；线程组-gt-添加-gt-监听器-gt-查看结果树\"><a href=\"#添加请求查看树，方便查询每个请求的出入参；线程组-gt-添加-gt-监听器-gt-查看结果树\" class=\"headerlink\" title=\"添加请求查看树，方便查询每个请求的出入参；线程组&gt;添加&gt;监听器&gt;查看结果树\"></a>添加请求查看树，方便查询每个请求的出入参；线程组&gt;添加&gt;监听器&gt;查看结果树</h2><p><img src=\"../images/Untitled/getImage-20220825182248034.png\" alt></p>\n<h2 id=\"添加测试结果汇总报告；线程组-gt-添加-gt-监听器-gt-Summary-Report\"><a href=\"#添加测试结果汇总报告；线程组-gt-添加-gt-监听器-gt-Summary-Report\" class=\"headerlink\" title=\"添加测试结果汇总报告；线程组&gt;添加&gt;监听器&gt;Summary Report\"></a>添加测试结果汇总报告；线程组&gt;添加&gt;监听器&gt;Summary Report</h2><p><img src=\"../images/Untitled/getImage-20220825182247230.png\" alt></p>\n<h2 id=\"开始压测，点击启动\"><a href=\"#开始压测，点击启动\" class=\"headerlink\" title=\"开始压测，点击启动\"></a>开始压测，点击启动</h2><p><img src=\"../images/Untitled/getImage-20220825182248268.png\" alt></p>\n<h2 id=\"结果查看，压测过程中可以看到请求参数，压测完之后可以压测结果，一般需要经过多次压测且压测的线程和并发数多一点\"><a href=\"#结果查看，压测过程中可以看到请求参数，压测完之后可以压测结果，一般需要经过多次压测且压测的线程和并发数多一点\" class=\"headerlink\" title=\"结果查看，压测过程中可以看到请求参数，压测完之后可以压测结果，一般需要经过多次压测且压测的线程和并发数多一点\"></a>结果查看，压测过程中可以看到请求参数，压测完之后可以压测结果，一般需要经过多次压测且压测的线程和并发数多一点</h2><p><img src=\"../images/Untitled/getImage-20220825182247269.png\" alt></p>\n<h1 id=\"六、dubbo服务器状态查看\"><a href=\"#六、dubbo服务器状态查看\" class=\"headerlink\" title=\"六、dubbo服务器状态查看\"></a>六、dubbo服务器状态查看</h1><ol>\n<li>使用telnet进入dubbo的console界面<pre><code>telnet 192.168.1.131 32101\n后回车</code></pre><img src=\"../images/Untitled/getImage-20220825182247523.png\" alt><br><code>status -l</code> 查看线程状态<br><img src=\"../images/Untitled/getImage-20220825182247961.png\" alt></li>\n</ol>\n"},{"_content":"解决办法：到安装路径C:\\Program Files (x86)\\JetBrains\\IntelliJ IDEA 15.0.4\\bin\n找到idea.exe.vmoptions配置修改Xmx 为合适大小1024/2048，然后启动此路径下的idea.exe\n```\n-Xms128m\n-Xmx1024m\n-XX:MaxPermSize=350m\n-XX:ReservedCodeCacheSize=240m\n-XX:+UseConcMarkSweepGC\n-XX:SoftRefLRUPolicyMSPerMB=50\n-ea\n-Dsun.io.useCanonCaches=false\n-Djava.net.preferIPv4Stack=true\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:-OmitStackTraceInFastThrow\n\n```\n\n** 如果你的系统是64位的，则就需要修改idea64.exe.vmoptions这个配置，然后启动idea64.exe**","source":"_posts/软件笔记/idea 突然闪退，内存溢出.md","raw":"解决办法：到安装路径C:\\Program Files (x86)\\JetBrains\\IntelliJ IDEA 15.0.4\\bin\n找到idea.exe.vmoptions配置修改Xmx 为合适大小1024/2048，然后启动此路径下的idea.exe\n```\n-Xms128m\n-Xmx1024m\n-XX:MaxPermSize=350m\n-XX:ReservedCodeCacheSize=240m\n-XX:+UseConcMarkSweepGC\n-XX:SoftRefLRUPolicyMSPerMB=50\n-ea\n-Dsun.io.useCanonCaches=false\n-Djava.net.preferIPv4Stack=true\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:-OmitStackTraceInFastThrow\n\n```\n\n** 如果你的系统是64位的，则就需要修改idea64.exe.vmoptions这个配置，然后启动idea64.exe**","slug":"软件笔记/idea 突然闪退，内存溢出","published":1,"date":"2022-08-25T10:33:15.625Z","updated":"2022-08-25T10:35:21.798Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczjf002nvwm11g0e2flz","content":"<p>解决办法：到安装路径C:\\Program Files (x86)\\JetBrains\\IntelliJ IDEA 15.0.4\\bin<br>找到idea.exe.vmoptions配置修改Xmx 为合适大小1024/2048，然后启动此路径下的idea.exe</p>\n<pre><code>-Xms128m\n-Xmx1024m\n-XX:MaxPermSize=350m\n-XX:ReservedCodeCacheSize=240m\n-XX:+UseConcMarkSweepGC\n-XX:SoftRefLRUPolicyMSPerMB=50\n-ea\n-Dsun.io.useCanonCaches=false\n-Djava.net.preferIPv4Stack=true\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:-OmitStackTraceInFastThrow\n</code></pre><p>** 如果你的系统是64位的，则就需要修改idea64.exe.vmoptions这个配置，然后启动idea64.exe**</p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<p>解决办法：到安装路径C:\\Program Files (x86)\\JetBrains\\IntelliJ IDEA 15.0.4\\bin<br>找到idea.exe.vmoptions配置修改Xmx 为合适大小1024/2048，然后启动此路径下的idea.exe</p>\n<pre><code>-Xms128m\n-Xmx1024m\n-XX:MaxPermSize=350m\n-XX:ReservedCodeCacheSize=240m\n-XX:+UseConcMarkSweepGC\n-XX:SoftRefLRUPolicyMSPerMB=50\n-ea\n-Dsun.io.useCanonCaches=false\n-Djava.net.preferIPv4Stack=true\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:-OmitStackTraceInFastThrow\n</code></pre><p>** 如果你的系统是64位的，则就需要修改idea64.exe.vmoptions这个配置，然后启动idea64.exe**</p>\n"},{"_content":"```\nmvn dependency:tree -Dverbose -Dincludes=org.slf4j\n```","source":"_posts/软件笔记/maven 包冲突 解决.md","raw":"```\nmvn dependency:tree -Dverbose -Dincludes=org.slf4j\n```","slug":"软件笔记/maven 包冲突 解决","published":1,"date":"2022-08-25T10:41:08.582Z","updated":"2022-08-25T10:42:01.719Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczjg002pvwm1pdblbjt4","content":"<pre><code>mvn dependency:tree -Dverbose -Dincludes=org.slf4j</code></pre>","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<pre><code>mvn dependency:tree -Dverbose -Dincludes=org.slf4j</code></pre>"},{"_content":"如果使用git命令进行仅涉及大小写的重命名,git 默认是把你的动作忽略的，所以当你删掉本地代码，重新pull代码时，你会发现文件还是重命名之前的,神奇吧，记下这个坑，等着你们踩着坑来这看吧，坏笑/\n\n解决方法如下：\n\n - 设置git库为大小写敏感（不建议）\n```\ngit config core.ignorecase false\n```\n用这种方法进行重命名，用git status就可以识别出修改了，但是不推荐用这种方式，因为在更新这种修改的时候会有麻烦。\n\n - 使用git mv命令（仅当core.ignorecase为true时可用）\n```\n$ git mv ABC.java Abc.java\n\n$ git status\n......\nrenamed:\n ABC.java -> Abc.java\n\n```","source":"_posts/软件笔记/git重命名的坑.md","raw":"如果使用git命令进行仅涉及大小写的重命名,git 默认是把你的动作忽略的，所以当你删掉本地代码，重新pull代码时，你会发现文件还是重命名之前的,神奇吧，记下这个坑，等着你们踩着坑来这看吧，坏笑/\n\n解决方法如下：\n\n - 设置git库为大小写敏感（不建议）\n```\ngit config core.ignorecase false\n```\n用这种方法进行重命名，用git status就可以识别出修改了，但是不推荐用这种方式，因为在更新这种修改的时候会有麻烦。\n\n - 使用git mv命令（仅当core.ignorecase为true时可用）\n```\n$ git mv ABC.java Abc.java\n\n$ git status\n......\nrenamed:\n ABC.java -> Abc.java\n\n```","slug":"软件笔记/git重命名的坑","published":1,"date":"2022-08-25T10:32:37.506Z","updated":"2022-08-25T10:32:48.412Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczjh002qvwm1qk0jgtwu","content":"<p>如果使用git命令进行仅涉及大小写的重命名,git 默认是把你的动作忽略的，所以当你删掉本地代码，重新pull代码时，你会发现文件还是重命名之前的,神奇吧，记下这个坑，等着你们踩着坑来这看吧，坏笑/</p>\n<p>解决方法如下：</p>\n<ul>\n<li><p>设置git库为大小写敏感（不建议）</p>\n<pre><code>git config core.ignorecase false</code></pre><p>用这种方法进行重命名，用git status就可以识别出修改了，但是不推荐用这种方式，因为在更新这种修改的时候会有麻烦。</p>\n</li>\n<li><p>使用git mv命令（仅当core.ignorecase为true时可用）</p>\n<pre><code>$ git mv ABC.java Abc.java\n</code></pre></li>\n</ul>\n<p>$ git status<br>……<br>renamed:<br> ABC.java -&gt; Abc.java</p>\n<p>```</p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<p>如果使用git命令进行仅涉及大小写的重命名,git 默认是把你的动作忽略的，所以当你删掉本地代码，重新pull代码时，你会发现文件还是重命名之前的,神奇吧，记下这个坑，等着你们踩着坑来这看吧，坏笑/</p>\n<p>解决方法如下：</p>\n<ul>\n<li><p>设置git库为大小写敏感（不建议）</p>\n<pre><code>git config core.ignorecase false</code></pre><p>用这种方法进行重命名，用git status就可以识别出修改了，但是不推荐用这种方式，因为在更新这种修改的时候会有麻烦。</p>\n</li>\n<li><p>使用git mv命令（仅当core.ignorecase为true时可用）</p>\n<pre><code>$ git mv ABC.java Abc.java\n</code></pre></li>\n</ul>\n<p>$ git status<br>……<br>renamed:<br> ABC.java -&gt; Abc.java</p>\n<p>```</p>\n"},{"_content":"在google应用市场中搜索Dark Reader，可以在网页中进行反色护眼\n![](../images/护眼神器Dark Reader/getImage-20220825182956835.png)","source":"_posts/软件笔记/护眼神器Dark Reader.md","raw":"在google应用市场中搜索Dark Reader，可以在网页中进行反色护眼\n![](../images/护眼神器Dark Reader/getImage-20220825182956835.png)","slug":"软件笔记/护眼神器Dark Reader","published":1,"date":"2022-08-25T10:29:39.835Z","updated":"2022-08-25T10:29:57.713Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczji002svwm192nmtp13","content":"<p>在google应用市场中搜索Dark Reader，可以在网页中进行反色护眼<br>![](../images/护眼神器Dark Reader/getImage-20220825182956835.png)</p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<p>在google应用市场中搜索Dark Reader，可以在网页中进行反色护眼<br>![](../images/护眼神器Dark Reader/getImage-20220825182956835.png)</p>\n"},{"_content":"```\n\n#阿里云maven\n<mirror>\n    <id>alimaven</id>\n    <name>aliyun maven</name>\n    <url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n    <mirrorOf>central</mirrorOf> \n</mirror>\n\n#开源中国maven\n<mirror>  \n    <id>nexus-osc</id>  \n    <mirrorOf>central</mirrorOf>  \n    <name>Nexus osc</name>  \n    <url>http://maven.oschina.net/content/groups/public/</url>  \n</mirror>\n\n```\n\n> 简单点来说，repository就是个仓库。maven里有两种仓库，本地仓库和远程仓库。远程仓库相当于公共的仓库，大家都能看到。本地仓库是你本地的一个山寨版，只有你看的到，主要起缓存作用。当你向仓库请求插件或依赖的时候，会先检查本地仓库里是否有。如果有则直接返回，否则会向远程仓库请求，并做缓存。你也可以把你做的东西上传到本地仓库给你本地自己用，或上传到远程仓库，供大家使用。 \n> 远程仓库可以在工程的pom.xml文件里指定，楼上两位已经列的很清楚了。如果没指定，默认就会把下面这地方做远程仓库，即默认会到http://repo1.maven.org/maven2这个地方去请求插件和依赖包。 \n\n\nXml代码 \n```xml\n<repository>  \n      <snapshots>  \n        <enabled>false</enabled>  \n      </snapshots>  \n      <id>central</id>  \n      <name>Maven Repository Switchboard</name>  \n      <url>http://repo1.maven.org/maven2</url>  \n</repository>  \n```\n本地仓库默认在你本地的用户目录下的.m2/repository目录下。 \n\nmirror就是镜像，主要提供一个方便地切换远程仓库地址的途径。比如，上班的时候在公司，用电信的网络，连的是电信的仓库。回到家后，是网通的网络，我想连网通的仓库，就可以通过mirror配置，统一把我工程里的仓库地址都改成联通的，而不用到具体工程配置文件里一个一个地改地址。 \nmirror的配置在.m2/settings.xml里。如： \n\n```\n<mirrors>  \n  <mirror>  \n    <id>UK</id>  \n    <name>UK Central</name>  \n    <url>http://uk.maven.org/maven2</url>  \n    <mirrorOf>central</mirrorOf>  \n  </mirror>  \n</mirrors>  \n```\n这样的话，就会给上面id为central的远程仓库做了个镜像。以后向`central`这个仓库发的请求都会发到`http://uk.maven.org/maven2`而不是`http://repo1.maven.org/maven2`了。 \n`<mirrorOf>central</mirrorOf>`里是要替代的仓库的id。如果填*，就会替代所有仓库。 \n\n参考资料： \nhttp://maven.apache.org/guides/introduction/introduction-to-repositories.html \nhttp://maven.apache.org/guides/mini/guide-mirror-settings.html","source":"_posts/软件笔记/靠谱的maven仓库地址.md","raw":"```\n\n#阿里云maven\n<mirror>\n    <id>alimaven</id>\n    <name>aliyun maven</name>\n    <url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n    <mirrorOf>central</mirrorOf> \n</mirror>\n\n#开源中国maven\n<mirror>  \n    <id>nexus-osc</id>  \n    <mirrorOf>central</mirrorOf>  \n    <name>Nexus osc</name>  \n    <url>http://maven.oschina.net/content/groups/public/</url>  \n</mirror>\n\n```\n\n> 简单点来说，repository就是个仓库。maven里有两种仓库，本地仓库和远程仓库。远程仓库相当于公共的仓库，大家都能看到。本地仓库是你本地的一个山寨版，只有你看的到，主要起缓存作用。当你向仓库请求插件或依赖的时候，会先检查本地仓库里是否有。如果有则直接返回，否则会向远程仓库请求，并做缓存。你也可以把你做的东西上传到本地仓库给你本地自己用，或上传到远程仓库，供大家使用。 \n> 远程仓库可以在工程的pom.xml文件里指定，楼上两位已经列的很清楚了。如果没指定，默认就会把下面这地方做远程仓库，即默认会到http://repo1.maven.org/maven2这个地方去请求插件和依赖包。 \n\n\nXml代码 \n```xml\n<repository>  \n      <snapshots>  \n        <enabled>false</enabled>  \n      </snapshots>  \n      <id>central</id>  \n      <name>Maven Repository Switchboard</name>  \n      <url>http://repo1.maven.org/maven2</url>  \n</repository>  \n```\n本地仓库默认在你本地的用户目录下的.m2/repository目录下。 \n\nmirror就是镜像，主要提供一个方便地切换远程仓库地址的途径。比如，上班的时候在公司，用电信的网络，连的是电信的仓库。回到家后，是网通的网络，我想连网通的仓库，就可以通过mirror配置，统一把我工程里的仓库地址都改成联通的，而不用到具体工程配置文件里一个一个地改地址。 \nmirror的配置在.m2/settings.xml里。如： \n\n```\n<mirrors>  \n  <mirror>  \n    <id>UK</id>  \n    <name>UK Central</name>  \n    <url>http://uk.maven.org/maven2</url>  \n    <mirrorOf>central</mirrorOf>  \n  </mirror>  \n</mirrors>  \n```\n这样的话，就会给上面id为central的远程仓库做了个镜像。以后向`central`这个仓库发的请求都会发到`http://uk.maven.org/maven2`而不是`http://repo1.maven.org/maven2`了。 \n`<mirrorOf>central</mirrorOf>`里是要替代的仓库的id。如果填*，就会替代所有仓库。 \n\n参考资料： \nhttp://maven.apache.org/guides/introduction/introduction-to-repositories.html \nhttp://maven.apache.org/guides/mini/guide-mirror-settings.html","slug":"软件笔记/靠谱的maven仓库地址","published":1,"date":"2022-08-25T10:32:58.657Z","updated":"2022-08-25T10:33:07.540Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczji002uvwm1j6t7yzy0","content":"<pre><code>\n#阿里云maven\n&lt;mirror&gt;\n    &lt;id&gt;alimaven&lt;/id&gt;\n    &lt;name&gt;aliyun maven&lt;/name&gt;\n    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;\n    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; \n&lt;/mirror&gt;\n\n#开源中国maven\n&lt;mirror&gt;  \n    &lt;id&gt;nexus-osc&lt;/id&gt;  \n    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;  \n    &lt;name&gt;Nexus osc&lt;/name&gt;  \n    &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt;  \n&lt;/mirror&gt;\n</code></pre><blockquote>\n<p>简单点来说，repository就是个仓库。maven里有两种仓库，本地仓库和远程仓库。远程仓库相当于公共的仓库，大家都能看到。本地仓库是你本地的一个山寨版，只有你看的到，主要起缓存作用。当你向仓库请求插件或依赖的时候，会先检查本地仓库里是否有。如果有则直接返回，否则会向远程仓库请求，并做缓存。你也可以把你做的东西上传到本地仓库给你本地自己用，或上传到远程仓库，供大家使用。<br>远程仓库可以在工程的pom.xml文件里指定，楼上两位已经列的很清楚了。如果没指定，默认就会把下面这地方做远程仓库，即默认会到<a href=\"http://repo1.maven.org/maven2这个地方去请求插件和依赖包。\" target=\"_blank\" rel=\"noopener\">http://repo1.maven.org/maven2这个地方去请求插件和依赖包。</a> </p>\n</blockquote>\n<p>Xml代码 </p>\n<pre class=\"line-numbers language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>repository</span><span class=\"token punctuation\">></span></span>  \n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>snapshots</span><span class=\"token punctuation\">></span></span>  \n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>enabled</span><span class=\"token punctuation\">></span></span>false<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>enabled</span><span class=\"token punctuation\">></span></span>  \n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>snapshots</span><span class=\"token punctuation\">></span></span>  \n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>id</span><span class=\"token punctuation\">></span></span>central<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>id</span><span class=\"token punctuation\">></span></span>  \n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>name</span><span class=\"token punctuation\">></span></span>Maven Repository Switchboard<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>name</span><span class=\"token punctuation\">></span></span>  \n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>url</span><span class=\"token punctuation\">></span></span>http://repo1.maven.org/maven2<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>url</span><span class=\"token punctuation\">></span></span>  \n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>repository</span><span class=\"token punctuation\">></span></span>  <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>本地仓库默认在你本地的用户目录下的.m2/repository目录下。 </p>\n<p>mirror就是镜像，主要提供一个方便地切换远程仓库地址的途径。比如，上班的时候在公司，用电信的网络，连的是电信的仓库。回到家后，是网通的网络，我想连网通的仓库，就可以通过mirror配置，统一把我工程里的仓库地址都改成联通的，而不用到具体工程配置文件里一个一个地改地址。<br>mirror的配置在.m2/settings.xml里。如： </p>\n<pre><code>&lt;mirrors&gt;  \n  &lt;mirror&gt;  \n    &lt;id&gt;UK&lt;/id&gt;  \n    &lt;name&gt;UK Central&lt;/name&gt;  \n    &lt;url&gt;http://uk.maven.org/maven2&lt;/url&gt;  \n    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;  \n  &lt;/mirror&gt;  \n&lt;/mirrors&gt;  </code></pre><p>这样的话，就会给上面id为central的远程仓库做了个镜像。以后向<code>central</code>这个仓库发的请求都会发到<code>http://uk.maven.org/maven2</code>而不是<code>http://repo1.maven.org/maven2</code>了。<br><code>&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</code>里是要替代的仓库的id。如果填*，就会替代所有仓库。 </p>\n<p>参考资料：<br><a href=\"http://maven.apache.org/guides/introduction/introduction-to-repositories.html\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org/guides/introduction/introduction-to-repositories.html</a><br><a href=\"http://maven.apache.org/guides/mini/guide-mirror-settings.html\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org/guides/mini/guide-mirror-settings.html</a></p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<pre><code>\n#阿里云maven\n&lt;mirror&gt;\n    &lt;id&gt;alimaven&lt;/id&gt;\n    &lt;name&gt;aliyun maven&lt;/name&gt;\n    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;\n    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; \n&lt;/mirror&gt;\n\n#开源中国maven\n&lt;mirror&gt;  \n    &lt;id&gt;nexus-osc&lt;/id&gt;  \n    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;  \n    &lt;name&gt;Nexus osc&lt;/name&gt;  \n    &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt;  \n&lt;/mirror&gt;\n</code></pre><blockquote>\n<p>简单点来说，repository就是个仓库。maven里有两种仓库，本地仓库和远程仓库。远程仓库相当于公共的仓库，大家都能看到。本地仓库是你本地的一个山寨版，只有你看的到，主要起缓存作用。当你向仓库请求插件或依赖的时候，会先检查本地仓库里是否有。如果有则直接返回，否则会向远程仓库请求，并做缓存。你也可以把你做的东西上传到本地仓库给你本地自己用，或上传到远程仓库，供大家使用。<br>远程仓库可以在工程的pom.xml文件里指定，楼上两位已经列的很清楚了。如果没指定，默认就会把下面这地方做远程仓库，即默认会到<a href=\"http://repo1.maven.org/maven2这个地方去请求插件和依赖包。\" target=\"_blank\" rel=\"noopener\">http://repo1.maven.org/maven2这个地方去请求插件和依赖包。</a> </p>\n</blockquote>\n<p>Xml代码 </p>\n<pre><code class=\"xml\">&lt;repository&gt;  \n      &lt;snapshots&gt;  \n        &lt;enabled&gt;false&lt;/enabled&gt;  \n      &lt;/snapshots&gt;  \n      &lt;id&gt;central&lt;/id&gt;  \n      &lt;name&gt;Maven Repository Switchboard&lt;/name&gt;  \n      &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt;  \n&lt;/repository&gt;  </code></pre>\n<p>本地仓库默认在你本地的用户目录下的.m2/repository目录下。 </p>\n<p>mirror就是镜像，主要提供一个方便地切换远程仓库地址的途径。比如，上班的时候在公司，用电信的网络，连的是电信的仓库。回到家后，是网通的网络，我想连网通的仓库，就可以通过mirror配置，统一把我工程里的仓库地址都改成联通的，而不用到具体工程配置文件里一个一个地改地址。<br>mirror的配置在.m2/settings.xml里。如： </p>\n<pre><code>&lt;mirrors&gt;  \n  &lt;mirror&gt;  \n    &lt;id&gt;UK&lt;/id&gt;  \n    &lt;name&gt;UK Central&lt;/name&gt;  \n    &lt;url&gt;http://uk.maven.org/maven2&lt;/url&gt;  \n    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;  \n  &lt;/mirror&gt;  \n&lt;/mirrors&gt;  </code></pre><p>这样的话，就会给上面id为central的远程仓库做了个镜像。以后向<code>central</code>这个仓库发的请求都会发到<code>http://uk.maven.org/maven2</code>而不是<code>http://repo1.maven.org/maven2</code>了。<br><code>&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</code>里是要替代的仓库的id。如果填*，就会替代所有仓库。 </p>\n<p>参考资料：<br><a href=\"http://maven.apache.org/guides/introduction/introduction-to-repositories.html\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org/guides/introduction/introduction-to-repositories.html</a><br><a href=\"http://maven.apache.org/guides/mini/guide-mirror-settings.html\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org/guides/mini/guide-mirror-settings.html</a></p>\n"},{"_content":"我们一般在pom.xml中加入`distributionManagement`\n```\n<distributionManagement>\n    <repository>\n      <id>internal.repo</id>\n      <name>MyCo Internal Repository</name>\n      <url>Host to Company Repository</url>\n    </repository>\n  </distributionManagement>\n```\n来指定setting.xml中的server私库地址，然后通过`mvn clean install deploy`打包上传 \n\n----\n\n但是为了子类不必要的应用，我们可以用`-DaltDeploymentRepository`来指定打包到私服的参数\n```\nmvn deploy -DaltDeploymentRepository=releases::default::http://198.11.174.75:8081/nexus/content/repositories/releases/\n```\n\n\n上传本地jar到私库\n```\nmvn deploy:deploy-file -DgroupId=com.xy.Oracle -DartifactId=ojdbc14 -Dversion=10.2.0.4.0 -Dpackaging=jar -Dfile=E:\\ojdbc14.jar -Durl=http://localhost:9090/nexus-2.2-01/content/repositories/thirdparty/ -DrepositoryId=thirdparty\n\n#上传小米push 到私有仓库\nmvn deploy:deploy-file -DgroupId=com.xiaomi -DartifactId=MiPush_SDK_Server -Dversion=2.2.18 -Dpackaging=jar -Dfile=lib/MiPush_SDK_Server_2_2_18.jar -Durl=http://198.11.174.75:8081/nexus/content/groups/public/\n```\n\n单独构建上传模块 pingjuan-web，同时会构建上传 pingjuan-web\n```\nmvn clean install deploy -pl trade-center-api -am\nmvn clean install deploy -DaltDeploymentRepository=releases::default::http://198.11.174.75:8081/nexus/content/repositories/releases/ -pl trade-center-api -am\n```","source":"_posts/软件笔记/使用Maven命令指定上传打包到私库.md","raw":"我们一般在pom.xml中加入`distributionManagement`\n```\n<distributionManagement>\n    <repository>\n      <id>internal.repo</id>\n      <name>MyCo Internal Repository</name>\n      <url>Host to Company Repository</url>\n    </repository>\n  </distributionManagement>\n```\n来指定setting.xml中的server私库地址，然后通过`mvn clean install deploy`打包上传 \n\n----\n\n但是为了子类不必要的应用，我们可以用`-DaltDeploymentRepository`来指定打包到私服的参数\n```\nmvn deploy -DaltDeploymentRepository=releases::default::http://198.11.174.75:8081/nexus/content/repositories/releases/\n```\n\n\n上传本地jar到私库\n```\nmvn deploy:deploy-file -DgroupId=com.xy.Oracle -DartifactId=ojdbc14 -Dversion=10.2.0.4.0 -Dpackaging=jar -Dfile=E:\\ojdbc14.jar -Durl=http://localhost:9090/nexus-2.2-01/content/repositories/thirdparty/ -DrepositoryId=thirdparty\n\n#上传小米push 到私有仓库\nmvn deploy:deploy-file -DgroupId=com.xiaomi -DartifactId=MiPush_SDK_Server -Dversion=2.2.18 -Dpackaging=jar -Dfile=lib/MiPush_SDK_Server_2_2_18.jar -Durl=http://198.11.174.75:8081/nexus/content/groups/public/\n```\n\n单独构建上传模块 pingjuan-web，同时会构建上传 pingjuan-web\n```\nmvn clean install deploy -pl trade-center-api -am\nmvn clean install deploy -DaltDeploymentRepository=releases::default::http://198.11.174.75:8081/nexus/content/repositories/releases/ -pl trade-center-api -am\n```","slug":"软件笔记/使用Maven命令指定上传打包到私库","published":1,"date":"2022-08-25T10:32:18.815Z","updated":"2022-08-25T10:32:30.816Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczjj002xvwm1j5h13fpx","content":"<p>我们一般在pom.xml中加入<code>distributionManagement</code></p>\n<pre><code>&lt;distributionManagement&gt;\n    &lt;repository&gt;\n      &lt;id&gt;internal.repo&lt;/id&gt;\n      &lt;name&gt;MyCo Internal Repository&lt;/name&gt;\n      &lt;url&gt;Host to Company Repository&lt;/url&gt;\n    &lt;/repository&gt;\n  &lt;/distributionManagement&gt;</code></pre><p>来指定setting.xml中的server私库地址，然后通过<code>mvn clean install deploy</code>打包上传 </p>\n<hr>\n<p>但是为了子类不必要的应用，我们可以用<code>-DaltDeploymentRepository</code>来指定打包到私服的参数</p>\n<pre><code>mvn deploy -DaltDeploymentRepository=releases::default::http://198.11.174.75:8081/nexus/content/repositories/releases/</code></pre><p>上传本地jar到私库</p>\n<pre><code>mvn deploy:deploy-file -DgroupId=com.xy.Oracle -DartifactId=ojdbc14 -Dversion=10.2.0.4.0 -Dpackaging=jar -Dfile=E:\\ojdbc14.jar -Durl=http://localhost:9090/nexus-2.2-01/content/repositories/thirdparty/ -DrepositoryId=thirdparty\n\n#上传小米push 到私有仓库\nmvn deploy:deploy-file -DgroupId=com.xiaomi -DartifactId=MiPush_SDK_Server -Dversion=2.2.18 -Dpackaging=jar -Dfile=lib/MiPush_SDK_Server_2_2_18.jar -Durl=http://198.11.174.75:8081/nexus/content/groups/public/</code></pre><p>单独构建上传模块 pingjuan-web，同时会构建上传 pingjuan-web</p>\n<pre><code>mvn clean install deploy -pl trade-center-api -am\nmvn clean install deploy -DaltDeploymentRepository=releases::default::http://198.11.174.75:8081/nexus/content/repositories/releases/ -pl trade-center-api -am</code></pre>","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<p>我们一般在pom.xml中加入<code>distributionManagement</code></p>\n<pre><code>&lt;distributionManagement&gt;\n    &lt;repository&gt;\n      &lt;id&gt;internal.repo&lt;/id&gt;\n      &lt;name&gt;MyCo Internal Repository&lt;/name&gt;\n      &lt;url&gt;Host to Company Repository&lt;/url&gt;\n    &lt;/repository&gt;\n  &lt;/distributionManagement&gt;</code></pre><p>来指定setting.xml中的server私库地址，然后通过<code>mvn clean install deploy</code>打包上传 </p>\n<hr>\n<p>但是为了子类不必要的应用，我们可以用<code>-DaltDeploymentRepository</code>来指定打包到私服的参数</p>\n<pre><code>mvn deploy -DaltDeploymentRepository=releases::default::http://198.11.174.75:8081/nexus/content/repositories/releases/</code></pre><p>上传本地jar到私库</p>\n<pre><code>mvn deploy:deploy-file -DgroupId=com.xy.Oracle -DartifactId=ojdbc14 -Dversion=10.2.0.4.0 -Dpackaging=jar -Dfile=E:\\ojdbc14.jar -Durl=http://localhost:9090/nexus-2.2-01/content/repositories/thirdparty/ -DrepositoryId=thirdparty\n\n#上传小米push 到私有仓库\nmvn deploy:deploy-file -DgroupId=com.xiaomi -DartifactId=MiPush_SDK_Server -Dversion=2.2.18 -Dpackaging=jar -Dfile=lib/MiPush_SDK_Server_2_2_18.jar -Durl=http://198.11.174.75:8081/nexus/content/groups/public/</code></pre><p>单独构建上传模块 pingjuan-web，同时会构建上传 pingjuan-web</p>\n<pre><code>mvn clean install deploy -pl trade-center-api -am\nmvn clean install deploy -DaltDeploymentRepository=releases::default::http://198.11.174.75:8081/nexus/content/repositories/releases/ -pl trade-center-api -am</code></pre>"},{"_content":"官方网站国内已经不能访问了：\n请用以下网址进入：\n熊猫VPN: https://www.pantavv.xyz/i/58074818","source":"_posts/软件笔记/科学上网神器,熊猫VPN, 亲测很舒服.md","raw":"官方网站国内已经不能访问了：\n请用以下网址进入：\n熊猫VPN: https://www.pantavv.xyz/i/58074818","slug":"软件笔记/科学上网神器,熊猫VPN, 亲测很舒服","published":1,"date":"2022-08-25T10:28:47.201Z","updated":"2022-08-25T10:29:03.123Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczjk002zvwm1e90xwd6x","content":"<p>官方网站国内已经不能访问了：<br>请用以下网址进入：<br>熊猫VPN: <a href=\"https://www.pantavv.xyz/i/58074818\" target=\"_blank\" rel=\"noopener\">https://www.pantavv.xyz/i/58074818</a></p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<p>官方网站国内已经不能访问了：<br>请用以下网址进入：<br>熊猫VPN: <a href=\"https://www.pantavv.xyz/i/58074818\" target=\"_blank\" rel=\"noopener\">https://www.pantavv.xyz/i/58074818</a></p>\n"},{"_content":"# 查看当前目录磁盘使用情况\n```\ndf -lh\n```\n\n# 统计当前目录下的目录及文件磁盘使用从大到小排序\n\n```\ndu -h --max-depth=1\n```","source":"_posts/软件笔记/磁盘空间满处理.md","raw":"# 查看当前目录磁盘使用情况\n```\ndf -lh\n```\n\n# 统计当前目录下的目录及文件磁盘使用从大到小排序\n\n```\ndu -h --max-depth=1\n```","slug":"软件笔记/磁盘空间满处理","published":1,"date":"2022-08-25T10:48:30.650Z","updated":"2022-08-25T10:50:03.790Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczjl0030vwm10mjglr4q","content":"<h1 id=\"查看当前目录磁盘使用情况\"><a href=\"#查看当前目录磁盘使用情况\" class=\"headerlink\" title=\"查看当前目录磁盘使用情况\"></a>查看当前目录磁盘使用情况</h1><pre><code>df -lh</code></pre><h1 id=\"统计当前目录下的目录及文件磁盘使用从大到小排序\"><a href=\"#统计当前目录下的目录及文件磁盘使用从大到小排序\" class=\"headerlink\" title=\"统计当前目录下的目录及文件磁盘使用从大到小排序\"></a>统计当前目录下的目录及文件磁盘使用从大到小排序</h1><pre><code>du -h --max-depth=1</code></pre>","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"查看当前目录磁盘使用情况\"><a href=\"#查看当前目录磁盘使用情况\" class=\"headerlink\" title=\"查看当前目录磁盘使用情况\"></a>查看当前目录磁盘使用情况</h1><pre><code>df -lh</code></pre><h1 id=\"统计当前目录下的目录及文件磁盘使用从大到小排序\"><a href=\"#统计当前目录下的目录及文件磁盘使用从大到小排序\" class=\"headerlink\" title=\"统计当前目录下的目录及文件磁盘使用从大到小排序\"></a>统计当前目录下的目录及文件磁盘使用从大到小排序</h1><pre><code>du -h --max-depth=1</code></pre>"},{"_content":"# 信息系统工程\n以结构、元素、信息及反馈等进行分析，以达到最优设计、最优规划、最优管理和最优控制的目的。\n\n系统工程的方法，霍尔提出的三维结构体系，以时间维、空间维、知识维组成的立体结构概括性表示出系统工程的各个阶段、各个步骤及所涉及到的知识范围。\n\n时间维———是指工作的进度，而于一个具体的工作项目，从制定规划起到一直更新为止，全部过程可分为七个阶段：\n\n- 规划阶段——调研、程序设计阶段，目的紫玉谋求活动的规划和战略\n- 拟定阶段——提出具体的规划方案\n- 研制阶段——作出研制方案及生产计划\n- 生产阶段\n- 安装阶段\n- 运行阶段\n- 更新阶段\n\n# 政府信息化与电子政务\n电子政务的三个主体：政府、企业及事业单位、大众\n\n# 企业的信息化与电子商务\n\n## 企业信息化\n企业信息化是指通过IT技术的部署来提供去也的生产运维效率，从而降低经营成本。其中业务流程的管理与知识的挖掘是重要活动。\n\n1. 企业信息化的是3个需求层次：战略需求、运作需求和技术需求\n\n- 战略需求——组织信息化的目标是提升组织的竞争力、为组织的可持续发展提供一个支持环境。从而某种意义上来说信息化对组织不仅仅是服务的手段和实现现有战略的辅助工具；信息化可以报组织战略提升到一个新的水平，为组织带来新的发展契机。\n- 运作需求——实现战略目标的需要、运作策略的需要、人才培养的需要。\n- 技术需求——由于系统开发时间过长等问题在信息技术层面对系统的完善、升级、集成和整合提出了需求\n\n## 企业资源规划——ERP\n商业智能——通过数据挖掘技术、知识等发现等技术分析和挖掘结构化的、面向特定领域的的数据仓库信息\n\nERP系统的三流：物流、资金流、信息流\nERP系统时对企业的物流、资金流、信息流进行全面集成的管理信息系统\n\nERP系统能够实现的企业决策计划：\n\n- 生产预测计划——对市场的需求进行比较准确的预测，是经营计划、生产计划大纲和主生产计划编制的基础\n- 销售管理计划——对销售部门的相关业务进行管理，属于最高层计划的范畴，是企业决策层最重要的计划之一\n- 生产计划大纲——根据经营计划生产目标制定\n- 主生产计划——说明一段时期内生产什么，生产多少盒什么时候交货，它是ERP的主要工作内容。\n- 物料需求计划是对主生产计划的各个项所需的制造件和全部采购件等计划\n- 能力需求计划——是对物料需求计划所需的能力进行核算的一种计划管理方法，能够帮助尽早发现企业的生产能力瓶颈，及时补充生产力。\n\nERP的信息流：\n\n- 需求信息——客户订单、生产计划、采购合同等\n- 供应信息——入库单、完工报告单、库存记录、可供销售量和提货发货发运单等\n\n\n## 客户关系管理——CRM\n客户关系管理（CRM）系统将市场营销的科学管理通过信息技术手段集成在软件商，能够帮助企业构建良好的客户关系。\nCRM是将人力资源、业务流程与专业的技术进行有效的整合，最终为企业涉及到的客户或者消费者的各个领域提供完美的集成，是的企业可以更低成本、更高效率满足客户的需求。\n其主要功能包括：\n\n- 销售自动化——是其中最为基本的模块\n- 营销自动化——作为销售自动化的补充，包括营销计划的编制和执行、计划结果分析等。\n- 客户服务支持——是系统的重要功能\n- 商业智能——数据挖掘和处理，为企业决策做支撑。\n\nCRM系统与ERP系统在财务、制造、库存等环节进行连接，**两种虽然不同但由于两者之间具有一定的关系，因此能够形成一定的闭环反馈结构**\n\n\n## 企业应用的集成\n企业应用集成有多种集成模式，构建统一标准的基础平台，将具有不同功能和目的而又独立运行的企业信息联合起来。目前市场上主流的集成模式有三种，分别是**面向信息的集成**、**面向过程的集成**、**面向服务的集成**。\n\n- 面向过程集成——强调处理不同应用系统之间的交互逻辑，与核心业务逻辑相分离，并通过不同应用系统之间的协作共同完成某项业务功能。\n- 面向信息的集成\n    -  内部信息集成\n        -  技术平台集成——系统底层的体系结构、软件、硬件及异构网络的特殊需求受限必须得到集成。这个集成包括信息技术硬件的组成\n        -  数据集成，共享数据库，主动记录、数据映射，实现不同的系统数据交流和共享，\n        -  应用系统集成，应用系统集成是实现不同系统之间的相互操作，是的不同应用系统之间能够实现数据和方法的共享\n        -  业务过程的集成，业务过程集成，企业必须在各个业务系统中定义、授权和管理各种业务信息的交流，一遍改进操作、减少成本、提高响应速度。\n    -  外部信息集成\n- 面向服务的集成\n\n集成方式：\n\n- 远程过程调用——基于同步的方式，效率较低，二期容易失败；\n- 共享数据和文件传输——将应用的数据存储在一个共享数据库中，通过制定统一的数据库模式来处理不同应用的集成需求，共享数据库为不同的应用提供了统一的数据存储和格式定义。性能方面较差，系统不能保持即时数据同步，而容易造成应用于数据紧耦合；\n- 消息传递方式——能够保证数据异步、立即、可靠传输\n\n集成平台提供的基本功能包括：\n\n- 数据通信服务：提供分布环境下的透明同步、异步通信的服务功能\n- 信息集成服务：为应用提供透明的信息访问服务，实现不同数据库之间的数据交换、相互操作、分布数据管理和共享信息模型的定义\n- 应用集成服务：通过高层应用编程接口实现对相应应用程序的访问，能够为应用提供数据交换和访问的操作，是的各个系统相互协作。\n- 二次开发工具：帮助用户开发特定应用程序的支持工具\n- 平台运行管理工具：是企业集成平台和运作的管理控制面板。\n\n电子数据交换——EDI\nEDI的实施需要一个公认的标准和协议，将商务活动中涉及到的文件标准化和格式化；EDI通过计算机网络，在贸易伙伴之间进行数据交换和自动处理\n\n企业门户是一个信息技术平台，可提供个性化的信息服务，为企业提供一个单一的访问企业各种信息资源和应用的程序入口。\n\n分为3中门户类型：\n\n- 企业信息门户——企业信息门户强调为访问结构数据和无结构数据提供统一的入口，实现收集、访问、管理和无缝集成\n- 企业知识门户——提供一个创造、搜集和传播企业知识的平台，通过企业知识门户，员工与工作团队中的其他成员取得联系，寻找能够提供帮助的专家。\n- 企业应用门户——是一个用来提供企业的集中贸易能力、协同能力和信息管理能力的平台。它以商业流程和企业应用为核心，将商业流程中功能不同的应用模块通过门户集成在一起，提高公司在集中贸易的能力、协同能力和信息管理能力。\n\n\n## 电子商务\n参与电子商务的实体有四类：客户（个人消费者或者集团）、商户（包括销售商、制造商和储运商）、银行（发卡行和收单行）以及认证中心\n\n# 知识管理和商业智能化\n## 商业智能化\n商业智能化的核心技术包括：数据仓库、数据挖掘、联机分析处理。\n商业智能化系统处理过程包括数据预处理、简历数据仓库、数据分析及数据展现：\n\n- 数据预处理——包括数据的抽取、转换、封装\n- 数据仓库——是处理海量数据的基础\n- 数据分析——包括联机分析处理和数据挖掘两部分\n    - 联机分析——处理不仅进行数据汇总、聚集，同事还提供切片、切块、下钻、上卷和旋转等分析功能\n    - 数据挖掘——挖掘数据背后的隐藏知识，通过\n- 数据展现——数据的可视化","source":"_posts/软考/企业信息化和政务信息化.md","raw":"# 信息系统工程\n以结构、元素、信息及反馈等进行分析，以达到最优设计、最优规划、最优管理和最优控制的目的。\n\n系统工程的方法，霍尔提出的三维结构体系，以时间维、空间维、知识维组成的立体结构概括性表示出系统工程的各个阶段、各个步骤及所涉及到的知识范围。\n\n时间维———是指工作的进度，而于一个具体的工作项目，从制定规划起到一直更新为止，全部过程可分为七个阶段：\n\n- 规划阶段——调研、程序设计阶段，目的紫玉谋求活动的规划和战略\n- 拟定阶段——提出具体的规划方案\n- 研制阶段——作出研制方案及生产计划\n- 生产阶段\n- 安装阶段\n- 运行阶段\n- 更新阶段\n\n# 政府信息化与电子政务\n电子政务的三个主体：政府、企业及事业单位、大众\n\n# 企业的信息化与电子商务\n\n## 企业信息化\n企业信息化是指通过IT技术的部署来提供去也的生产运维效率，从而降低经营成本。其中业务流程的管理与知识的挖掘是重要活动。\n\n1. 企业信息化的是3个需求层次：战略需求、运作需求和技术需求\n\n- 战略需求——组织信息化的目标是提升组织的竞争力、为组织的可持续发展提供一个支持环境。从而某种意义上来说信息化对组织不仅仅是服务的手段和实现现有战略的辅助工具；信息化可以报组织战略提升到一个新的水平，为组织带来新的发展契机。\n- 运作需求——实现战略目标的需要、运作策略的需要、人才培养的需要。\n- 技术需求——由于系统开发时间过长等问题在信息技术层面对系统的完善、升级、集成和整合提出了需求\n\n## 企业资源规划——ERP\n商业智能——通过数据挖掘技术、知识等发现等技术分析和挖掘结构化的、面向特定领域的的数据仓库信息\n\nERP系统的三流：物流、资金流、信息流\nERP系统时对企业的物流、资金流、信息流进行全面集成的管理信息系统\n\nERP系统能够实现的企业决策计划：\n\n- 生产预测计划——对市场的需求进行比较准确的预测，是经营计划、生产计划大纲和主生产计划编制的基础\n- 销售管理计划——对销售部门的相关业务进行管理，属于最高层计划的范畴，是企业决策层最重要的计划之一\n- 生产计划大纲——根据经营计划生产目标制定\n- 主生产计划——说明一段时期内生产什么，生产多少盒什么时候交货，它是ERP的主要工作内容。\n- 物料需求计划是对主生产计划的各个项所需的制造件和全部采购件等计划\n- 能力需求计划——是对物料需求计划所需的能力进行核算的一种计划管理方法，能够帮助尽早发现企业的生产能力瓶颈，及时补充生产力。\n\nERP的信息流：\n\n- 需求信息——客户订单、生产计划、采购合同等\n- 供应信息——入库单、完工报告单、库存记录、可供销售量和提货发货发运单等\n\n\n## 客户关系管理——CRM\n客户关系管理（CRM）系统将市场营销的科学管理通过信息技术手段集成在软件商，能够帮助企业构建良好的客户关系。\nCRM是将人力资源、业务流程与专业的技术进行有效的整合，最终为企业涉及到的客户或者消费者的各个领域提供完美的集成，是的企业可以更低成本、更高效率满足客户的需求。\n其主要功能包括：\n\n- 销售自动化——是其中最为基本的模块\n- 营销自动化——作为销售自动化的补充，包括营销计划的编制和执行、计划结果分析等。\n- 客户服务支持——是系统的重要功能\n- 商业智能——数据挖掘和处理，为企业决策做支撑。\n\nCRM系统与ERP系统在财务、制造、库存等环节进行连接，**两种虽然不同但由于两者之间具有一定的关系，因此能够形成一定的闭环反馈结构**\n\n\n## 企业应用的集成\n企业应用集成有多种集成模式，构建统一标准的基础平台，将具有不同功能和目的而又独立运行的企业信息联合起来。目前市场上主流的集成模式有三种，分别是**面向信息的集成**、**面向过程的集成**、**面向服务的集成**。\n\n- 面向过程集成——强调处理不同应用系统之间的交互逻辑，与核心业务逻辑相分离，并通过不同应用系统之间的协作共同完成某项业务功能。\n- 面向信息的集成\n    -  内部信息集成\n        -  技术平台集成——系统底层的体系结构、软件、硬件及异构网络的特殊需求受限必须得到集成。这个集成包括信息技术硬件的组成\n        -  数据集成，共享数据库，主动记录、数据映射，实现不同的系统数据交流和共享，\n        -  应用系统集成，应用系统集成是实现不同系统之间的相互操作，是的不同应用系统之间能够实现数据和方法的共享\n        -  业务过程的集成，业务过程集成，企业必须在各个业务系统中定义、授权和管理各种业务信息的交流，一遍改进操作、减少成本、提高响应速度。\n    -  外部信息集成\n- 面向服务的集成\n\n集成方式：\n\n- 远程过程调用——基于同步的方式，效率较低，二期容易失败；\n- 共享数据和文件传输——将应用的数据存储在一个共享数据库中，通过制定统一的数据库模式来处理不同应用的集成需求，共享数据库为不同的应用提供了统一的数据存储和格式定义。性能方面较差，系统不能保持即时数据同步，而容易造成应用于数据紧耦合；\n- 消息传递方式——能够保证数据异步、立即、可靠传输\n\n集成平台提供的基本功能包括：\n\n- 数据通信服务：提供分布环境下的透明同步、异步通信的服务功能\n- 信息集成服务：为应用提供透明的信息访问服务，实现不同数据库之间的数据交换、相互操作、分布数据管理和共享信息模型的定义\n- 应用集成服务：通过高层应用编程接口实现对相应应用程序的访问，能够为应用提供数据交换和访问的操作，是的各个系统相互协作。\n- 二次开发工具：帮助用户开发特定应用程序的支持工具\n- 平台运行管理工具：是企业集成平台和运作的管理控制面板。\n\n电子数据交换——EDI\nEDI的实施需要一个公认的标准和协议，将商务活动中涉及到的文件标准化和格式化；EDI通过计算机网络，在贸易伙伴之间进行数据交换和自动处理\n\n企业门户是一个信息技术平台，可提供个性化的信息服务，为企业提供一个单一的访问企业各种信息资源和应用的程序入口。\n\n分为3中门户类型：\n\n- 企业信息门户——企业信息门户强调为访问结构数据和无结构数据提供统一的入口，实现收集、访问、管理和无缝集成\n- 企业知识门户——提供一个创造、搜集和传播企业知识的平台，通过企业知识门户，员工与工作团队中的其他成员取得联系，寻找能够提供帮助的专家。\n- 企业应用门户——是一个用来提供企业的集中贸易能力、协同能力和信息管理能力的平台。它以商业流程和企业应用为核心，将商业流程中功能不同的应用模块通过门户集成在一起，提高公司在集中贸易的能力、协同能力和信息管理能力。\n\n\n## 电子商务\n参与电子商务的实体有四类：客户（个人消费者或者集团）、商户（包括销售商、制造商和储运商）、银行（发卡行和收单行）以及认证中心\n\n# 知识管理和商业智能化\n## 商业智能化\n商业智能化的核心技术包括：数据仓库、数据挖掘、联机分析处理。\n商业智能化系统处理过程包括数据预处理、简历数据仓库、数据分析及数据展现：\n\n- 数据预处理——包括数据的抽取、转换、封装\n- 数据仓库——是处理海量数据的基础\n- 数据分析——包括联机分析处理和数据挖掘两部分\n    - 联机分析——处理不仅进行数据汇总、聚集，同事还提供切片、切块、下钻、上卷和旋转等分析功能\n    - 数据挖掘——挖掘数据背后的隐藏知识，通过\n- 数据展现——数据的可视化","slug":"软考/企业信息化和政务信息化","published":1,"date":"2022-08-25T10:38:58.080Z","updated":"2022-08-25T10:39:09.076Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczjl0032vwm1mdhre7or","content":"<h1 id=\"信息系统工程\"><a href=\"#信息系统工程\" class=\"headerlink\" title=\"信息系统工程\"></a>信息系统工程</h1><p>以结构、元素、信息及反馈等进行分析，以达到最优设计、最优规划、最优管理和最优控制的目的。</p>\n<p>系统工程的方法，霍尔提出的三维结构体系，以时间维、空间维、知识维组成的立体结构概括性表示出系统工程的各个阶段、各个步骤及所涉及到的知识范围。</p>\n<p>时间维———是指工作的进度，而于一个具体的工作项目，从制定规划起到一直更新为止，全部过程可分为七个阶段：</p>\n<ul>\n<li>规划阶段——调研、程序设计阶段，目的紫玉谋求活动的规划和战略</li>\n<li>拟定阶段——提出具体的规划方案</li>\n<li>研制阶段——作出研制方案及生产计划</li>\n<li>生产阶段</li>\n<li>安装阶段</li>\n<li>运行阶段</li>\n<li>更新阶段</li>\n</ul>\n<h1 id=\"政府信息化与电子政务\"><a href=\"#政府信息化与电子政务\" class=\"headerlink\" title=\"政府信息化与电子政务\"></a>政府信息化与电子政务</h1><p>电子政务的三个主体：政府、企业及事业单位、大众</p>\n<h1 id=\"企业的信息化与电子商务\"><a href=\"#企业的信息化与电子商务\" class=\"headerlink\" title=\"企业的信息化与电子商务\"></a>企业的信息化与电子商务</h1><h2 id=\"企业信息化\"><a href=\"#企业信息化\" class=\"headerlink\" title=\"企业信息化\"></a>企业信息化</h2><p>企业信息化是指通过IT技术的部署来提供去也的生产运维效率，从而降低经营成本。其中业务流程的管理与知识的挖掘是重要活动。</p>\n<ol>\n<li>企业信息化的是3个需求层次：战略需求、运作需求和技术需求</li>\n</ol>\n<ul>\n<li>战略需求——组织信息化的目标是提升组织的竞争力、为组织的可持续发展提供一个支持环境。从而某种意义上来说信息化对组织不仅仅是服务的手段和实现现有战略的辅助工具；信息化可以报组织战略提升到一个新的水平，为组织带来新的发展契机。</li>\n<li>运作需求——实现战略目标的需要、运作策略的需要、人才培养的需要。</li>\n<li>技术需求——由于系统开发时间过长等问题在信息技术层面对系统的完善、升级、集成和整合提出了需求</li>\n</ul>\n<h2 id=\"企业资源规划——ERP\"><a href=\"#企业资源规划——ERP\" class=\"headerlink\" title=\"企业资源规划——ERP\"></a>企业资源规划——ERP</h2><p>商业智能——通过数据挖掘技术、知识等发现等技术分析和挖掘结构化的、面向特定领域的的数据仓库信息</p>\n<p>ERP系统的三流：物流、资金流、信息流<br>ERP系统时对企业的物流、资金流、信息流进行全面集成的管理信息系统</p>\n<p>ERP系统能够实现的企业决策计划：</p>\n<ul>\n<li>生产预测计划——对市场的需求进行比较准确的预测，是经营计划、生产计划大纲和主生产计划编制的基础</li>\n<li>销售管理计划——对销售部门的相关业务进行管理，属于最高层计划的范畴，是企业决策层最重要的计划之一</li>\n<li>生产计划大纲——根据经营计划生产目标制定</li>\n<li>主生产计划——说明一段时期内生产什么，生产多少盒什么时候交货，它是ERP的主要工作内容。</li>\n<li>物料需求计划是对主生产计划的各个项所需的制造件和全部采购件等计划</li>\n<li>能力需求计划——是对物料需求计划所需的能力进行核算的一种计划管理方法，能够帮助尽早发现企业的生产能力瓶颈，及时补充生产力。</li>\n</ul>\n<p>ERP的信息流：</p>\n<ul>\n<li>需求信息——客户订单、生产计划、采购合同等</li>\n<li>供应信息——入库单、完工报告单、库存记录、可供销售量和提货发货发运单等</li>\n</ul>\n<h2 id=\"客户关系管理——CRM\"><a href=\"#客户关系管理——CRM\" class=\"headerlink\" title=\"客户关系管理——CRM\"></a>客户关系管理——CRM</h2><p>客户关系管理（CRM）系统将市场营销的科学管理通过信息技术手段集成在软件商，能够帮助企业构建良好的客户关系。<br>CRM是将人力资源、业务流程与专业的技术进行有效的整合，最终为企业涉及到的客户或者消费者的各个领域提供完美的集成，是的企业可以更低成本、更高效率满足客户的需求。<br>其主要功能包括：</p>\n<ul>\n<li>销售自动化——是其中最为基本的模块</li>\n<li>营销自动化——作为销售自动化的补充，包括营销计划的编制和执行、计划结果分析等。</li>\n<li>客户服务支持——是系统的重要功能</li>\n<li>商业智能——数据挖掘和处理，为企业决策做支撑。</li>\n</ul>\n<p>CRM系统与ERP系统在财务、制造、库存等环节进行连接，<strong>两种虽然不同但由于两者之间具有一定的关系，因此能够形成一定的闭环反馈结构</strong></p>\n<h2 id=\"企业应用的集成\"><a href=\"#企业应用的集成\" class=\"headerlink\" title=\"企业应用的集成\"></a>企业应用的集成</h2><p>企业应用集成有多种集成模式，构建统一标准的基础平台，将具有不同功能和目的而又独立运行的企业信息联合起来。目前市场上主流的集成模式有三种，分别是<strong>面向信息的集成</strong>、<strong>面向过程的集成</strong>、<strong>面向服务的集成</strong>。</p>\n<ul>\n<li>面向过程集成——强调处理不同应用系统之间的交互逻辑，与核心业务逻辑相分离，并通过不同应用系统之间的协作共同完成某项业务功能。</li>\n<li>面向信息的集成<ul>\n<li>内部信息集成<ul>\n<li>技术平台集成——系统底层的体系结构、软件、硬件及异构网络的特殊需求受限必须得到集成。这个集成包括信息技术硬件的组成</li>\n<li>数据集成，共享数据库，主动记录、数据映射，实现不同的系统数据交流和共享，</li>\n<li>应用系统集成，应用系统集成是实现不同系统之间的相互操作，是的不同应用系统之间能够实现数据和方法的共享</li>\n<li>业务过程的集成，业务过程集成，企业必须在各个业务系统中定义、授权和管理各种业务信息的交流，一遍改进操作、减少成本、提高响应速度。</li>\n</ul>\n</li>\n<li>外部信息集成</li>\n</ul>\n</li>\n<li>面向服务的集成</li>\n</ul>\n<p>集成方式：</p>\n<ul>\n<li>远程过程调用——基于同步的方式，效率较低，二期容易失败；</li>\n<li>共享数据和文件传输——将应用的数据存储在一个共享数据库中，通过制定统一的数据库模式来处理不同应用的集成需求，共享数据库为不同的应用提供了统一的数据存储和格式定义。性能方面较差，系统不能保持即时数据同步，而容易造成应用于数据紧耦合；</li>\n<li>消息传递方式——能够保证数据异步、立即、可靠传输</li>\n</ul>\n<p>集成平台提供的基本功能包括：</p>\n<ul>\n<li>数据通信服务：提供分布环境下的透明同步、异步通信的服务功能</li>\n<li>信息集成服务：为应用提供透明的信息访问服务，实现不同数据库之间的数据交换、相互操作、分布数据管理和共享信息模型的定义</li>\n<li>应用集成服务：通过高层应用编程接口实现对相应应用程序的访问，能够为应用提供数据交换和访问的操作，是的各个系统相互协作。</li>\n<li>二次开发工具：帮助用户开发特定应用程序的支持工具</li>\n<li>平台运行管理工具：是企业集成平台和运作的管理控制面板。</li>\n</ul>\n<p>电子数据交换——EDI<br>EDI的实施需要一个公认的标准和协议，将商务活动中涉及到的文件标准化和格式化；EDI通过计算机网络，在贸易伙伴之间进行数据交换和自动处理</p>\n<p>企业门户是一个信息技术平台，可提供个性化的信息服务，为企业提供一个单一的访问企业各种信息资源和应用的程序入口。</p>\n<p>分为3中门户类型：</p>\n<ul>\n<li>企业信息门户——企业信息门户强调为访问结构数据和无结构数据提供统一的入口，实现收集、访问、管理和无缝集成</li>\n<li>企业知识门户——提供一个创造、搜集和传播企业知识的平台，通过企业知识门户，员工与工作团队中的其他成员取得联系，寻找能够提供帮助的专家。</li>\n<li>企业应用门户——是一个用来提供企业的集中贸易能力、协同能力和信息管理能力的平台。它以商业流程和企业应用为核心，将商业流程中功能不同的应用模块通过门户集成在一起，提高公司在集中贸易的能力、协同能力和信息管理能力。</li>\n</ul>\n<h2 id=\"电子商务\"><a href=\"#电子商务\" class=\"headerlink\" title=\"电子商务\"></a>电子商务</h2><p>参与电子商务的实体有四类：客户（个人消费者或者集团）、商户（包括销售商、制造商和储运商）、银行（发卡行和收单行）以及认证中心</p>\n<h1 id=\"知识管理和商业智能化\"><a href=\"#知识管理和商业智能化\" class=\"headerlink\" title=\"知识管理和商业智能化\"></a>知识管理和商业智能化</h1><h2 id=\"商业智能化\"><a href=\"#商业智能化\" class=\"headerlink\" title=\"商业智能化\"></a>商业智能化</h2><p>商业智能化的核心技术包括：数据仓库、数据挖掘、联机分析处理。<br>商业智能化系统处理过程包括数据预处理、简历数据仓库、数据分析及数据展现：</p>\n<ul>\n<li>数据预处理——包括数据的抽取、转换、封装</li>\n<li>数据仓库——是处理海量数据的基础</li>\n<li>数据分析——包括联机分析处理和数据挖掘两部分<ul>\n<li>联机分析——处理不仅进行数据汇总、聚集，同事还提供切片、切块、下钻、上卷和旋转等分析功能</li>\n<li>数据挖掘——挖掘数据背后的隐藏知识，通过</li>\n</ul>\n</li>\n<li>数据展现——数据的可视化</li>\n</ul>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"信息系统工程\"><a href=\"#信息系统工程\" class=\"headerlink\" title=\"信息系统工程\"></a>信息系统工程</h1><p>以结构、元素、信息及反馈等进行分析，以达到最优设计、最优规划、最优管理和最优控制的目的。</p>\n<p>系统工程的方法，霍尔提出的三维结构体系，以时间维、空间维、知识维组成的立体结构概括性表示出系统工程的各个阶段、各个步骤及所涉及到的知识范围。</p>\n<p>时间维———是指工作的进度，而于一个具体的工作项目，从制定规划起到一直更新为止，全部过程可分为七个阶段：</p>\n<ul>\n<li>规划阶段——调研、程序设计阶段，目的紫玉谋求活动的规划和战略</li>\n<li>拟定阶段——提出具体的规划方案</li>\n<li>研制阶段——作出研制方案及生产计划</li>\n<li>生产阶段</li>\n<li>安装阶段</li>\n<li>运行阶段</li>\n<li>更新阶段</li>\n</ul>\n<h1 id=\"政府信息化与电子政务\"><a href=\"#政府信息化与电子政务\" class=\"headerlink\" title=\"政府信息化与电子政务\"></a>政府信息化与电子政务</h1><p>电子政务的三个主体：政府、企业及事业单位、大众</p>\n<h1 id=\"企业的信息化与电子商务\"><a href=\"#企业的信息化与电子商务\" class=\"headerlink\" title=\"企业的信息化与电子商务\"></a>企业的信息化与电子商务</h1><h2 id=\"企业信息化\"><a href=\"#企业信息化\" class=\"headerlink\" title=\"企业信息化\"></a>企业信息化</h2><p>企业信息化是指通过IT技术的部署来提供去也的生产运维效率，从而降低经营成本。其中业务流程的管理与知识的挖掘是重要活动。</p>\n<ol>\n<li>企业信息化的是3个需求层次：战略需求、运作需求和技术需求</li>\n</ol>\n<ul>\n<li>战略需求——组织信息化的目标是提升组织的竞争力、为组织的可持续发展提供一个支持环境。从而某种意义上来说信息化对组织不仅仅是服务的手段和实现现有战略的辅助工具；信息化可以报组织战略提升到一个新的水平，为组织带来新的发展契机。</li>\n<li>运作需求——实现战略目标的需要、运作策略的需要、人才培养的需要。</li>\n<li>技术需求——由于系统开发时间过长等问题在信息技术层面对系统的完善、升级、集成和整合提出了需求</li>\n</ul>\n<h2 id=\"企业资源规划——ERP\"><a href=\"#企业资源规划——ERP\" class=\"headerlink\" title=\"企业资源规划——ERP\"></a>企业资源规划——ERP</h2><p>商业智能——通过数据挖掘技术、知识等发现等技术分析和挖掘结构化的、面向特定领域的的数据仓库信息</p>\n<p>ERP系统的三流：物流、资金流、信息流<br>ERP系统时对企业的物流、资金流、信息流进行全面集成的管理信息系统</p>\n<p>ERP系统能够实现的企业决策计划：</p>\n<ul>\n<li>生产预测计划——对市场的需求进行比较准确的预测，是经营计划、生产计划大纲和主生产计划编制的基础</li>\n<li>销售管理计划——对销售部门的相关业务进行管理，属于最高层计划的范畴，是企业决策层最重要的计划之一</li>\n<li>生产计划大纲——根据经营计划生产目标制定</li>\n<li>主生产计划——说明一段时期内生产什么，生产多少盒什么时候交货，它是ERP的主要工作内容。</li>\n<li>物料需求计划是对主生产计划的各个项所需的制造件和全部采购件等计划</li>\n<li>能力需求计划——是对物料需求计划所需的能力进行核算的一种计划管理方法，能够帮助尽早发现企业的生产能力瓶颈，及时补充生产力。</li>\n</ul>\n<p>ERP的信息流：</p>\n<ul>\n<li>需求信息——客户订单、生产计划、采购合同等</li>\n<li>供应信息——入库单、完工报告单、库存记录、可供销售量和提货发货发运单等</li>\n</ul>\n<h2 id=\"客户关系管理——CRM\"><a href=\"#客户关系管理——CRM\" class=\"headerlink\" title=\"客户关系管理——CRM\"></a>客户关系管理——CRM</h2><p>客户关系管理（CRM）系统将市场营销的科学管理通过信息技术手段集成在软件商，能够帮助企业构建良好的客户关系。<br>CRM是将人力资源、业务流程与专业的技术进行有效的整合，最终为企业涉及到的客户或者消费者的各个领域提供完美的集成，是的企业可以更低成本、更高效率满足客户的需求。<br>其主要功能包括：</p>\n<ul>\n<li>销售自动化——是其中最为基本的模块</li>\n<li>营销自动化——作为销售自动化的补充，包括营销计划的编制和执行、计划结果分析等。</li>\n<li>客户服务支持——是系统的重要功能</li>\n<li>商业智能——数据挖掘和处理，为企业决策做支撑。</li>\n</ul>\n<p>CRM系统与ERP系统在财务、制造、库存等环节进行连接，<strong>两种虽然不同但由于两者之间具有一定的关系，因此能够形成一定的闭环反馈结构</strong></p>\n<h2 id=\"企业应用的集成\"><a href=\"#企业应用的集成\" class=\"headerlink\" title=\"企业应用的集成\"></a>企业应用的集成</h2><p>企业应用集成有多种集成模式，构建统一标准的基础平台，将具有不同功能和目的而又独立运行的企业信息联合起来。目前市场上主流的集成模式有三种，分别是<strong>面向信息的集成</strong>、<strong>面向过程的集成</strong>、<strong>面向服务的集成</strong>。</p>\n<ul>\n<li>面向过程集成——强调处理不同应用系统之间的交互逻辑，与核心业务逻辑相分离，并通过不同应用系统之间的协作共同完成某项业务功能。</li>\n<li>面向信息的集成<ul>\n<li>内部信息集成<ul>\n<li>技术平台集成——系统底层的体系结构、软件、硬件及异构网络的特殊需求受限必须得到集成。这个集成包括信息技术硬件的组成</li>\n<li>数据集成，共享数据库，主动记录、数据映射，实现不同的系统数据交流和共享，</li>\n<li>应用系统集成，应用系统集成是实现不同系统之间的相互操作，是的不同应用系统之间能够实现数据和方法的共享</li>\n<li>业务过程的集成，业务过程集成，企业必须在各个业务系统中定义、授权和管理各种业务信息的交流，一遍改进操作、减少成本、提高响应速度。</li>\n</ul>\n</li>\n<li>外部信息集成</li>\n</ul>\n</li>\n<li>面向服务的集成</li>\n</ul>\n<p>集成方式：</p>\n<ul>\n<li>远程过程调用——基于同步的方式，效率较低，二期容易失败；</li>\n<li>共享数据和文件传输——将应用的数据存储在一个共享数据库中，通过制定统一的数据库模式来处理不同应用的集成需求，共享数据库为不同的应用提供了统一的数据存储和格式定义。性能方面较差，系统不能保持即时数据同步，而容易造成应用于数据紧耦合；</li>\n<li>消息传递方式——能够保证数据异步、立即、可靠传输</li>\n</ul>\n<p>集成平台提供的基本功能包括：</p>\n<ul>\n<li>数据通信服务：提供分布环境下的透明同步、异步通信的服务功能</li>\n<li>信息集成服务：为应用提供透明的信息访问服务，实现不同数据库之间的数据交换、相互操作、分布数据管理和共享信息模型的定义</li>\n<li>应用集成服务：通过高层应用编程接口实现对相应应用程序的访问，能够为应用提供数据交换和访问的操作，是的各个系统相互协作。</li>\n<li>二次开发工具：帮助用户开发特定应用程序的支持工具</li>\n<li>平台运行管理工具：是企业集成平台和运作的管理控制面板。</li>\n</ul>\n<p>电子数据交换——EDI<br>EDI的实施需要一个公认的标准和协议，将商务活动中涉及到的文件标准化和格式化；EDI通过计算机网络，在贸易伙伴之间进行数据交换和自动处理</p>\n<p>企业门户是一个信息技术平台，可提供个性化的信息服务，为企业提供一个单一的访问企业各种信息资源和应用的程序入口。</p>\n<p>分为3中门户类型：</p>\n<ul>\n<li>企业信息门户——企业信息门户强调为访问结构数据和无结构数据提供统一的入口，实现收集、访问、管理和无缝集成</li>\n<li>企业知识门户——提供一个创造、搜集和传播企业知识的平台，通过企业知识门户，员工与工作团队中的其他成员取得联系，寻找能够提供帮助的专家。</li>\n<li>企业应用门户——是一个用来提供企业的集中贸易能力、协同能力和信息管理能力的平台。它以商业流程和企业应用为核心，将商业流程中功能不同的应用模块通过门户集成在一起，提高公司在集中贸易的能力、协同能力和信息管理能力。</li>\n</ul>\n<h2 id=\"电子商务\"><a href=\"#电子商务\" class=\"headerlink\" title=\"电子商务\"></a>电子商务</h2><p>参与电子商务的实体有四类：客户（个人消费者或者集团）、商户（包括销售商、制造商和储运商）、银行（发卡行和收单行）以及认证中心</p>\n<h1 id=\"知识管理和商业智能化\"><a href=\"#知识管理和商业智能化\" class=\"headerlink\" title=\"知识管理和商业智能化\"></a>知识管理和商业智能化</h1><h2 id=\"商业智能化\"><a href=\"#商业智能化\" class=\"headerlink\" title=\"商业智能化\"></a>商业智能化</h2><p>商业智能化的核心技术包括：数据仓库、数据挖掘、联机分析处理。<br>商业智能化系统处理过程包括数据预处理、简历数据仓库、数据分析及数据展现：</p>\n<ul>\n<li>数据预处理——包括数据的抽取、转换、封装</li>\n<li>数据仓库——是处理海量数据的基础</li>\n<li>数据分析——包括联机分析处理和数据挖掘两部分<ul>\n<li>联机分析——处理不仅进行数据汇总、聚集，同事还提供切片、切块、下钻、上卷和旋转等分析功能</li>\n<li>数据挖掘——挖掘数据背后的隐藏知识，通过</li>\n</ul>\n</li>\n<li>数据展现——数据的可视化</li>\n</ul>\n"},{"_content":"> 前言：软件开发方法是软件开发的方法学，旨在提供软件的质量，降低开发成本\n\n# 1 软件生命周期\n\n 1. 可行性研究和规划：通过可行性分析确认原件的必要性，价值点，初步确认软件的目标、范围、风险和开发成本等内容。\n 2. 需求分析：需求分析是开发过程的重要阶段，初步确认软件开发的目标和范围，之后则要对软件的需求进行细致分析，确认最终要做成什么样子。这个过程极其重要，如果这个阶段出现分析错误和偏差将导致后续开发过程偏离真实需求越远，修正的成本越大。\n 3. 概要设计：是程序员开发过程中的蓝图，包括确认系统架构、各个子系统依赖关系、数据库模型、编码规范、接口规约等内容\n 4. 详细设计：详细设计师开发之前的最后设计，是在概要设计的基础上进行进行细化，如类设计。详细设计不是必要过程，在规模较小，功能结构简单的系统中可以省略。\n 5. 实现：针对设计的单元模块进行开发，如一个过程、方法、函数，包括实现单元模块的单元测试\n 6. 集成测试：对单元模块进行组装联调测试\n 7. 确认测试：系统开发完后，需要验证是否和需求预期一致\n 8. 软件使用和维护：软件投入试运行，并不断对过程中出现的问题进行维护修正，软件维护郭晨会贯穿整个软件的使用郭晨直至软件自然消亡。\n\n\n# 2 软件开发模型\n计算机刚刚诞生的年代，是一种只有天才才能掌握的巩固，人们对软件知识的认知仅仅停留在程序层面。随着技术发展，软件复杂度的提高，意识到必须遵循一定的开发方法才能取得成功，于是出现了模式化的开发方法称为开发模型。\n\n## 2.1 瀑布模型\n\n特点：\n1. 软件过程要经过需求分析、总体设计、详细设计、编码、调试、集成测试和系统测试阶段，开发阶段划分明确\n2. 再每一个阶段结算后都有不定的文档或者程序流入下一个阶段\n3. 每个阶段在发现问题时可以反馈给上一个阶段进行修正\n适用场景：需求明确、稳定时\n\n### 2.1.1 瀑布V模型\n同标准瀑布模型一样，保持了瀑布模型的阶段式文档驱动的特点，但是更强调软件产品的验证工作，即需求分析的记过将作为系统测试的标准，能够在设计初期得到验证，以此类推，总体设计对应了集成测试，详细设计对应了单元测试。\n\n### 2.1.2 瀑布模型的缺点\n1. 需求分析是一切活动的基础，如果需求分析出现偏差，将导致后续活动放大这个偏差。但事实是，由于用户、开发者立场、经验不同、知识领域不同，对同一事物的表述不同造成的理解偏差难于避免，导致后期维护工作繁重\n2. 难于适应需求变化，一旦需求变更要重头再来\n3. 从需求提出到最后看到产品是一个相当长的过程，不能及时给用户反馈，并验证是否是能够满足客户需求的软件。\n4. 瀑布模型是面向文档的开发模型，过程中将产生大量文档，大部分对客户没有意义，但却工作量繁重\n\n## 2.2 演化模型\n演化模型是在瀑布模型难以一次性完全理解用户需求的基础上，对整个过程进行若干次的“瀑布模型”迭代，做到不断渐进、不断深入的过程\n\n## 2.3 螺旋模型\n螺旋模型是在瀑布模型和演化模型结合的基础上，还强调其他模型忽略的风险分析。\n特点：\n1. 螺旋模型对每一期都包含需求定义、风险分析、工程实现、和评审4个阶段，对整个过程进行螺旋式迭代\n2. 支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供方便，降低软件开发风险\n\n缺点：\n1. 螺旋模型的风险评估需要具有丰富风险评估经验和专业知识的人，否则将造成重大损失\n2. 过多的迭代次数会增加开发成本，延迟提交时间\n\n## 2.4 增量模型\n演化模型是另外一种增量模型的形式。在系统架构成熟、风险较低时，可采用增量方式进行系统开发，可提前进行基础测试和系统测试，缩短出事版本的发布周期，提高用户对系统的可见度。\n特点：\n1. 增量模型，做好系统的分析和设计，对系统划分为若干不同的版本，每一个版本都是完成可用的系统，后一个版本是前一个版本的基础进行开发，扩展前一个版本的功能，同时保证每个版本增量均匀。\n2. 原型法，每一次发布都经历完成的生命周期，当用户需求很多不明确或者技术架构中很多不可知因素时，可采用原型增量法。在初始版本的原型并不考虑需求的合理性和系统稳定性，只为精准获取用户需求，一般会在后面的开发中抛弃这个原型进行完成的系统实现。\n\n## 2.5 构件组装模型\n\n将系统划分为一组构件的集合，明确构件之间的关系。每个构件可以独立开发、自包容，可以是自己开发设计，也可以是第三方购买整合。最后进行构件组装的一个开发模型。\n构件组装优点：\n1. 构件自包容让系统扩展变得更加容易\n2. 良好的构件更容易重用，降低开发成本\n3. 构件力度较整个系统更小，更容易开发设计及安排工作更加灵活\n\n缺点：\n1. 对构件设计需要经验丰富的架构设计师，设计不良的构件难以实现他的优点\n2. 考虑重用度是，往往会对其他方面设计做出让步，比如性能\n3. 构件组装应用是，要求程序员熟悉掌握构件，增加了开发人员的学习成本\n4. 第三方构件质量难以把控，将影响软件的质量。\n\n# 3 统一过程模型\n统一过程（Unified Process, UP）是一种优秀的软件开发模型，可以有效地降低软件开发过程中的风险。这个开发模型的特点是每一个阶段的工作都不是绝对的，都是相互交叠配的的，但是每一个阶段都有侧重点。\n\n![](../images/软件开发方法/getImage-20220825183846811.png)\n\n整个过程大致分为\n1. 初始阶段，刚刚接入系统开发工作，侧重工作是明确系统目的，业务建模和需求工作\n2. 细化阶段，抽象软件逻辑模型，设计架构，侧重是分析设计工作\n3. 构件阶段，完成系统的构件，使之成为一个完整的实体，并进行测试和部署\n4. 交付阶段，软件系统需求已经完成，重点工作是对软件进行重构、修改、测试和部署\n\n整个工作内容整体包括：业务建模、需求、分析设计、实施、测试、部署、配置与变更管理、项目管理、环境。\n\n其中“环境”是相对于其他工作难以理解的。环境工作很重要，也称之为环境管理。在软件开发过程中，需要为各种工作准备相应的工作环境，在工作环境中包含必须的工具、活动指南、活动流程规范、工作产品模板、基本的开发设施等。环境管理应该在工作流中得到应有的重视，每个开发团队都有自己的特点和活动准则规范，这种准则和规范是团队协作的基础，万万不能少，否则开发活动就会使放养式的管理。\n\n** UP的生命周期**\n分为4个里程碑\n1. 目标里程碑。明确系统的目标和范围时达到这个里程\n2. 架构里程碑。当开发者确定稳定系统的架构时达到这个里程\n3. 能力里程碑。当系统已经足够稳定和成熟并完成了Alpha测试之后达到这个里程碑\n4. 发布里程碑。当完成系统的测试、完成系统的发布和用户培训工作之后达到这个里程碑\n\nUP的特点：\n1. UP是一个迭代的二维开发模型，每个生命后期都可以进行需求、设计、开发等\n2. 采用不同的迭代方式的UP可以演变为演化模型或增量模型\n3. UP的迭代特点使得更容易控制开发风险\n4. Up是迭代开发模型，但不属于敏捷开发模型。一般未经过裁剪的Up是一个重载过程\n5. 实际应用可根据具体问题进行UP的裁剪，从而使用各种规模的软件和开发团队\n\n架构师在UP活动中的作用\n架构师除了需要建立系统的架构模型外，在UP活动中承担非常重要的角色，例如：\n1. 同需求人员和项目管理人员密切协作\n2. 细化软件架构\n3. 保持整个架构的概念完整性，具体地说就是定义设计方法、设计指南、编码规范、平舌工作\n**因此有人称UP是一个已加购书为中心的开发模型。**\n\n# 4 敏捷开发方法\n2001年，17位“无政府主义者”共同发表了《敏捷软件开发宣言》：\n> 1. 尽早地、持续地向客户交付有价值的软件对开发人员来说是最重要的。\n2. 拥抱变化，即使在开发的后期。敏捷过程能够驾驭变化，保持客户的竞争力。\n3. 经常交付可工作的软件，从几周到几个月，时间范围越小越好。\n4. 在整个项目中，业务人员和开发者紧密合作。\n5. 围绕士气高昂的团队进行开发，为团队成员提供适宜的环境，满足他们的需要，并给予\n足够的信任。\n6. 在团队中，最有效率的、也是效果最好的沟通方式是面对面地交流。\n7. 可以工作的软件是进度首要的度量方式。\n8. 可持续地开发。投资人、开发团队和用户应该保持固定的节奏。\n9. 不断追求优秀的技术和良好的设计有助于提高敏捷性。\n10. 要简单，尽可能减少工作量。减少工作量的艺术是非常重要的。\n11. 最好的架构、需求和设计都来自于一个自我组织的团队。\n12. 团队要定期地总结如何能够更有效率，然后相应地自我调整\n\n这份宣言就是敏捷开发方法的灯塔\n\n## 4.1 敏捷开发方法实践之极限编程（eXtreme Programming）\n极限编程（XP）是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方法。特点如下：\n1. 在更短的周期内，更早地提供具体、持续的反馈信息。\n2. 迭代地进行计划编制。在最开始迅速形成总体计划，然后开发过程中不断迭代发展它\n3. 依赖自动化测试程序来监控开发进度，尽早地铺货缺陷\n4. 依赖口头交流、测试和源程序进行沟通\n5. 倡导持续的、演化式的设计\n6. 依赖于开发团队内部的紧密协作\n7. 尽可能达到程序员的短期利益和长期利益的平衡。即关注短期程序员的自主设计和参与感，同时帮助程序员长期的成长\n\n四大价值观：沟通、简单、反馈、勇气\n1. 沟通。通常，程序员相对内向，不善言谈，项目中的许多问题都发生在缺乏良好的沟通上。而传统的开发方法中并不太在意这种口头的沟通，而是希望通过完善的流程和面面俱到的文档、报表、计划来代替，这同时就引入了效率不高的问题，往往一个小问题通过漫长的流程下来被放大。而XP方法认为，如果小组内成员无法做到持续的、无间断的交流，协作就无从谈起，XP鼓励大家进行口头的面对面交流快速解决问题，提高效率。\n2. 简单。XP方法的工作中秉承“够用即好”，实现尽可能简单化，不要过度设计。这一点看上去容易，但要做到其实很淡，因为在传统的开发过程中需要开发人员对未来做一些预先的规划，以便后续做扩展预留空间，这是一个平衡的过程，并不是一点都不考虑未来的可扩展性，所以比较难做到\n3. 反馈。传统的开发过程中缺乏对客户必要的反馈，整个开发过程像一个“黑盒子”，过程漫长，完全看不到效果和进度。容易造成最终偏离用户需求的系统软件。XP注重反馈的作用，通过持续的、明确的反馈来暴露软件当前的状态和问题，尽早地纠正一些可以避免的错误。\n4. 勇气。在XP方法中，要有勇气面对每时每刻的变化带来的挑战。由于提倡良好的沟通，会有更多的需求调整；由于提倡系统保持简单，需求变更导致的重构；由于提倡尽早反馈，更多地发现问题并纠正。而面对这些带来的挑战，我们更需要为之提高勇气。因为相比于沟通、简单和反馈带来的挑战，更多的我们是得到了良好的信息同步，尽早地发现了问题，更清晰地理解了用户需求，以及更简单地实现了系统软件。\n\nXP的四大价值观之下，隐藏着一种更深刻的东西，那就是尊重，对人的尊重。因为这一切都是建立在团队成员之间的相互关系、相互理解的基础之上。\n\n### 4.1.1 极限编程的十二个最佳实践\n\n 1. 计划游戏。主要思想是先快速制定一份概要计划，然后随着项目细节的不断清醒，在逐步完善这份计划。“客户负责业务决策，开发负责计算决策”，也就是说系统的范围、下一次迭代发布的时间、用户股市的优先级应有客户决定，而每个用户故事所需的而开发时间、技术成本、如何组件团队、以及开发顺序应有开发团队决定。\n    > 计划游戏开始，客户和开发同坐一屋子，每个人准备一支笔、一些用于记录用户需求的纸片，再准备一个白板就可以开始了。\n    > 1. 客户编写需求故事：由客户谈论系统应该完成什么功能，然后用自然语言词汇写在卡片上\n    > 2. 开发人员进行评估：有客户按优先级将故事需求标注为必须有、希望有、如果有三类，然后又开发人进行估算，优先级由高到低。如果估算的时候感到故事需求太大，不容易估算或者超过2人/周，那么应该进行分解在进行评估\n    > 3. 确定迭代周期：根据用户期望的需求优先级、期望发布的时间结合开发现有资源与用户协商，筛检出能够实现的需求，形成初步的需求计划。\n\n 2. 小型发布。XP方法秉承“持续集成，小步快走”的哲学思维，也就是说每次发布的版本尽可能肖，当然前提是每个版本都有发布的商业价值，值得发布。\n 3. 隐喻。相对而言，隐喻这个令人费解，什么时隐喻呢，字面意思是用来暗示字面意义不相似的事物之间相似的东西。对应到开发过程中就是，需要寻求共识，对系统理解、目标价值以等；还有就是发明共享词汇，通过规范项目中常用通用的业务专有名词，减少不必要的沟通；描述体系结构；并不是每一种情况都能找到合适的隐喻，没必要强求，而是顺其自然。\n 4. 简单设计。强调简单的价值观，引出简单性假设原则。这里说的简单设计并不是忽略设计而是设计不应该一次完成，因为随着业务的变化，可能当时设想的可预知的未来根本就是不存在的，留有适当的扩展设计并满足现有需求的简单设计原则。\n 5. 测试先行。是指注重测试用例程序的编写，不能因为没有时间，工作紧张为由忽略测试工作，这样就会由于没有良好的测试用例而化大把的时间在后续的联调维护阶段，实际上这个整体上市大大降低产能、效率埂底下的做法。\n 6. 重构。重构是一种对待吗进行重写而不影响功能实现的的技术，XP要求在开发人员“问到代码的坏味道”时，就有重构代码的勇气。重构的目的是让代码降低因变化引起的风险、使得代码更加易于维护和阅读。\n 7. 结对编程。一开始虽然会牺牲一些速度，但慢慢的，开发速度会逐步加快，究其原因是结对编程大大降低了沟通成本，提高了工作的质量，具体表现在：\n    1. 所有的设计决策确保不是一个人做出来的\n    2. 系统的任何部分至少有2个人以上熟悉\n    3. 不能能同时2个人都忽略测试项\n    4. 阶段的动态性，是一个去也知识管理的好途径\n    5. 代码总是能够保证评审通过\n    6. XP方法集成的吉他最佳实践能够是的结对编程更加容易进行\n    7. 编码标准能够消除一些无谓的分歧\n    8. 隐喻可以帮助结对伙伴更好沟通\n    9. 简单设计能够是的伙伴更了解他们所从事的工作\n    \n    结对编程技术被誉为XP保持工作质量、强调人文主义的一个典型实践，能够是的开发团队之间的协作更加流畅、知识交流更加频繁、团队更加稳定。\n\n\n 8. 集体代码所有制。有XP方法鼓励团队进行结对编程，而且编程组是动态搭配的，每个人会遇到不同的代码，代码所有制就不是局限于某一个人，而是集体所有制，团队中的每个人都有进行修改的权利，每个人都拥有全部代码，也都需要对全部代码负责。同时XP强调代码是谁该坏的就应该有谁来修复。\n 9. 持续集成。持续集成是最佳实践的基本支撑条件。\n 10. 每周工作40小时。这是一个让开发者开心、管理者反对的一个最佳实践。加班早已成为开发人员的家常便饭，也是管理者最常用的一种策略。而XP方法认为，加班会扼杀团队的积极性，最终导致项目失败，这也体现了XP方法是关注人的因素比关注过程的因素更多一些。这里说的40小时不是绝对的额，是指根据团队公司合理的工作时长。提倡追求有效的、高效的工作时间，而不是绝对的时长。\n 11. 现场客户。为了保证开发出来的结果与客户的预想接近，XP方法认为最重要的是将客户请到现场，保持和客户的现场沟通，并让客户参与到开发决策中来。\n 12. 编码标准。拥有编码标准可以避免团队无关细节的争论。不过这个标准不是越细越好，而是要能够确保代码清晰，便于交流的一个指导方针。\n\nXP方法最大价值在于项目中融会贯通地运用这12个最佳实践，而非单独使用。当然可以使用其中一些实践，单并不意味这就应用了XP方法。\n\n## 4.2 特征驱动开发方法\nFDD也是一个迭代的开发模型。FDD每一步都强调质量，不断地交付可运行的软件，并以很小的开发提供准确的项目进度报告和状态信息。同敏捷开发一样，FDD弱化了过程在软件开发的地位。\n### 4.2.1 FDD的角色定义\nFDD认为，有效的软件开发不可或缺的三个要素是：人、过程和技术。软件开发不能没有过程，也不能没有技术，但最重要的还是人。定义了6中关键角色：\n1. 项目经理。项目开发的组织者，是团队的保护屏障，提供一个适宜的开发环境。\n2. 首席架构设计师。负责系统的架构设计\n3. 开发经理。负责团队日常的开发工作的安排，解决开发过程中的技术问题和资源冲突\n4. 主程序员。主程序员将带领小组完成特征的详细设计和构件工作，一般要求主程序员具有一定的工作经验，并能够带动小组工作。\n5. 程序员。若干个程序员在主程序员带领下完成小组的开发，按照特征开发疾患完成开发\n6. 领域专家。领域专家是指对业务精通的人，一般有客户、系统分析师担当。\n\n### 4.2.2 FDD的最佳实践\nFDD最佳实践包括：领域对象建模、根据特征进行开发、类的个体所有、组成特征小组、审查、定期构造、配置管理、结果的可见性\n其中最有特色的是个体所有，激活所有的而开发模型都是代码共有。但在FDD中，将类分配给特定的任何小组，分配给A小组的代码只能由A来维护，除A外的角色都不能修改它，只能使用它。\n优点是：\n1. 这个类的支配感会促使开发人员产生自豪感，从而更出色地完成任务。不过FDD也提到了类q\n2. 审查也是FDD中很具特设的一项实践。不少人认为审查是非常严格的软件过程特有的，然而FDD中明确将审查作为一项最佳实践。审查是一种很有效的发现缺陷的手段，但经常被忽视，国内的软件组织中很少有严格的审查制度保障软件质量。在开发阶段的代码审查机制能够很好的避免潜在的问题。\n\n缺点：\n1. 项目依赖关系增强，形成代码黑盒，除了负责人没人能修改。\n\n\n## 4.3 Scrum\nScrum是一个用于开发和维护复杂产品框架，是一个增量的、迭代的开发过程。由若干个迭代周期组成，一个短的迭代周期成为Sprint,每个Sprint的建议周期在2到4周。在Scrum中，使用产品的Backlog来管理产品的需求，产品Backlog是一个按商业价值拍下的需求列表。\nScrum团队重产品的Backlog中挑选优先级最高的需求进行开发。\n挑选的需求在sprint的计划会议上进行讨论、分析和估算得到相应的任务列表，称之为Sprint backlog.\n\n### 4.3.1 Scrum的5个活动\n![](../images/软件开发方法/getImage-20220825183846916.png)\n1. 产品待办事项的梳理——Prodct Backlog. 产品待办事项通常会很多，也很宽泛，而且想法会变来变去、优先级也会变化，所以产品待办事项列表的梳理是一个贯穿整个Scrum项目的活动。梳理包括：整理需求、优先级排序、事项分解、归并以及商业价值分析等。待办事项的梳理最好是所有团队成员参与，因为有可能需要其他技术或者团队的参与，而不是单单产品经理。\n2. Sprint计划会议。每个Sprint工作周期以Sprint计划会议作为开始，让团队共同选择和理解即将到来的Sprint工作事项. Sprint计划会议的成功十分依赖产品待办事项列表的质量。Sprint计划会议工作内容有两部分：\n    1. 需要完成那些工作：产品负责人介绍排好序的代办事项，让整个Scrum团队共同理解这些工作。而产品待办事项的数目完全有开发团队决定，开发团队要考虑当天产品的增量状态，团队过去的工作情况，当前生产力等，产品负责人不能强加更多的工作量。\n    2. 如何完成工作：开发团队根据当前的“完成的定义”一起决定如何实现一个产品增量，进行任务分解，前几天的工作分解成小单元，每个单元不超过一天，之后的任务可以稍微大一些，以后再对它进行分解。总之产品和开发团队一起考虑斌讨论产品待办事项，确保每个人对事项的理解一致，最终产出待办事项列表就是“Sprint 待办事项列表”，称之为Sprint Backlog\n\n3. 每日Scrum会议。开发团队自组织，通过每日Scrum会议来确认他们任然可以实现Sprint的目标，每个人说下三点内容：上一个工作日完成了什么、当前工作日计划完成什么、有什么阻碍或风险。一般不超过15分钟。\n4. Sprint评审会议。一个Sprint周期结束时，Scrum团队和相关人员一起评审Sprint的产出，Sprint评审会议向每个人展示当前的产品增量情况，帮助大家了解我们目前的进度到哪里，讨论他们在Sprint过程中看到了什么、有什么想法，并一起探讨下一步如何更好的推进。\n5. Sprint回顾会议。每个Sprint周期结束之后，Scrum团队开回顾会议，目的是回顾一下团队在流程人际关系及工作方面做得如何，识别出团队中做得好的与不好的，并找潜在可以改进的事项，为将来的Sprint提供改进的计划\n\n### 4.3.2 Scrum的5大价值观\n1. 承若——愿意对目标负责\n2. 专注——把你的心思和能力都用到你承诺的工作上去\n3. 开放——Scrum把项目中的一切开放给每个人看，做到信息透明\n4. 尊重——每个人都有他独特的背景和经验，尊重每个人的特点\n5. 勇气——有勇气做出承诺，履行程度，接受别人的尊重\n   \n## 4.4 水晶方法\n水晶方法有七大体系特征：\n1. 经常交付。没过一段时间或者几个月向用户交付可测试运行的代码，让用户有机会发现原来需求是否是他真正想要的，有机会将结果反馈到开发中。\n2. 反思改进。开发过程中难免会遇到一些技术难题、各种烦心事，会影响项目进度，所以我们应该经常在迭代中及时地进行反思和改进，从慌乱的日常开发中，抽一点时间来思考更为行之有效的方法。\n3. 渗透式交流。渗透式交流就是信息交流在团队成员中形成背景听觉，使得成员就像通过渗透一样获取相关信息。团队通过在一个共同的工作空间内，若其中一个成员提出问题，其他成员可以选择关注或不关注，也可以随时加入到讨论中来，选择性地获取相关交流的信息。\n4. 个人安全。当你勇敢指出了困扰你的问题时，你可以不用担心受到报复，应该有保护机制，鼓励大家发现和改正自身的缺点，而不是知而不言，这样就会对团队造成损害，不利于整个团队的协作和稳定。\n5. 焦点。也叫聚焦，明确知道要做什么，然后再安排时间，确保团队成员都清楚地了解他们自己最重要的任务是什么，确保他们能够充分利用时间去完成这些任务。\n6. 与专家用户简历方便的联系。与专家用户简历方便的联系能够给团队提供很好的帮助，例如对业务的专业理解，成品的质量和快速罚款，设计理念和需求背景，用户最新的需求等。\n7. 自动化测试。自动化测试是在开发在修改代码之后能够进行自动化测试，以便发现一些bug，让开发能够及时地进行修复，节省了整体的开发时间，提高效率。\n\n## 4.5 其他敏捷方法——开放式源码\n开放式源码——是指以开放源码的方式运作，特别的就是开发人员可能地域分布很广，这和其他的敏捷方法不同，开放源码的一个好处就是排错的高度并行性，任何人都可以发现错误并修改代码提交给维护者。这里面体现的价值观就是猜测、合作和学习。\n\n# 5 软件重用\n\n软件产品和其他的产品不同，是抽象的，一旦产生就可以无限地复制，因此重复利用软件产品意义重大，可以节约大量的人力物力。软件重用包括：软件产品、源代码、文档、设计思想甚至领域知识。\n常见的重用形式：\n1. 源代码重用。这是简单最常见的重用形式，由于软件系统的复杂性，很难大规模地重用已有代码\n2. 架构重用。这个重用也很常见，随着软件架构风格和设计模式的推广和应用，架构重用已经对软件开发产生了重大影响\n3. 应用框架的重用。随着技术的发展，应用框架的重用变得越来越普遍，如AOP、EJB、Spring等应用框架技术\n4. 商业建模的重用。虽然软件领域各有不同，但是人们可以总结出常用的领域建模的方法，重用这些领域建模可以降低不确定性因素风险。\n5. 文档及过程的重用。有效地重用已有的文档有助于提高开发的效率\n6. 构件的重用。如第三方的组件，中间件等\n7. 软件服务的重用。随着web服务的提出，人们越来越关注服务的重用。例如SOA架构就是一个服务重用的实践，让一类功能收归到一个服务做不同业务软件的重用服务。\n\n# 6 基于架构的软件设计\n基于架构的软件设计（Architecture-Based Software Design,ABSD）是一种架构驱动的设计方法，这种方法有3个基础：\n1. 功能分解。在功能分解中，ABSD方法使用已有的基于模块内聚和耦合技术\n2. 通过选择架构风格来实现质量和业务需求\n3. 软件模板的使用。软件模板利用了一些软件系统的结构。\n\nABSB模型是吧整个过程划分为：架构需求、设计、文档化、复审、实现和演化\n\n## 6.1 ABSB方法与生命周期\n![](../images/软件开发方法/getImage-20220825183846654.png)\n\n## 6.2 基于架构的软件开发模型\n基于架构的软件开发模型（Architecture-Based Software Design Model，ABSDM）把整个基于架构的软件过程划分为架构需求、架构设计、架构文档化、架构复审、架构实现和架构演化6个子过程：\n![](../images/软件开发方法/getImage-20220825183846024.png)\n\n1. 机构需求。是指用户对目标软件在系统功能、行为、性能、设计约束方面的期望。通过用户的需求，架构师根据技术环境和架构师经验标注出所需要的构件，最后进行需求的评审。必要时“需求获取——标识构件——需求评审”之间进行迭代。\n2. 架构设计。根据架构需求提出架构的模型、映射构件、分析构件相互作用、产生架构、设计评审\n3. 架构文档化。绝大多数架构都是抽象的，有一些概念的构件组成。为了开发人员更好地理解和实现架构，必须把架构进行文档化描述\n3. 架构复审。架构设计完成之后要安排一次由外部人员（用户和领域专家）参与的复审，其目的是识别潜在的风险，及早发现架构设计中的缺陷和错误，包括架构能否满足需求、质量需求是否得到体现、是否清晰、构件是否划分合理、文档标识是否明确、以及构架设计是否满足功能和性能要求等等\n4. 架构实现。开发人员根据复审后的架构文档，分析和实现其中的构件，然后组装测试的一个过程。\n5. 架构演化。在架构开发中，用户的需求可能变动，在开发完成正常运行后，也可能发生需求变化。那么就要相应地调整架构以适应新的软件需求。主要过程包括这7个步骤：需求变动归类、架构演化计划、构件变动、更新构件的相互作用关系、构件组装和测试、技术评审、技术评审，最后得出演化后的架构设计。\n\n# 7 形式化方法\n形式化方法是指采用严格的数据方法对软件的描述、开发和验证的过程进行严格规约的一种方法，通过这种方式可以需求和定义人员与开发人员的理解偏差，避免模糊性和二义性。通过形式化描述进行需求分析的质量大大提高，很多自然语言描述无法避免的缺陷在需求分析阶段就会被发现并等到解决，从而降低了后期的开发和维护的成本。形式化描述可以通过计算计算进行自动处理（一些专业软件），进行一致性检查和证明。\n一般一些安全要求较高的，如地铁、高铁、航空、核电等软件会考虑使用这种开发方法来保证系统的安全和可靠性。","source":"_posts/软考/软件开发方法.md","raw":"> 前言：软件开发方法是软件开发的方法学，旨在提供软件的质量，降低开发成本\n\n# 1 软件生命周期\n\n 1. 可行性研究和规划：通过可行性分析确认原件的必要性，价值点，初步确认软件的目标、范围、风险和开发成本等内容。\n 2. 需求分析：需求分析是开发过程的重要阶段，初步确认软件开发的目标和范围，之后则要对软件的需求进行细致分析，确认最终要做成什么样子。这个过程极其重要，如果这个阶段出现分析错误和偏差将导致后续开发过程偏离真实需求越远，修正的成本越大。\n 3. 概要设计：是程序员开发过程中的蓝图，包括确认系统架构、各个子系统依赖关系、数据库模型、编码规范、接口规约等内容\n 4. 详细设计：详细设计师开发之前的最后设计，是在概要设计的基础上进行进行细化，如类设计。详细设计不是必要过程，在规模较小，功能结构简单的系统中可以省略。\n 5. 实现：针对设计的单元模块进行开发，如一个过程、方法、函数，包括实现单元模块的单元测试\n 6. 集成测试：对单元模块进行组装联调测试\n 7. 确认测试：系统开发完后，需要验证是否和需求预期一致\n 8. 软件使用和维护：软件投入试运行，并不断对过程中出现的问题进行维护修正，软件维护郭晨会贯穿整个软件的使用郭晨直至软件自然消亡。\n\n\n# 2 软件开发模型\n计算机刚刚诞生的年代，是一种只有天才才能掌握的巩固，人们对软件知识的认知仅仅停留在程序层面。随着技术发展，软件复杂度的提高，意识到必须遵循一定的开发方法才能取得成功，于是出现了模式化的开发方法称为开发模型。\n\n## 2.1 瀑布模型\n\n特点：\n1. 软件过程要经过需求分析、总体设计、详细设计、编码、调试、集成测试和系统测试阶段，开发阶段划分明确\n2. 再每一个阶段结算后都有不定的文档或者程序流入下一个阶段\n3. 每个阶段在发现问题时可以反馈给上一个阶段进行修正\n适用场景：需求明确、稳定时\n\n### 2.1.1 瀑布V模型\n同标准瀑布模型一样，保持了瀑布模型的阶段式文档驱动的特点，但是更强调软件产品的验证工作，即需求分析的记过将作为系统测试的标准，能够在设计初期得到验证，以此类推，总体设计对应了集成测试，详细设计对应了单元测试。\n\n### 2.1.2 瀑布模型的缺点\n1. 需求分析是一切活动的基础，如果需求分析出现偏差，将导致后续活动放大这个偏差。但事实是，由于用户、开发者立场、经验不同、知识领域不同，对同一事物的表述不同造成的理解偏差难于避免，导致后期维护工作繁重\n2. 难于适应需求变化，一旦需求变更要重头再来\n3. 从需求提出到最后看到产品是一个相当长的过程，不能及时给用户反馈，并验证是否是能够满足客户需求的软件。\n4. 瀑布模型是面向文档的开发模型，过程中将产生大量文档，大部分对客户没有意义，但却工作量繁重\n\n## 2.2 演化模型\n演化模型是在瀑布模型难以一次性完全理解用户需求的基础上，对整个过程进行若干次的“瀑布模型”迭代，做到不断渐进、不断深入的过程\n\n## 2.3 螺旋模型\n螺旋模型是在瀑布模型和演化模型结合的基础上，还强调其他模型忽略的风险分析。\n特点：\n1. 螺旋模型对每一期都包含需求定义、风险分析、工程实现、和评审4个阶段，对整个过程进行螺旋式迭代\n2. 支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供方便，降低软件开发风险\n\n缺点：\n1. 螺旋模型的风险评估需要具有丰富风险评估经验和专业知识的人，否则将造成重大损失\n2. 过多的迭代次数会增加开发成本，延迟提交时间\n\n## 2.4 增量模型\n演化模型是另外一种增量模型的形式。在系统架构成熟、风险较低时，可采用增量方式进行系统开发，可提前进行基础测试和系统测试，缩短出事版本的发布周期，提高用户对系统的可见度。\n特点：\n1. 增量模型，做好系统的分析和设计，对系统划分为若干不同的版本，每一个版本都是完成可用的系统，后一个版本是前一个版本的基础进行开发，扩展前一个版本的功能，同时保证每个版本增量均匀。\n2. 原型法，每一次发布都经历完成的生命周期，当用户需求很多不明确或者技术架构中很多不可知因素时，可采用原型增量法。在初始版本的原型并不考虑需求的合理性和系统稳定性，只为精准获取用户需求，一般会在后面的开发中抛弃这个原型进行完成的系统实现。\n\n## 2.5 构件组装模型\n\n将系统划分为一组构件的集合，明确构件之间的关系。每个构件可以独立开发、自包容，可以是自己开发设计，也可以是第三方购买整合。最后进行构件组装的一个开发模型。\n构件组装优点：\n1. 构件自包容让系统扩展变得更加容易\n2. 良好的构件更容易重用，降低开发成本\n3. 构件力度较整个系统更小，更容易开发设计及安排工作更加灵活\n\n缺点：\n1. 对构件设计需要经验丰富的架构设计师，设计不良的构件难以实现他的优点\n2. 考虑重用度是，往往会对其他方面设计做出让步，比如性能\n3. 构件组装应用是，要求程序员熟悉掌握构件，增加了开发人员的学习成本\n4. 第三方构件质量难以把控，将影响软件的质量。\n\n# 3 统一过程模型\n统一过程（Unified Process, UP）是一种优秀的软件开发模型，可以有效地降低软件开发过程中的风险。这个开发模型的特点是每一个阶段的工作都不是绝对的，都是相互交叠配的的，但是每一个阶段都有侧重点。\n\n![](../images/软件开发方法/getImage-20220825183846811.png)\n\n整个过程大致分为\n1. 初始阶段，刚刚接入系统开发工作，侧重工作是明确系统目的，业务建模和需求工作\n2. 细化阶段，抽象软件逻辑模型，设计架构，侧重是分析设计工作\n3. 构件阶段，完成系统的构件，使之成为一个完整的实体，并进行测试和部署\n4. 交付阶段，软件系统需求已经完成，重点工作是对软件进行重构、修改、测试和部署\n\n整个工作内容整体包括：业务建模、需求、分析设计、实施、测试、部署、配置与变更管理、项目管理、环境。\n\n其中“环境”是相对于其他工作难以理解的。环境工作很重要，也称之为环境管理。在软件开发过程中，需要为各种工作准备相应的工作环境，在工作环境中包含必须的工具、活动指南、活动流程规范、工作产品模板、基本的开发设施等。环境管理应该在工作流中得到应有的重视，每个开发团队都有自己的特点和活动准则规范，这种准则和规范是团队协作的基础，万万不能少，否则开发活动就会使放养式的管理。\n\n** UP的生命周期**\n分为4个里程碑\n1. 目标里程碑。明确系统的目标和范围时达到这个里程\n2. 架构里程碑。当开发者确定稳定系统的架构时达到这个里程\n3. 能力里程碑。当系统已经足够稳定和成熟并完成了Alpha测试之后达到这个里程碑\n4. 发布里程碑。当完成系统的测试、完成系统的发布和用户培训工作之后达到这个里程碑\n\nUP的特点：\n1. UP是一个迭代的二维开发模型，每个生命后期都可以进行需求、设计、开发等\n2. 采用不同的迭代方式的UP可以演变为演化模型或增量模型\n3. UP的迭代特点使得更容易控制开发风险\n4. Up是迭代开发模型，但不属于敏捷开发模型。一般未经过裁剪的Up是一个重载过程\n5. 实际应用可根据具体问题进行UP的裁剪，从而使用各种规模的软件和开发团队\n\n架构师在UP活动中的作用\n架构师除了需要建立系统的架构模型外，在UP活动中承担非常重要的角色，例如：\n1. 同需求人员和项目管理人员密切协作\n2. 细化软件架构\n3. 保持整个架构的概念完整性，具体地说就是定义设计方法、设计指南、编码规范、平舌工作\n**因此有人称UP是一个已加购书为中心的开发模型。**\n\n# 4 敏捷开发方法\n2001年，17位“无政府主义者”共同发表了《敏捷软件开发宣言》：\n> 1. 尽早地、持续地向客户交付有价值的软件对开发人员来说是最重要的。\n2. 拥抱变化，即使在开发的后期。敏捷过程能够驾驭变化，保持客户的竞争力。\n3. 经常交付可工作的软件，从几周到几个月，时间范围越小越好。\n4. 在整个项目中，业务人员和开发者紧密合作。\n5. 围绕士气高昂的团队进行开发，为团队成员提供适宜的环境，满足他们的需要，并给予\n足够的信任。\n6. 在团队中，最有效率的、也是效果最好的沟通方式是面对面地交流。\n7. 可以工作的软件是进度首要的度量方式。\n8. 可持续地开发。投资人、开发团队和用户应该保持固定的节奏。\n9. 不断追求优秀的技术和良好的设计有助于提高敏捷性。\n10. 要简单，尽可能减少工作量。减少工作量的艺术是非常重要的。\n11. 最好的架构、需求和设计都来自于一个自我组织的团队。\n12. 团队要定期地总结如何能够更有效率，然后相应地自我调整\n\n这份宣言就是敏捷开发方法的灯塔\n\n## 4.1 敏捷开发方法实践之极限编程（eXtreme Programming）\n极限编程（XP）是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方法。特点如下：\n1. 在更短的周期内，更早地提供具体、持续的反馈信息。\n2. 迭代地进行计划编制。在最开始迅速形成总体计划，然后开发过程中不断迭代发展它\n3. 依赖自动化测试程序来监控开发进度，尽早地铺货缺陷\n4. 依赖口头交流、测试和源程序进行沟通\n5. 倡导持续的、演化式的设计\n6. 依赖于开发团队内部的紧密协作\n7. 尽可能达到程序员的短期利益和长期利益的平衡。即关注短期程序员的自主设计和参与感，同时帮助程序员长期的成长\n\n四大价值观：沟通、简单、反馈、勇气\n1. 沟通。通常，程序员相对内向，不善言谈，项目中的许多问题都发生在缺乏良好的沟通上。而传统的开发方法中并不太在意这种口头的沟通，而是希望通过完善的流程和面面俱到的文档、报表、计划来代替，这同时就引入了效率不高的问题，往往一个小问题通过漫长的流程下来被放大。而XP方法认为，如果小组内成员无法做到持续的、无间断的交流，协作就无从谈起，XP鼓励大家进行口头的面对面交流快速解决问题，提高效率。\n2. 简单。XP方法的工作中秉承“够用即好”，实现尽可能简单化，不要过度设计。这一点看上去容易，但要做到其实很淡，因为在传统的开发过程中需要开发人员对未来做一些预先的规划，以便后续做扩展预留空间，这是一个平衡的过程，并不是一点都不考虑未来的可扩展性，所以比较难做到\n3. 反馈。传统的开发过程中缺乏对客户必要的反馈，整个开发过程像一个“黑盒子”，过程漫长，完全看不到效果和进度。容易造成最终偏离用户需求的系统软件。XP注重反馈的作用，通过持续的、明确的反馈来暴露软件当前的状态和问题，尽早地纠正一些可以避免的错误。\n4. 勇气。在XP方法中，要有勇气面对每时每刻的变化带来的挑战。由于提倡良好的沟通，会有更多的需求调整；由于提倡系统保持简单，需求变更导致的重构；由于提倡尽早反馈，更多地发现问题并纠正。而面对这些带来的挑战，我们更需要为之提高勇气。因为相比于沟通、简单和反馈带来的挑战，更多的我们是得到了良好的信息同步，尽早地发现了问题，更清晰地理解了用户需求，以及更简单地实现了系统软件。\n\nXP的四大价值观之下，隐藏着一种更深刻的东西，那就是尊重，对人的尊重。因为这一切都是建立在团队成员之间的相互关系、相互理解的基础之上。\n\n### 4.1.1 极限编程的十二个最佳实践\n\n 1. 计划游戏。主要思想是先快速制定一份概要计划，然后随着项目细节的不断清醒，在逐步完善这份计划。“客户负责业务决策，开发负责计算决策”，也就是说系统的范围、下一次迭代发布的时间、用户股市的优先级应有客户决定，而每个用户故事所需的而开发时间、技术成本、如何组件团队、以及开发顺序应有开发团队决定。\n    > 计划游戏开始，客户和开发同坐一屋子，每个人准备一支笔、一些用于记录用户需求的纸片，再准备一个白板就可以开始了。\n    > 1. 客户编写需求故事：由客户谈论系统应该完成什么功能，然后用自然语言词汇写在卡片上\n    > 2. 开发人员进行评估：有客户按优先级将故事需求标注为必须有、希望有、如果有三类，然后又开发人进行估算，优先级由高到低。如果估算的时候感到故事需求太大，不容易估算或者超过2人/周，那么应该进行分解在进行评估\n    > 3. 确定迭代周期：根据用户期望的需求优先级、期望发布的时间结合开发现有资源与用户协商，筛检出能够实现的需求，形成初步的需求计划。\n\n 2. 小型发布。XP方法秉承“持续集成，小步快走”的哲学思维，也就是说每次发布的版本尽可能肖，当然前提是每个版本都有发布的商业价值，值得发布。\n 3. 隐喻。相对而言，隐喻这个令人费解，什么时隐喻呢，字面意思是用来暗示字面意义不相似的事物之间相似的东西。对应到开发过程中就是，需要寻求共识，对系统理解、目标价值以等；还有就是发明共享词汇，通过规范项目中常用通用的业务专有名词，减少不必要的沟通；描述体系结构；并不是每一种情况都能找到合适的隐喻，没必要强求，而是顺其自然。\n 4. 简单设计。强调简单的价值观，引出简单性假设原则。这里说的简单设计并不是忽略设计而是设计不应该一次完成，因为随着业务的变化，可能当时设想的可预知的未来根本就是不存在的，留有适当的扩展设计并满足现有需求的简单设计原则。\n 5. 测试先行。是指注重测试用例程序的编写，不能因为没有时间，工作紧张为由忽略测试工作，这样就会由于没有良好的测试用例而化大把的时间在后续的联调维护阶段，实际上这个整体上市大大降低产能、效率埂底下的做法。\n 6. 重构。重构是一种对待吗进行重写而不影响功能实现的的技术，XP要求在开发人员“问到代码的坏味道”时，就有重构代码的勇气。重构的目的是让代码降低因变化引起的风险、使得代码更加易于维护和阅读。\n 7. 结对编程。一开始虽然会牺牲一些速度，但慢慢的，开发速度会逐步加快，究其原因是结对编程大大降低了沟通成本，提高了工作的质量，具体表现在：\n    1. 所有的设计决策确保不是一个人做出来的\n    2. 系统的任何部分至少有2个人以上熟悉\n    3. 不能能同时2个人都忽略测试项\n    4. 阶段的动态性，是一个去也知识管理的好途径\n    5. 代码总是能够保证评审通过\n    6. XP方法集成的吉他最佳实践能够是的结对编程更加容易进行\n    7. 编码标准能够消除一些无谓的分歧\n    8. 隐喻可以帮助结对伙伴更好沟通\n    9. 简单设计能够是的伙伴更了解他们所从事的工作\n    \n    结对编程技术被誉为XP保持工作质量、强调人文主义的一个典型实践，能够是的开发团队之间的协作更加流畅、知识交流更加频繁、团队更加稳定。\n\n\n 8. 集体代码所有制。有XP方法鼓励团队进行结对编程，而且编程组是动态搭配的，每个人会遇到不同的代码，代码所有制就不是局限于某一个人，而是集体所有制，团队中的每个人都有进行修改的权利，每个人都拥有全部代码，也都需要对全部代码负责。同时XP强调代码是谁该坏的就应该有谁来修复。\n 9. 持续集成。持续集成是最佳实践的基本支撑条件。\n 10. 每周工作40小时。这是一个让开发者开心、管理者反对的一个最佳实践。加班早已成为开发人员的家常便饭，也是管理者最常用的一种策略。而XP方法认为，加班会扼杀团队的积极性，最终导致项目失败，这也体现了XP方法是关注人的因素比关注过程的因素更多一些。这里说的40小时不是绝对的额，是指根据团队公司合理的工作时长。提倡追求有效的、高效的工作时间，而不是绝对的时长。\n 11. 现场客户。为了保证开发出来的结果与客户的预想接近，XP方法认为最重要的是将客户请到现场，保持和客户的现场沟通，并让客户参与到开发决策中来。\n 12. 编码标准。拥有编码标准可以避免团队无关细节的争论。不过这个标准不是越细越好，而是要能够确保代码清晰，便于交流的一个指导方针。\n\nXP方法最大价值在于项目中融会贯通地运用这12个最佳实践，而非单独使用。当然可以使用其中一些实践，单并不意味这就应用了XP方法。\n\n## 4.2 特征驱动开发方法\nFDD也是一个迭代的开发模型。FDD每一步都强调质量，不断地交付可运行的软件，并以很小的开发提供准确的项目进度报告和状态信息。同敏捷开发一样，FDD弱化了过程在软件开发的地位。\n### 4.2.1 FDD的角色定义\nFDD认为，有效的软件开发不可或缺的三个要素是：人、过程和技术。软件开发不能没有过程，也不能没有技术，但最重要的还是人。定义了6中关键角色：\n1. 项目经理。项目开发的组织者，是团队的保护屏障，提供一个适宜的开发环境。\n2. 首席架构设计师。负责系统的架构设计\n3. 开发经理。负责团队日常的开发工作的安排，解决开发过程中的技术问题和资源冲突\n4. 主程序员。主程序员将带领小组完成特征的详细设计和构件工作，一般要求主程序员具有一定的工作经验，并能够带动小组工作。\n5. 程序员。若干个程序员在主程序员带领下完成小组的开发，按照特征开发疾患完成开发\n6. 领域专家。领域专家是指对业务精通的人，一般有客户、系统分析师担当。\n\n### 4.2.2 FDD的最佳实践\nFDD最佳实践包括：领域对象建模、根据特征进行开发、类的个体所有、组成特征小组、审查、定期构造、配置管理、结果的可见性\n其中最有特色的是个体所有，激活所有的而开发模型都是代码共有。但在FDD中，将类分配给特定的任何小组，分配给A小组的代码只能由A来维护，除A外的角色都不能修改它，只能使用它。\n优点是：\n1. 这个类的支配感会促使开发人员产生自豪感，从而更出色地完成任务。不过FDD也提到了类q\n2. 审查也是FDD中很具特设的一项实践。不少人认为审查是非常严格的软件过程特有的，然而FDD中明确将审查作为一项最佳实践。审查是一种很有效的发现缺陷的手段，但经常被忽视，国内的软件组织中很少有严格的审查制度保障软件质量。在开发阶段的代码审查机制能够很好的避免潜在的问题。\n\n缺点：\n1. 项目依赖关系增强，形成代码黑盒，除了负责人没人能修改。\n\n\n## 4.3 Scrum\nScrum是一个用于开发和维护复杂产品框架，是一个增量的、迭代的开发过程。由若干个迭代周期组成，一个短的迭代周期成为Sprint,每个Sprint的建议周期在2到4周。在Scrum中，使用产品的Backlog来管理产品的需求，产品Backlog是一个按商业价值拍下的需求列表。\nScrum团队重产品的Backlog中挑选优先级最高的需求进行开发。\n挑选的需求在sprint的计划会议上进行讨论、分析和估算得到相应的任务列表，称之为Sprint backlog.\n\n### 4.3.1 Scrum的5个活动\n![](../images/软件开发方法/getImage-20220825183846916.png)\n1. 产品待办事项的梳理——Prodct Backlog. 产品待办事项通常会很多，也很宽泛，而且想法会变来变去、优先级也会变化，所以产品待办事项列表的梳理是一个贯穿整个Scrum项目的活动。梳理包括：整理需求、优先级排序、事项分解、归并以及商业价值分析等。待办事项的梳理最好是所有团队成员参与，因为有可能需要其他技术或者团队的参与，而不是单单产品经理。\n2. Sprint计划会议。每个Sprint工作周期以Sprint计划会议作为开始，让团队共同选择和理解即将到来的Sprint工作事项. Sprint计划会议的成功十分依赖产品待办事项列表的质量。Sprint计划会议工作内容有两部分：\n    1. 需要完成那些工作：产品负责人介绍排好序的代办事项，让整个Scrum团队共同理解这些工作。而产品待办事项的数目完全有开发团队决定，开发团队要考虑当天产品的增量状态，团队过去的工作情况，当前生产力等，产品负责人不能强加更多的工作量。\n    2. 如何完成工作：开发团队根据当前的“完成的定义”一起决定如何实现一个产品增量，进行任务分解，前几天的工作分解成小单元，每个单元不超过一天，之后的任务可以稍微大一些，以后再对它进行分解。总之产品和开发团队一起考虑斌讨论产品待办事项，确保每个人对事项的理解一致，最终产出待办事项列表就是“Sprint 待办事项列表”，称之为Sprint Backlog\n\n3. 每日Scrum会议。开发团队自组织，通过每日Scrum会议来确认他们任然可以实现Sprint的目标，每个人说下三点内容：上一个工作日完成了什么、当前工作日计划完成什么、有什么阻碍或风险。一般不超过15分钟。\n4. Sprint评审会议。一个Sprint周期结束时，Scrum团队和相关人员一起评审Sprint的产出，Sprint评审会议向每个人展示当前的产品增量情况，帮助大家了解我们目前的进度到哪里，讨论他们在Sprint过程中看到了什么、有什么想法，并一起探讨下一步如何更好的推进。\n5. Sprint回顾会议。每个Sprint周期结束之后，Scrum团队开回顾会议，目的是回顾一下团队在流程人际关系及工作方面做得如何，识别出团队中做得好的与不好的，并找潜在可以改进的事项，为将来的Sprint提供改进的计划\n\n### 4.3.2 Scrum的5大价值观\n1. 承若——愿意对目标负责\n2. 专注——把你的心思和能力都用到你承诺的工作上去\n3. 开放——Scrum把项目中的一切开放给每个人看，做到信息透明\n4. 尊重——每个人都有他独特的背景和经验，尊重每个人的特点\n5. 勇气——有勇气做出承诺，履行程度，接受别人的尊重\n   \n## 4.4 水晶方法\n水晶方法有七大体系特征：\n1. 经常交付。没过一段时间或者几个月向用户交付可测试运行的代码，让用户有机会发现原来需求是否是他真正想要的，有机会将结果反馈到开发中。\n2. 反思改进。开发过程中难免会遇到一些技术难题、各种烦心事，会影响项目进度，所以我们应该经常在迭代中及时地进行反思和改进，从慌乱的日常开发中，抽一点时间来思考更为行之有效的方法。\n3. 渗透式交流。渗透式交流就是信息交流在团队成员中形成背景听觉，使得成员就像通过渗透一样获取相关信息。团队通过在一个共同的工作空间内，若其中一个成员提出问题，其他成员可以选择关注或不关注，也可以随时加入到讨论中来，选择性地获取相关交流的信息。\n4. 个人安全。当你勇敢指出了困扰你的问题时，你可以不用担心受到报复，应该有保护机制，鼓励大家发现和改正自身的缺点，而不是知而不言，这样就会对团队造成损害，不利于整个团队的协作和稳定。\n5. 焦点。也叫聚焦，明确知道要做什么，然后再安排时间，确保团队成员都清楚地了解他们自己最重要的任务是什么，确保他们能够充分利用时间去完成这些任务。\n6. 与专家用户简历方便的联系。与专家用户简历方便的联系能够给团队提供很好的帮助，例如对业务的专业理解，成品的质量和快速罚款，设计理念和需求背景，用户最新的需求等。\n7. 自动化测试。自动化测试是在开发在修改代码之后能够进行自动化测试，以便发现一些bug，让开发能够及时地进行修复，节省了整体的开发时间，提高效率。\n\n## 4.5 其他敏捷方法——开放式源码\n开放式源码——是指以开放源码的方式运作，特别的就是开发人员可能地域分布很广，这和其他的敏捷方法不同，开放源码的一个好处就是排错的高度并行性，任何人都可以发现错误并修改代码提交给维护者。这里面体现的价值观就是猜测、合作和学习。\n\n# 5 软件重用\n\n软件产品和其他的产品不同，是抽象的，一旦产生就可以无限地复制，因此重复利用软件产品意义重大，可以节约大量的人力物力。软件重用包括：软件产品、源代码、文档、设计思想甚至领域知识。\n常见的重用形式：\n1. 源代码重用。这是简单最常见的重用形式，由于软件系统的复杂性，很难大规模地重用已有代码\n2. 架构重用。这个重用也很常见，随着软件架构风格和设计模式的推广和应用，架构重用已经对软件开发产生了重大影响\n3. 应用框架的重用。随着技术的发展，应用框架的重用变得越来越普遍，如AOP、EJB、Spring等应用框架技术\n4. 商业建模的重用。虽然软件领域各有不同，但是人们可以总结出常用的领域建模的方法，重用这些领域建模可以降低不确定性因素风险。\n5. 文档及过程的重用。有效地重用已有的文档有助于提高开发的效率\n6. 构件的重用。如第三方的组件，中间件等\n7. 软件服务的重用。随着web服务的提出，人们越来越关注服务的重用。例如SOA架构就是一个服务重用的实践，让一类功能收归到一个服务做不同业务软件的重用服务。\n\n# 6 基于架构的软件设计\n基于架构的软件设计（Architecture-Based Software Design,ABSD）是一种架构驱动的设计方法，这种方法有3个基础：\n1. 功能分解。在功能分解中，ABSD方法使用已有的基于模块内聚和耦合技术\n2. 通过选择架构风格来实现质量和业务需求\n3. 软件模板的使用。软件模板利用了一些软件系统的结构。\n\nABSB模型是吧整个过程划分为：架构需求、设计、文档化、复审、实现和演化\n\n## 6.1 ABSB方法与生命周期\n![](../images/软件开发方法/getImage-20220825183846654.png)\n\n## 6.2 基于架构的软件开发模型\n基于架构的软件开发模型（Architecture-Based Software Design Model，ABSDM）把整个基于架构的软件过程划分为架构需求、架构设计、架构文档化、架构复审、架构实现和架构演化6个子过程：\n![](../images/软件开发方法/getImage-20220825183846024.png)\n\n1. 机构需求。是指用户对目标软件在系统功能、行为、性能、设计约束方面的期望。通过用户的需求，架构师根据技术环境和架构师经验标注出所需要的构件，最后进行需求的评审。必要时“需求获取——标识构件——需求评审”之间进行迭代。\n2. 架构设计。根据架构需求提出架构的模型、映射构件、分析构件相互作用、产生架构、设计评审\n3. 架构文档化。绝大多数架构都是抽象的，有一些概念的构件组成。为了开发人员更好地理解和实现架构，必须把架构进行文档化描述\n3. 架构复审。架构设计完成之后要安排一次由外部人员（用户和领域专家）参与的复审，其目的是识别潜在的风险，及早发现架构设计中的缺陷和错误，包括架构能否满足需求、质量需求是否得到体现、是否清晰、构件是否划分合理、文档标识是否明确、以及构架设计是否满足功能和性能要求等等\n4. 架构实现。开发人员根据复审后的架构文档，分析和实现其中的构件，然后组装测试的一个过程。\n5. 架构演化。在架构开发中，用户的需求可能变动，在开发完成正常运行后，也可能发生需求变化。那么就要相应地调整架构以适应新的软件需求。主要过程包括这7个步骤：需求变动归类、架构演化计划、构件变动、更新构件的相互作用关系、构件组装和测试、技术评审、技术评审，最后得出演化后的架构设计。\n\n# 7 形式化方法\n形式化方法是指采用严格的数据方法对软件的描述、开发和验证的过程进行严格规约的一种方法，通过这种方式可以需求和定义人员与开发人员的理解偏差，避免模糊性和二义性。通过形式化描述进行需求分析的质量大大提高，很多自然语言描述无法避免的缺陷在需求分析阶段就会被发现并等到解决，从而降低了后期的开发和维护的成本。形式化描述可以通过计算计算进行自动处理（一些专业软件），进行一致性检查和证明。\n一般一些安全要求较高的，如地铁、高铁、航空、核电等软件会考虑使用这种开发方法来保证系统的安全和可靠性。","slug":"软考/软件开发方法","published":1,"date":"2022-08-25T10:38:31.861Z","updated":"2022-08-25T10:39:06.825Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczjm0034vwm1w1pt2k2j","content":"<blockquote>\n<p>前言：软件开发方法是软件开发的方法学，旨在提供软件的质量，降低开发成本</p>\n</blockquote>\n<h1 id=\"1-软件生命周期\"><a href=\"#1-软件生命周期\" class=\"headerlink\" title=\"1 软件生命周期\"></a>1 软件生命周期</h1><ol>\n<li>可行性研究和规划：通过可行性分析确认原件的必要性，价值点，初步确认软件的目标、范围、风险和开发成本等内容。</li>\n<li>需求分析：需求分析是开发过程的重要阶段，初步确认软件开发的目标和范围，之后则要对软件的需求进行细致分析，确认最终要做成什么样子。这个过程极其重要，如果这个阶段出现分析错误和偏差将导致后续开发过程偏离真实需求越远，修正的成本越大。</li>\n<li>概要设计：是程序员开发过程中的蓝图，包括确认系统架构、各个子系统依赖关系、数据库模型、编码规范、接口规约等内容</li>\n<li>详细设计：详细设计师开发之前的最后设计，是在概要设计的基础上进行进行细化，如类设计。详细设计不是必要过程，在规模较小，功能结构简单的系统中可以省略。</li>\n<li>实现：针对设计的单元模块进行开发，如一个过程、方法、函数，包括实现单元模块的单元测试</li>\n<li>集成测试：对单元模块进行组装联调测试</li>\n<li>确认测试：系统开发完后，需要验证是否和需求预期一致</li>\n<li>软件使用和维护：软件投入试运行，并不断对过程中出现的问题进行维护修正，软件维护郭晨会贯穿整个软件的使用郭晨直至软件自然消亡。</li>\n</ol>\n<h1 id=\"2-软件开发模型\"><a href=\"#2-软件开发模型\" class=\"headerlink\" title=\"2 软件开发模型\"></a>2 软件开发模型</h1><p>计算机刚刚诞生的年代，是一种只有天才才能掌握的巩固，人们对软件知识的认知仅仅停留在程序层面。随着技术发展，软件复杂度的提高，意识到必须遵循一定的开发方法才能取得成功，于是出现了模式化的开发方法称为开发模型。</p>\n<h2 id=\"2-1-瀑布模型\"><a href=\"#2-1-瀑布模型\" class=\"headerlink\" title=\"2.1 瀑布模型\"></a>2.1 瀑布模型</h2><p>特点：</p>\n<ol>\n<li>软件过程要经过需求分析、总体设计、详细设计、编码、调试、集成测试和系统测试阶段，开发阶段划分明确</li>\n<li>再每一个阶段结算后都有不定的文档或者程序流入下一个阶段</li>\n<li>每个阶段在发现问题时可以反馈给上一个阶段进行修正<br>适用场景：需求明确、稳定时</li>\n</ol>\n<h3 id=\"2-1-1-瀑布V模型\"><a href=\"#2-1-1-瀑布V模型\" class=\"headerlink\" title=\"2.1.1 瀑布V模型\"></a>2.1.1 瀑布V模型</h3><p>同标准瀑布模型一样，保持了瀑布模型的阶段式文档驱动的特点，但是更强调软件产品的验证工作，即需求分析的记过将作为系统测试的标准，能够在设计初期得到验证，以此类推，总体设计对应了集成测试，详细设计对应了单元测试。</p>\n<h3 id=\"2-1-2-瀑布模型的缺点\"><a href=\"#2-1-2-瀑布模型的缺点\" class=\"headerlink\" title=\"2.1.2 瀑布模型的缺点\"></a>2.1.2 瀑布模型的缺点</h3><ol>\n<li>需求分析是一切活动的基础，如果需求分析出现偏差，将导致后续活动放大这个偏差。但事实是，由于用户、开发者立场、经验不同、知识领域不同，对同一事物的表述不同造成的理解偏差难于避免，导致后期维护工作繁重</li>\n<li>难于适应需求变化，一旦需求变更要重头再来</li>\n<li>从需求提出到最后看到产品是一个相当长的过程，不能及时给用户反馈，并验证是否是能够满足客户需求的软件。</li>\n<li>瀑布模型是面向文档的开发模型，过程中将产生大量文档，大部分对客户没有意义，但却工作量繁重</li>\n</ol>\n<h2 id=\"2-2-演化模型\"><a href=\"#2-2-演化模型\" class=\"headerlink\" title=\"2.2 演化模型\"></a>2.2 演化模型</h2><p>演化模型是在瀑布模型难以一次性完全理解用户需求的基础上，对整个过程进行若干次的“瀑布模型”迭代，做到不断渐进、不断深入的过程</p>\n<h2 id=\"2-3-螺旋模型\"><a href=\"#2-3-螺旋模型\" class=\"headerlink\" title=\"2.3 螺旋模型\"></a>2.3 螺旋模型</h2><p>螺旋模型是在瀑布模型和演化模型结合的基础上，还强调其他模型忽略的风险分析。<br>特点：</p>\n<ol>\n<li>螺旋模型对每一期都包含需求定义、风险分析、工程实现、和评审4个阶段，对整个过程进行螺旋式迭代</li>\n<li>支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供方便，降低软件开发风险</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>螺旋模型的风险评估需要具有丰富风险评估经验和专业知识的人，否则将造成重大损失</li>\n<li>过多的迭代次数会增加开发成本，延迟提交时间</li>\n</ol>\n<h2 id=\"2-4-增量模型\"><a href=\"#2-4-增量模型\" class=\"headerlink\" title=\"2.4 增量模型\"></a>2.4 增量模型</h2><p>演化模型是另外一种增量模型的形式。在系统架构成熟、风险较低时，可采用增量方式进行系统开发，可提前进行基础测试和系统测试，缩短出事版本的发布周期，提高用户对系统的可见度。<br>特点：</p>\n<ol>\n<li>增量模型，做好系统的分析和设计，对系统划分为若干不同的版本，每一个版本都是完成可用的系统，后一个版本是前一个版本的基础进行开发，扩展前一个版本的功能，同时保证每个版本增量均匀。</li>\n<li>原型法，每一次发布都经历完成的生命周期，当用户需求很多不明确或者技术架构中很多不可知因素时，可采用原型增量法。在初始版本的原型并不考虑需求的合理性和系统稳定性，只为精准获取用户需求，一般会在后面的开发中抛弃这个原型进行完成的系统实现。</li>\n</ol>\n<h2 id=\"2-5-构件组装模型\"><a href=\"#2-5-构件组装模型\" class=\"headerlink\" title=\"2.5 构件组装模型\"></a>2.5 构件组装模型</h2><p>将系统划分为一组构件的集合，明确构件之间的关系。每个构件可以独立开发、自包容，可以是自己开发设计，也可以是第三方购买整合。最后进行构件组装的一个开发模型。<br>构件组装优点：</p>\n<ol>\n<li>构件自包容让系统扩展变得更加容易</li>\n<li>良好的构件更容易重用，降低开发成本</li>\n<li>构件力度较整个系统更小，更容易开发设计及安排工作更加灵活</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>对构件设计需要经验丰富的架构设计师，设计不良的构件难以实现他的优点</li>\n<li>考虑重用度是，往往会对其他方面设计做出让步，比如性能</li>\n<li>构件组装应用是，要求程序员熟悉掌握构件，增加了开发人员的学习成本</li>\n<li>第三方构件质量难以把控，将影响软件的质量。</li>\n</ol>\n<h1 id=\"3-统一过程模型\"><a href=\"#3-统一过程模型\" class=\"headerlink\" title=\"3 统一过程模型\"></a>3 统一过程模型</h1><p>统一过程（Unified Process, UP）是一种优秀的软件开发模型，可以有效地降低软件开发过程中的风险。这个开发模型的特点是每一个阶段的工作都不是绝对的，都是相互交叠配的的，但是每一个阶段都有侧重点。</p>\n<p><img src=\"../images/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/getImage-20220825183846811.png\" alt></p>\n<p>整个过程大致分为</p>\n<ol>\n<li>初始阶段，刚刚接入系统开发工作，侧重工作是明确系统目的，业务建模和需求工作</li>\n<li>细化阶段，抽象软件逻辑模型，设计架构，侧重是分析设计工作</li>\n<li>构件阶段，完成系统的构件，使之成为一个完整的实体，并进行测试和部署</li>\n<li>交付阶段，软件系统需求已经完成，重点工作是对软件进行重构、修改、测试和部署</li>\n</ol>\n<p>整个工作内容整体包括：业务建模、需求、分析设计、实施、测试、部署、配置与变更管理、项目管理、环境。</p>\n<p>其中“环境”是相对于其他工作难以理解的。环境工作很重要，也称之为环境管理。在软件开发过程中，需要为各种工作准备相应的工作环境，在工作环境中包含必须的工具、活动指南、活动流程规范、工作产品模板、基本的开发设施等。环境管理应该在工作流中得到应有的重视，每个开发团队都有自己的特点和活动准则规范，这种准则和规范是团队协作的基础，万万不能少，否则开发活动就会使放养式的管理。</p>\n<p>** UP的生命周期**<br>分为4个里程碑</p>\n<ol>\n<li>目标里程碑。明确系统的目标和范围时达到这个里程</li>\n<li>架构里程碑。当开发者确定稳定系统的架构时达到这个里程</li>\n<li>能力里程碑。当系统已经足够稳定和成熟并完成了Alpha测试之后达到这个里程碑</li>\n<li>发布里程碑。当完成系统的测试、完成系统的发布和用户培训工作之后达到这个里程碑</li>\n</ol>\n<p>UP的特点：</p>\n<ol>\n<li>UP是一个迭代的二维开发模型，每个生命后期都可以进行需求、设计、开发等</li>\n<li>采用不同的迭代方式的UP可以演变为演化模型或增量模型</li>\n<li>UP的迭代特点使得更容易控制开发风险</li>\n<li>Up是迭代开发模型，但不属于敏捷开发模型。一般未经过裁剪的Up是一个重载过程</li>\n<li>实际应用可根据具体问题进行UP的裁剪，从而使用各种规模的软件和开发团队</li>\n</ol>\n<p>架构师在UP活动中的作用<br>架构师除了需要建立系统的架构模型外，在UP活动中承担非常重要的角色，例如：</p>\n<ol>\n<li>同需求人员和项目管理人员密切协作</li>\n<li>细化软件架构</li>\n<li>保持整个架构的概念完整性，具体地说就是定义设计方法、设计指南、编码规范、平舌工作</li>\n</ol>\n<p><strong>因此有人称UP是一个已加购书为中心的开发模型。</strong></p>\n<h1 id=\"4-敏捷开发方法\"><a href=\"#4-敏捷开发方法\" class=\"headerlink\" title=\"4 敏捷开发方法\"></a>4 敏捷开发方法</h1><p>2001年，17位“无政府主义者”共同发表了《敏捷软件开发宣言》：</p>\n<blockquote>\n<ol>\n<li>尽早地、持续地向客户交付有价值的软件对开发人员来说是最重要的。</li>\n<li>拥抱变化，即使在开发的后期。敏捷过程能够驾驭变化，保持客户的竞争力。</li>\n<li>经常交付可工作的软件，从几周到几个月，时间范围越小越好。</li>\n<li>在整个项目中，业务人员和开发者紧密合作。</li>\n<li>围绕士气高昂的团队进行开发，为团队成员提供适宜的环境，满足他们的需要，并给予<br>足够的信任。</li>\n<li>在团队中，最有效率的、也是效果最好的沟通方式是面对面地交流。</li>\n<li>可以工作的软件是进度首要的度量方式。</li>\n<li>可持续地开发。投资人、开发团队和用户应该保持固定的节奏。</li>\n<li>不断追求优秀的技术和良好的设计有助于提高敏捷性。</li>\n<li>要简单，尽可能减少工作量。减少工作量的艺术是非常重要的。</li>\n<li>最好的架构、需求和设计都来自于一个自我组织的团队。</li>\n<li>团队要定期地总结如何能够更有效率，然后相应地自我调整</li>\n</ol>\n</blockquote>\n<p>这份宣言就是敏捷开发方法的灯塔</p>\n<h2 id=\"4-1-敏捷开发方法实践之极限编程（eXtreme-Programming）\"><a href=\"#4-1-敏捷开发方法实践之极限编程（eXtreme-Programming）\" class=\"headerlink\" title=\"4.1 敏捷开发方法实践之极限编程（eXtreme Programming）\"></a>4.1 敏捷开发方法实践之极限编程（eXtreme Programming）</h2><p>极限编程（XP）是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方法。特点如下：</p>\n<ol>\n<li>在更短的周期内，更早地提供具体、持续的反馈信息。</li>\n<li>迭代地进行计划编制。在最开始迅速形成总体计划，然后开发过程中不断迭代发展它</li>\n<li>依赖自动化测试程序来监控开发进度，尽早地铺货缺陷</li>\n<li>依赖口头交流、测试和源程序进行沟通</li>\n<li>倡导持续的、演化式的设计</li>\n<li>依赖于开发团队内部的紧密协作</li>\n<li>尽可能达到程序员的短期利益和长期利益的平衡。即关注短期程序员的自主设计和参与感，同时帮助程序员长期的成长</li>\n</ol>\n<p>四大价值观：沟通、简单、反馈、勇气</p>\n<ol>\n<li>沟通。通常，程序员相对内向，不善言谈，项目中的许多问题都发生在缺乏良好的沟通上。而传统的开发方法中并不太在意这种口头的沟通，而是希望通过完善的流程和面面俱到的文档、报表、计划来代替，这同时就引入了效率不高的问题，往往一个小问题通过漫长的流程下来被放大。而XP方法认为，如果小组内成员无法做到持续的、无间断的交流，协作就无从谈起，XP鼓励大家进行口头的面对面交流快速解决问题，提高效率。</li>\n<li>简单。XP方法的工作中秉承“够用即好”，实现尽可能简单化，不要过度设计。这一点看上去容易，但要做到其实很淡，因为在传统的开发过程中需要开发人员对未来做一些预先的规划，以便后续做扩展预留空间，这是一个平衡的过程，并不是一点都不考虑未来的可扩展性，所以比较难做到</li>\n<li>反馈。传统的开发过程中缺乏对客户必要的反馈，整个开发过程像一个“黑盒子”，过程漫长，完全看不到效果和进度。容易造成最终偏离用户需求的系统软件。XP注重反馈的作用，通过持续的、明确的反馈来暴露软件当前的状态和问题，尽早地纠正一些可以避免的错误。</li>\n<li>勇气。在XP方法中，要有勇气面对每时每刻的变化带来的挑战。由于提倡良好的沟通，会有更多的需求调整；由于提倡系统保持简单，需求变更导致的重构；由于提倡尽早反馈，更多地发现问题并纠正。而面对这些带来的挑战，我们更需要为之提高勇气。因为相比于沟通、简单和反馈带来的挑战，更多的我们是得到了良好的信息同步，尽早地发现了问题，更清晰地理解了用户需求，以及更简单地实现了系统软件。</li>\n</ol>\n<p>XP的四大价值观之下，隐藏着一种更深刻的东西，那就是尊重，对人的尊重。因为这一切都是建立在团队成员之间的相互关系、相互理解的基础之上。</p>\n<h3 id=\"4-1-1-极限编程的十二个最佳实践\"><a href=\"#4-1-1-极限编程的十二个最佳实践\" class=\"headerlink\" title=\"4.1.1 极限编程的十二个最佳实践\"></a>4.1.1 极限编程的十二个最佳实践</h3><ol>\n<li><p>计划游戏。主要思想是先快速制定一份概要计划，然后随着项目细节的不断清醒，在逐步完善这份计划。“客户负责业务决策，开发负责计算决策”，也就是说系统的范围、下一次迭代发布的时间、用户股市的优先级应有客户决定，而每个用户故事所需的而开发时间、技术成本、如何组件团队、以及开发顺序应有开发团队决定。</p>\n<blockquote>\n<p>计划游戏开始，客户和开发同坐一屋子，每个人准备一支笔、一些用于记录用户需求的纸片，再准备一个白板就可以开始了。</p>\n<ol>\n<li>客户编写需求故事：由客户谈论系统应该完成什么功能，然后用自然语言词汇写在卡片上</li>\n<li>开发人员进行评估：有客户按优先级将故事需求标注为必须有、希望有、如果有三类，然后又开发人进行估算，优先级由高到低。如果估算的时候感到故事需求太大，不容易估算或者超过2人/周，那么应该进行分解在进行评估</li>\n<li>确定迭代周期：根据用户期望的需求优先级、期望发布的时间结合开发现有资源与用户协商，筛检出能够实现的需求，形成初步的需求计划。</li>\n</ol>\n</blockquote>\n</li>\n<li><p>小型发布。XP方法秉承“持续集成，小步快走”的哲学思维，也就是说每次发布的版本尽可能肖，当然前提是每个版本都有发布的商业价值，值得发布。</p>\n</li>\n<li><p>隐喻。相对而言，隐喻这个令人费解，什么时隐喻呢，字面意思是用来暗示字面意义不相似的事物之间相似的东西。对应到开发过程中就是，需要寻求共识，对系统理解、目标价值以等；还有就是发明共享词汇，通过规范项目中常用通用的业务专有名词，减少不必要的沟通；描述体系结构；并不是每一种情况都能找到合适的隐喻，没必要强求，而是顺其自然。</p>\n</li>\n<li><p>简单设计。强调简单的价值观，引出简单性假设原则。这里说的简单设计并不是忽略设计而是设计不应该一次完成，因为随着业务的变化，可能当时设想的可预知的未来根本就是不存在的，留有适当的扩展设计并满足现有需求的简单设计原则。</p>\n</li>\n<li><p>测试先行。是指注重测试用例程序的编写，不能因为没有时间，工作紧张为由忽略测试工作，这样就会由于没有良好的测试用例而化大把的时间在后续的联调维护阶段，实际上这个整体上市大大降低产能、效率埂底下的做法。</p>\n</li>\n<li><p>重构。重构是一种对待吗进行重写而不影响功能实现的的技术，XP要求在开发人员“问到代码的坏味道”时，就有重构代码的勇气。重构的目的是让代码降低因变化引起的风险、使得代码更加易于维护和阅读。</p>\n</li>\n<li><p>结对编程。一开始虽然会牺牲一些速度，但慢慢的，开发速度会逐步加快，究其原因是结对编程大大降低了沟通成本，提高了工作的质量，具体表现在：</p>\n<ol>\n<li>所有的设计决策确保不是一个人做出来的</li>\n<li>系统的任何部分至少有2个人以上熟悉</li>\n<li>不能能同时2个人都忽略测试项</li>\n<li>阶段的动态性，是一个去也知识管理的好途径</li>\n<li>代码总是能够保证评审通过</li>\n<li>XP方法集成的吉他最佳实践能够是的结对编程更加容易进行</li>\n<li>编码标准能够消除一些无谓的分歧</li>\n<li>隐喻可以帮助结对伙伴更好沟通</li>\n<li>简单设计能够是的伙伴更了解他们所从事的工作</li>\n</ol>\n<p>结对编程技术被誉为XP保持工作质量、强调人文主义的一个典型实践，能够是的开发团队之间的协作更加流畅、知识交流更加频繁、团队更加稳定。</p>\n</li>\n</ol>\n<ol start=\"8\">\n<li>集体代码所有制。有XP方法鼓励团队进行结对编程，而且编程组是动态搭配的，每个人会遇到不同的代码，代码所有制就不是局限于某一个人，而是集体所有制，团队中的每个人都有进行修改的权利，每个人都拥有全部代码，也都需要对全部代码负责。同时XP强调代码是谁该坏的就应该有谁来修复。</li>\n<li>持续集成。持续集成是最佳实践的基本支撑条件。</li>\n<li>每周工作40小时。这是一个让开发者开心、管理者反对的一个最佳实践。加班早已成为开发人员的家常便饭，也是管理者最常用的一种策略。而XP方法认为，加班会扼杀团队的积极性，最终导致项目失败，这也体现了XP方法是关注人的因素比关注过程的因素更多一些。这里说的40小时不是绝对的额，是指根据团队公司合理的工作时长。提倡追求有效的、高效的工作时间，而不是绝对的时长。</li>\n<li>现场客户。为了保证开发出来的结果与客户的预想接近，XP方法认为最重要的是将客户请到现场，保持和客户的现场沟通，并让客户参与到开发决策中来。</li>\n<li>编码标准。拥有编码标准可以避免团队无关细节的争论。不过这个标准不是越细越好，而是要能够确保代码清晰，便于交流的一个指导方针。</li>\n</ol>\n<p>XP方法最大价值在于项目中融会贯通地运用这12个最佳实践，而非单独使用。当然可以使用其中一些实践，单并不意味这就应用了XP方法。</p>\n<h2 id=\"4-2-特征驱动开发方法\"><a href=\"#4-2-特征驱动开发方法\" class=\"headerlink\" title=\"4.2 特征驱动开发方法\"></a>4.2 特征驱动开发方法</h2><p>FDD也是一个迭代的开发模型。FDD每一步都强调质量，不断地交付可运行的软件，并以很小的开发提供准确的项目进度报告和状态信息。同敏捷开发一样，FDD弱化了过程在软件开发的地位。</p>\n<h3 id=\"4-2-1-FDD的角色定义\"><a href=\"#4-2-1-FDD的角色定义\" class=\"headerlink\" title=\"4.2.1 FDD的角色定义\"></a>4.2.1 FDD的角色定义</h3><p>FDD认为，有效的软件开发不可或缺的三个要素是：人、过程和技术。软件开发不能没有过程，也不能没有技术，但最重要的还是人。定义了6中关键角色：</p>\n<ol>\n<li>项目经理。项目开发的组织者，是团队的保护屏障，提供一个适宜的开发环境。</li>\n<li>首席架构设计师。负责系统的架构设计</li>\n<li>开发经理。负责团队日常的开发工作的安排，解决开发过程中的技术问题和资源冲突</li>\n<li>主程序员。主程序员将带领小组完成特征的详细设计和构件工作，一般要求主程序员具有一定的工作经验，并能够带动小组工作。</li>\n<li>程序员。若干个程序员在主程序员带领下完成小组的开发，按照特征开发疾患完成开发</li>\n<li>领域专家。领域专家是指对业务精通的人，一般有客户、系统分析师担当。</li>\n</ol>\n<h3 id=\"4-2-2-FDD的最佳实践\"><a href=\"#4-2-2-FDD的最佳实践\" class=\"headerlink\" title=\"4.2.2 FDD的最佳实践\"></a>4.2.2 FDD的最佳实践</h3><p>FDD最佳实践包括：领域对象建模、根据特征进行开发、类的个体所有、组成特征小组、审查、定期构造、配置管理、结果的可见性<br>其中最有特色的是个体所有，激活所有的而开发模型都是代码共有。但在FDD中，将类分配给特定的任何小组，分配给A小组的代码只能由A来维护，除A外的角色都不能修改它，只能使用它。<br>优点是：</p>\n<ol>\n<li>这个类的支配感会促使开发人员产生自豪感，从而更出色地完成任务。不过FDD也提到了类q</li>\n<li>审查也是FDD中很具特设的一项实践。不少人认为审查是非常严格的软件过程特有的，然而FDD中明确将审查作为一项最佳实践。审查是一种很有效的发现缺陷的手段，但经常被忽视，国内的软件组织中很少有严格的审查制度保障软件质量。在开发阶段的代码审查机制能够很好的避免潜在的问题。</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>项目依赖关系增强，形成代码黑盒，除了负责人没人能修改。</li>\n</ol>\n<h2 id=\"4-3-Scrum\"><a href=\"#4-3-Scrum\" class=\"headerlink\" title=\"4.3 Scrum\"></a>4.3 Scrum</h2><p>Scrum是一个用于开发和维护复杂产品框架，是一个增量的、迭代的开发过程。由若干个迭代周期组成，一个短的迭代周期成为Sprint,每个Sprint的建议周期在2到4周。在Scrum中，使用产品的Backlog来管理产品的需求，产品Backlog是一个按商业价值拍下的需求列表。<br>Scrum团队重产品的Backlog中挑选优先级最高的需求进行开发。<br>挑选的需求在sprint的计划会议上进行讨论、分析和估算得到相应的任务列表，称之为Sprint backlog.</p>\n<h3 id=\"4-3-1-Scrum的5个活动\"><a href=\"#4-3-1-Scrum的5个活动\" class=\"headerlink\" title=\"4.3.1 Scrum的5个活动\"></a>4.3.1 Scrum的5个活动</h3><p><img src=\"../images/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/getImage-20220825183846916.png\" alt></p>\n<ol>\n<li><p>产品待办事项的梳理——Prodct Backlog. 产品待办事项通常会很多，也很宽泛，而且想法会变来变去、优先级也会变化，所以产品待办事项列表的梳理是一个贯穿整个Scrum项目的活动。梳理包括：整理需求、优先级排序、事项分解、归并以及商业价值分析等。待办事项的梳理最好是所有团队成员参与，因为有可能需要其他技术或者团队的参与，而不是单单产品经理。</p>\n</li>\n<li><p>Sprint计划会议。每个Sprint工作周期以Sprint计划会议作为开始，让团队共同选择和理解即将到来的Sprint工作事项. Sprint计划会议的成功十分依赖产品待办事项列表的质量。Sprint计划会议工作内容有两部分：</p>\n<ol>\n<li>需要完成那些工作：产品负责人介绍排好序的代办事项，让整个Scrum团队共同理解这些工作。而产品待办事项的数目完全有开发团队决定，开发团队要考虑当天产品的增量状态，团队过去的工作情况，当前生产力等，产品负责人不能强加更多的工作量。</li>\n<li>如何完成工作：开发团队根据当前的“完成的定义”一起决定如何实现一个产品增量，进行任务分解，前几天的工作分解成小单元，每个单元不超过一天，之后的任务可以稍微大一些，以后再对它进行分解。总之产品和开发团队一起考虑斌讨论产品待办事项，确保每个人对事项的理解一致，最终产出待办事项列表就是“Sprint 待办事项列表”，称之为Sprint Backlog</li>\n</ol>\n</li>\n<li><p>每日Scrum会议。开发团队自组织，通过每日Scrum会议来确认他们任然可以实现Sprint的目标，每个人说下三点内容：上一个工作日完成了什么、当前工作日计划完成什么、有什么阻碍或风险。一般不超过15分钟。</p>\n</li>\n<li><p>Sprint评审会议。一个Sprint周期结束时，Scrum团队和相关人员一起评审Sprint的产出，Sprint评审会议向每个人展示当前的产品增量情况，帮助大家了解我们目前的进度到哪里，讨论他们在Sprint过程中看到了什么、有什么想法，并一起探讨下一步如何更好的推进。</p>\n</li>\n<li><p>Sprint回顾会议。每个Sprint周期结束之后，Scrum团队开回顾会议，目的是回顾一下团队在流程人际关系及工作方面做得如何，识别出团队中做得好的与不好的，并找潜在可以改进的事项，为将来的Sprint提供改进的计划</p>\n</li>\n</ol>\n<h3 id=\"4-3-2-Scrum的5大价值观\"><a href=\"#4-3-2-Scrum的5大价值观\" class=\"headerlink\" title=\"4.3.2 Scrum的5大价值观\"></a>4.3.2 Scrum的5大价值观</h3><ol>\n<li>承若——愿意对目标负责</li>\n<li>专注——把你的心思和能力都用到你承诺的工作上去</li>\n<li>开放——Scrum把项目中的一切开放给每个人看，做到信息透明</li>\n<li>尊重——每个人都有他独特的背景和经验，尊重每个人的特点</li>\n<li>勇气——有勇气做出承诺，履行程度，接受别人的尊重</li>\n</ol>\n<h2 id=\"4-4-水晶方法\"><a href=\"#4-4-水晶方法\" class=\"headerlink\" title=\"4.4 水晶方法\"></a>4.4 水晶方法</h2><p>水晶方法有七大体系特征：</p>\n<ol>\n<li>经常交付。没过一段时间或者几个月向用户交付可测试运行的代码，让用户有机会发现原来需求是否是他真正想要的，有机会将结果反馈到开发中。</li>\n<li>反思改进。开发过程中难免会遇到一些技术难题、各种烦心事，会影响项目进度，所以我们应该经常在迭代中及时地进行反思和改进，从慌乱的日常开发中，抽一点时间来思考更为行之有效的方法。</li>\n<li>渗透式交流。渗透式交流就是信息交流在团队成员中形成背景听觉，使得成员就像通过渗透一样获取相关信息。团队通过在一个共同的工作空间内，若其中一个成员提出问题，其他成员可以选择关注或不关注，也可以随时加入到讨论中来，选择性地获取相关交流的信息。</li>\n<li>个人安全。当你勇敢指出了困扰你的问题时，你可以不用担心受到报复，应该有保护机制，鼓励大家发现和改正自身的缺点，而不是知而不言，这样就会对团队造成损害，不利于整个团队的协作和稳定。</li>\n<li>焦点。也叫聚焦，明确知道要做什么，然后再安排时间，确保团队成员都清楚地了解他们自己最重要的任务是什么，确保他们能够充分利用时间去完成这些任务。</li>\n<li>与专家用户简历方便的联系。与专家用户简历方便的联系能够给团队提供很好的帮助，例如对业务的专业理解，成品的质量和快速罚款，设计理念和需求背景，用户最新的需求等。</li>\n<li>自动化测试。自动化测试是在开发在修改代码之后能够进行自动化测试，以便发现一些bug，让开发能够及时地进行修复，节省了整体的开发时间，提高效率。</li>\n</ol>\n<h2 id=\"4-5-其他敏捷方法——开放式源码\"><a href=\"#4-5-其他敏捷方法——开放式源码\" class=\"headerlink\" title=\"4.5 其他敏捷方法——开放式源码\"></a>4.5 其他敏捷方法——开放式源码</h2><p>开放式源码——是指以开放源码的方式运作，特别的就是开发人员可能地域分布很广，这和其他的敏捷方法不同，开放源码的一个好处就是排错的高度并行性，任何人都可以发现错误并修改代码提交给维护者。这里面体现的价值观就是猜测、合作和学习。</p>\n<h1 id=\"5-软件重用\"><a href=\"#5-软件重用\" class=\"headerlink\" title=\"5 软件重用\"></a>5 软件重用</h1><p>软件产品和其他的产品不同，是抽象的，一旦产生就可以无限地复制，因此重复利用软件产品意义重大，可以节约大量的人力物力。软件重用包括：软件产品、源代码、文档、设计思想甚至领域知识。<br>常见的重用形式：</p>\n<ol>\n<li>源代码重用。这是简单最常见的重用形式，由于软件系统的复杂性，很难大规模地重用已有代码</li>\n<li>架构重用。这个重用也很常见，随着软件架构风格和设计模式的推广和应用，架构重用已经对软件开发产生了重大影响</li>\n<li>应用框架的重用。随着技术的发展，应用框架的重用变得越来越普遍，如AOP、EJB、Spring等应用框架技术</li>\n<li>商业建模的重用。虽然软件领域各有不同，但是人们可以总结出常用的领域建模的方法，重用这些领域建模可以降低不确定性因素风险。</li>\n<li>文档及过程的重用。有效地重用已有的文档有助于提高开发的效率</li>\n<li>构件的重用。如第三方的组件，中间件等</li>\n<li>软件服务的重用。随着web服务的提出，人们越来越关注服务的重用。例如SOA架构就是一个服务重用的实践，让一类功能收归到一个服务做不同业务软件的重用服务。</li>\n</ol>\n<h1 id=\"6-基于架构的软件设计\"><a href=\"#6-基于架构的软件设计\" class=\"headerlink\" title=\"6 基于架构的软件设计\"></a>6 基于架构的软件设计</h1><p>基于架构的软件设计（Architecture-Based Software Design,ABSD）是一种架构驱动的设计方法，这种方法有3个基础：</p>\n<ol>\n<li>功能分解。在功能分解中，ABSD方法使用已有的基于模块内聚和耦合技术</li>\n<li>通过选择架构风格来实现质量和业务需求</li>\n<li>软件模板的使用。软件模板利用了一些软件系统的结构。</li>\n</ol>\n<p>ABSB模型是吧整个过程划分为：架构需求、设计、文档化、复审、实现和演化</p>\n<h2 id=\"6-1-ABSB方法与生命周期\"><a href=\"#6-1-ABSB方法与生命周期\" class=\"headerlink\" title=\"6.1 ABSB方法与生命周期\"></a>6.1 ABSB方法与生命周期</h2><p><img src=\"../images/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/getImage-20220825183846654.png\" alt></p>\n<h2 id=\"6-2-基于架构的软件开发模型\"><a href=\"#6-2-基于架构的软件开发模型\" class=\"headerlink\" title=\"6.2 基于架构的软件开发模型\"></a>6.2 基于架构的软件开发模型</h2><p>基于架构的软件开发模型（Architecture-Based Software Design Model，ABSDM）把整个基于架构的软件过程划分为架构需求、架构设计、架构文档化、架构复审、架构实现和架构演化6个子过程：<br><img src=\"../images/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/getImage-20220825183846024.png\" alt></p>\n<ol>\n<li>机构需求。是指用户对目标软件在系统功能、行为、性能、设计约束方面的期望。通过用户的需求，架构师根据技术环境和架构师经验标注出所需要的构件，最后进行需求的评审。必要时“需求获取——标识构件——需求评审”之间进行迭代。</li>\n<li>架构设计。根据架构需求提出架构的模型、映射构件、分析构件相互作用、产生架构、设计评审</li>\n<li>架构文档化。绝大多数架构都是抽象的，有一些概念的构件组成。为了开发人员更好地理解和实现架构，必须把架构进行文档化描述</li>\n<li>架构复审。架构设计完成之后要安排一次由外部人员（用户和领域专家）参与的复审，其目的是识别潜在的风险，及早发现架构设计中的缺陷和错误，包括架构能否满足需求、质量需求是否得到体现、是否清晰、构件是否划分合理、文档标识是否明确、以及构架设计是否满足功能和性能要求等等</li>\n<li>架构实现。开发人员根据复审后的架构文档，分析和实现其中的构件，然后组装测试的一个过程。</li>\n<li>架构演化。在架构开发中，用户的需求可能变动，在开发完成正常运行后，也可能发生需求变化。那么就要相应地调整架构以适应新的软件需求。主要过程包括这7个步骤：需求变动归类、架构演化计划、构件变动、更新构件的相互作用关系、构件组装和测试、技术评审、技术评审，最后得出演化后的架构设计。</li>\n</ol>\n<h1 id=\"7-形式化方法\"><a href=\"#7-形式化方法\" class=\"headerlink\" title=\"7 形式化方法\"></a>7 形式化方法</h1><p>形式化方法是指采用严格的数据方法对软件的描述、开发和验证的过程进行严格规约的一种方法，通过这种方式可以需求和定义人员与开发人员的理解偏差，避免模糊性和二义性。通过形式化描述进行需求分析的质量大大提高，很多自然语言描述无法避免的缺陷在需求分析阶段就会被发现并等到解决，从而降低了后期的开发和维护的成本。形式化描述可以通过计算计算进行自动处理（一些专业软件），进行一致性检查和证明。<br>一般一些安全要求较高的，如地铁、高铁、航空、核电等软件会考虑使用这种开发方法来保证系统的安全和可靠性。</p>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<blockquote>\n<p>前言：软件开发方法是软件开发的方法学，旨在提供软件的质量，降低开发成本</p>\n</blockquote>\n<h1 id=\"1-软件生命周期\"><a href=\"#1-软件生命周期\" class=\"headerlink\" title=\"1 软件生命周期\"></a>1 软件生命周期</h1><ol>\n<li>可行性研究和规划：通过可行性分析确认原件的必要性，价值点，初步确认软件的目标、范围、风险和开发成本等内容。</li>\n<li>需求分析：需求分析是开发过程的重要阶段，初步确认软件开发的目标和范围，之后则要对软件的需求进行细致分析，确认最终要做成什么样子。这个过程极其重要，如果这个阶段出现分析错误和偏差将导致后续开发过程偏离真实需求越远，修正的成本越大。</li>\n<li>概要设计：是程序员开发过程中的蓝图，包括确认系统架构、各个子系统依赖关系、数据库模型、编码规范、接口规约等内容</li>\n<li>详细设计：详细设计师开发之前的最后设计，是在概要设计的基础上进行进行细化，如类设计。详细设计不是必要过程，在规模较小，功能结构简单的系统中可以省略。</li>\n<li>实现：针对设计的单元模块进行开发，如一个过程、方法、函数，包括实现单元模块的单元测试</li>\n<li>集成测试：对单元模块进行组装联调测试</li>\n<li>确认测试：系统开发完后，需要验证是否和需求预期一致</li>\n<li>软件使用和维护：软件投入试运行，并不断对过程中出现的问题进行维护修正，软件维护郭晨会贯穿整个软件的使用郭晨直至软件自然消亡。</li>\n</ol>\n<h1 id=\"2-软件开发模型\"><a href=\"#2-软件开发模型\" class=\"headerlink\" title=\"2 软件开发模型\"></a>2 软件开发模型</h1><p>计算机刚刚诞生的年代，是一种只有天才才能掌握的巩固，人们对软件知识的认知仅仅停留在程序层面。随着技术发展，软件复杂度的提高，意识到必须遵循一定的开发方法才能取得成功，于是出现了模式化的开发方法称为开发模型。</p>\n<h2 id=\"2-1-瀑布模型\"><a href=\"#2-1-瀑布模型\" class=\"headerlink\" title=\"2.1 瀑布模型\"></a>2.1 瀑布模型</h2><p>特点：</p>\n<ol>\n<li>软件过程要经过需求分析、总体设计、详细设计、编码、调试、集成测试和系统测试阶段，开发阶段划分明确</li>\n<li>再每一个阶段结算后都有不定的文档或者程序流入下一个阶段</li>\n<li>每个阶段在发现问题时可以反馈给上一个阶段进行修正<br>适用场景：需求明确、稳定时</li>\n</ol>\n<h3 id=\"2-1-1-瀑布V模型\"><a href=\"#2-1-1-瀑布V模型\" class=\"headerlink\" title=\"2.1.1 瀑布V模型\"></a>2.1.1 瀑布V模型</h3><p>同标准瀑布模型一样，保持了瀑布模型的阶段式文档驱动的特点，但是更强调软件产品的验证工作，即需求分析的记过将作为系统测试的标准，能够在设计初期得到验证，以此类推，总体设计对应了集成测试，详细设计对应了单元测试。</p>\n<h3 id=\"2-1-2-瀑布模型的缺点\"><a href=\"#2-1-2-瀑布模型的缺点\" class=\"headerlink\" title=\"2.1.2 瀑布模型的缺点\"></a>2.1.2 瀑布模型的缺点</h3><ol>\n<li>需求分析是一切活动的基础，如果需求分析出现偏差，将导致后续活动放大这个偏差。但事实是，由于用户、开发者立场、经验不同、知识领域不同，对同一事物的表述不同造成的理解偏差难于避免，导致后期维护工作繁重</li>\n<li>难于适应需求变化，一旦需求变更要重头再来</li>\n<li>从需求提出到最后看到产品是一个相当长的过程，不能及时给用户反馈，并验证是否是能够满足客户需求的软件。</li>\n<li>瀑布模型是面向文档的开发模型，过程中将产生大量文档，大部分对客户没有意义，但却工作量繁重</li>\n</ol>\n<h2 id=\"2-2-演化模型\"><a href=\"#2-2-演化模型\" class=\"headerlink\" title=\"2.2 演化模型\"></a>2.2 演化模型</h2><p>演化模型是在瀑布模型难以一次性完全理解用户需求的基础上，对整个过程进行若干次的“瀑布模型”迭代，做到不断渐进、不断深入的过程</p>\n<h2 id=\"2-3-螺旋模型\"><a href=\"#2-3-螺旋模型\" class=\"headerlink\" title=\"2.3 螺旋模型\"></a>2.3 螺旋模型</h2><p>螺旋模型是在瀑布模型和演化模型结合的基础上，还强调其他模型忽略的风险分析。<br>特点：</p>\n<ol>\n<li>螺旋模型对每一期都包含需求定义、风险分析、工程实现、和评审4个阶段，对整个过程进行螺旋式迭代</li>\n<li>支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供方便，降低软件开发风险</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>螺旋模型的风险评估需要具有丰富风险评估经验和专业知识的人，否则将造成重大损失</li>\n<li>过多的迭代次数会增加开发成本，延迟提交时间</li>\n</ol>\n<h2 id=\"2-4-增量模型\"><a href=\"#2-4-增量模型\" class=\"headerlink\" title=\"2.4 增量模型\"></a>2.4 增量模型</h2><p>演化模型是另外一种增量模型的形式。在系统架构成熟、风险较低时，可采用增量方式进行系统开发，可提前进行基础测试和系统测试，缩短出事版本的发布周期，提高用户对系统的可见度。<br>特点：</p>\n<ol>\n<li>增量模型，做好系统的分析和设计，对系统划分为若干不同的版本，每一个版本都是完成可用的系统，后一个版本是前一个版本的基础进行开发，扩展前一个版本的功能，同时保证每个版本增量均匀。</li>\n<li>原型法，每一次发布都经历完成的生命周期，当用户需求很多不明确或者技术架构中很多不可知因素时，可采用原型增量法。在初始版本的原型并不考虑需求的合理性和系统稳定性，只为精准获取用户需求，一般会在后面的开发中抛弃这个原型进行完成的系统实现。</li>\n</ol>\n<h2 id=\"2-5-构件组装模型\"><a href=\"#2-5-构件组装模型\" class=\"headerlink\" title=\"2.5 构件组装模型\"></a>2.5 构件组装模型</h2><p>将系统划分为一组构件的集合，明确构件之间的关系。每个构件可以独立开发、自包容，可以是自己开发设计，也可以是第三方购买整合。最后进行构件组装的一个开发模型。<br>构件组装优点：</p>\n<ol>\n<li>构件自包容让系统扩展变得更加容易</li>\n<li>良好的构件更容易重用，降低开发成本</li>\n<li>构件力度较整个系统更小，更容易开发设计及安排工作更加灵活</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>对构件设计需要经验丰富的架构设计师，设计不良的构件难以实现他的优点</li>\n<li>考虑重用度是，往往会对其他方面设计做出让步，比如性能</li>\n<li>构件组装应用是，要求程序员熟悉掌握构件，增加了开发人员的学习成本</li>\n<li>第三方构件质量难以把控，将影响软件的质量。</li>\n</ol>\n<h1 id=\"3-统一过程模型\"><a href=\"#3-统一过程模型\" class=\"headerlink\" title=\"3 统一过程模型\"></a>3 统一过程模型</h1><p>统一过程（Unified Process, UP）是一种优秀的软件开发模型，可以有效地降低软件开发过程中的风险。这个开发模型的特点是每一个阶段的工作都不是绝对的，都是相互交叠配的的，但是每一个阶段都有侧重点。</p>\n<p><img src=\"../images/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/getImage-20220825183846811.png\" alt></p>\n<p>整个过程大致分为</p>\n<ol>\n<li>初始阶段，刚刚接入系统开发工作，侧重工作是明确系统目的，业务建模和需求工作</li>\n<li>细化阶段，抽象软件逻辑模型，设计架构，侧重是分析设计工作</li>\n<li>构件阶段，完成系统的构件，使之成为一个完整的实体，并进行测试和部署</li>\n<li>交付阶段，软件系统需求已经完成，重点工作是对软件进行重构、修改、测试和部署</li>\n</ol>\n<p>整个工作内容整体包括：业务建模、需求、分析设计、实施、测试、部署、配置与变更管理、项目管理、环境。</p>\n<p>其中“环境”是相对于其他工作难以理解的。环境工作很重要，也称之为环境管理。在软件开发过程中，需要为各种工作准备相应的工作环境，在工作环境中包含必须的工具、活动指南、活动流程规范、工作产品模板、基本的开发设施等。环境管理应该在工作流中得到应有的重视，每个开发团队都有自己的特点和活动准则规范，这种准则和规范是团队协作的基础，万万不能少，否则开发活动就会使放养式的管理。</p>\n<p>** UP的生命周期**<br>分为4个里程碑</p>\n<ol>\n<li>目标里程碑。明确系统的目标和范围时达到这个里程</li>\n<li>架构里程碑。当开发者确定稳定系统的架构时达到这个里程</li>\n<li>能力里程碑。当系统已经足够稳定和成熟并完成了Alpha测试之后达到这个里程碑</li>\n<li>发布里程碑。当完成系统的测试、完成系统的发布和用户培训工作之后达到这个里程碑</li>\n</ol>\n<p>UP的特点：</p>\n<ol>\n<li>UP是一个迭代的二维开发模型，每个生命后期都可以进行需求、设计、开发等</li>\n<li>采用不同的迭代方式的UP可以演变为演化模型或增量模型</li>\n<li>UP的迭代特点使得更容易控制开发风险</li>\n<li>Up是迭代开发模型，但不属于敏捷开发模型。一般未经过裁剪的Up是一个重载过程</li>\n<li>实际应用可根据具体问题进行UP的裁剪，从而使用各种规模的软件和开发团队</li>\n</ol>\n<p>架构师在UP活动中的作用<br>架构师除了需要建立系统的架构模型外，在UP活动中承担非常重要的角色，例如：</p>\n<ol>\n<li>同需求人员和项目管理人员密切协作</li>\n<li>细化软件架构</li>\n<li>保持整个架构的概念完整性，具体地说就是定义设计方法、设计指南、编码规范、平舌工作</li>\n</ol>\n<p><strong>因此有人称UP是一个已加购书为中心的开发模型。</strong></p>\n<h1 id=\"4-敏捷开发方法\"><a href=\"#4-敏捷开发方法\" class=\"headerlink\" title=\"4 敏捷开发方法\"></a>4 敏捷开发方法</h1><p>2001年，17位“无政府主义者”共同发表了《敏捷软件开发宣言》：</p>\n<blockquote>\n<ol>\n<li>尽早地、持续地向客户交付有价值的软件对开发人员来说是最重要的。</li>\n<li>拥抱变化，即使在开发的后期。敏捷过程能够驾驭变化，保持客户的竞争力。</li>\n<li>经常交付可工作的软件，从几周到几个月，时间范围越小越好。</li>\n<li>在整个项目中，业务人员和开发者紧密合作。</li>\n<li>围绕士气高昂的团队进行开发，为团队成员提供适宜的环境，满足他们的需要，并给予<br>足够的信任。</li>\n<li>在团队中，最有效率的、也是效果最好的沟通方式是面对面地交流。</li>\n<li>可以工作的软件是进度首要的度量方式。</li>\n<li>可持续地开发。投资人、开发团队和用户应该保持固定的节奏。</li>\n<li>不断追求优秀的技术和良好的设计有助于提高敏捷性。</li>\n<li>要简单，尽可能减少工作量。减少工作量的艺术是非常重要的。</li>\n<li>最好的架构、需求和设计都来自于一个自我组织的团队。</li>\n<li>团队要定期地总结如何能够更有效率，然后相应地自我调整</li>\n</ol>\n</blockquote>\n<p>这份宣言就是敏捷开发方法的灯塔</p>\n<h2 id=\"4-1-敏捷开发方法实践之极限编程（eXtreme-Programming）\"><a href=\"#4-1-敏捷开发方法实践之极限编程（eXtreme-Programming）\" class=\"headerlink\" title=\"4.1 敏捷开发方法实践之极限编程（eXtreme Programming）\"></a>4.1 敏捷开发方法实践之极限编程（eXtreme Programming）</h2><p>极限编程（XP）是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方法。特点如下：</p>\n<ol>\n<li>在更短的周期内，更早地提供具体、持续的反馈信息。</li>\n<li>迭代地进行计划编制。在最开始迅速形成总体计划，然后开发过程中不断迭代发展它</li>\n<li>依赖自动化测试程序来监控开发进度，尽早地铺货缺陷</li>\n<li>依赖口头交流、测试和源程序进行沟通</li>\n<li>倡导持续的、演化式的设计</li>\n<li>依赖于开发团队内部的紧密协作</li>\n<li>尽可能达到程序员的短期利益和长期利益的平衡。即关注短期程序员的自主设计和参与感，同时帮助程序员长期的成长</li>\n</ol>\n<p>四大价值观：沟通、简单、反馈、勇气</p>\n<ol>\n<li>沟通。通常，程序员相对内向，不善言谈，项目中的许多问题都发生在缺乏良好的沟通上。而传统的开发方法中并不太在意这种口头的沟通，而是希望通过完善的流程和面面俱到的文档、报表、计划来代替，这同时就引入了效率不高的问题，往往一个小问题通过漫长的流程下来被放大。而XP方法认为，如果小组内成员无法做到持续的、无间断的交流，协作就无从谈起，XP鼓励大家进行口头的面对面交流快速解决问题，提高效率。</li>\n<li>简单。XP方法的工作中秉承“够用即好”，实现尽可能简单化，不要过度设计。这一点看上去容易，但要做到其实很淡，因为在传统的开发过程中需要开发人员对未来做一些预先的规划，以便后续做扩展预留空间，这是一个平衡的过程，并不是一点都不考虑未来的可扩展性，所以比较难做到</li>\n<li>反馈。传统的开发过程中缺乏对客户必要的反馈，整个开发过程像一个“黑盒子”，过程漫长，完全看不到效果和进度。容易造成最终偏离用户需求的系统软件。XP注重反馈的作用，通过持续的、明确的反馈来暴露软件当前的状态和问题，尽早地纠正一些可以避免的错误。</li>\n<li>勇气。在XP方法中，要有勇气面对每时每刻的变化带来的挑战。由于提倡良好的沟通，会有更多的需求调整；由于提倡系统保持简单，需求变更导致的重构；由于提倡尽早反馈，更多地发现问题并纠正。而面对这些带来的挑战，我们更需要为之提高勇气。因为相比于沟通、简单和反馈带来的挑战，更多的我们是得到了良好的信息同步，尽早地发现了问题，更清晰地理解了用户需求，以及更简单地实现了系统软件。</li>\n</ol>\n<p>XP的四大价值观之下，隐藏着一种更深刻的东西，那就是尊重，对人的尊重。因为这一切都是建立在团队成员之间的相互关系、相互理解的基础之上。</p>\n<h3 id=\"4-1-1-极限编程的十二个最佳实践\"><a href=\"#4-1-1-极限编程的十二个最佳实践\" class=\"headerlink\" title=\"4.1.1 极限编程的十二个最佳实践\"></a>4.1.1 极限编程的十二个最佳实践</h3><ol>\n<li><p>计划游戏。主要思想是先快速制定一份概要计划，然后随着项目细节的不断清醒，在逐步完善这份计划。“客户负责业务决策，开发负责计算决策”，也就是说系统的范围、下一次迭代发布的时间、用户股市的优先级应有客户决定，而每个用户故事所需的而开发时间、技术成本、如何组件团队、以及开发顺序应有开发团队决定。</p>\n<blockquote>\n<p>计划游戏开始，客户和开发同坐一屋子，每个人准备一支笔、一些用于记录用户需求的纸片，再准备一个白板就可以开始了。</p>\n<ol>\n<li>客户编写需求故事：由客户谈论系统应该完成什么功能，然后用自然语言词汇写在卡片上</li>\n<li>开发人员进行评估：有客户按优先级将故事需求标注为必须有、希望有、如果有三类，然后又开发人进行估算，优先级由高到低。如果估算的时候感到故事需求太大，不容易估算或者超过2人/周，那么应该进行分解在进行评估</li>\n<li>确定迭代周期：根据用户期望的需求优先级、期望发布的时间结合开发现有资源与用户协商，筛检出能够实现的需求，形成初步的需求计划。</li>\n</ol>\n</blockquote>\n</li>\n<li><p>小型发布。XP方法秉承“持续集成，小步快走”的哲学思维，也就是说每次发布的版本尽可能肖，当然前提是每个版本都有发布的商业价值，值得发布。</p>\n</li>\n<li><p>隐喻。相对而言，隐喻这个令人费解，什么时隐喻呢，字面意思是用来暗示字面意义不相似的事物之间相似的东西。对应到开发过程中就是，需要寻求共识，对系统理解、目标价值以等；还有就是发明共享词汇，通过规范项目中常用通用的业务专有名词，减少不必要的沟通；描述体系结构；并不是每一种情况都能找到合适的隐喻，没必要强求，而是顺其自然。</p>\n</li>\n<li><p>简单设计。强调简单的价值观，引出简单性假设原则。这里说的简单设计并不是忽略设计而是设计不应该一次完成，因为随着业务的变化，可能当时设想的可预知的未来根本就是不存在的，留有适当的扩展设计并满足现有需求的简单设计原则。</p>\n</li>\n<li><p>测试先行。是指注重测试用例程序的编写，不能因为没有时间，工作紧张为由忽略测试工作，这样就会由于没有良好的测试用例而化大把的时间在后续的联调维护阶段，实际上这个整体上市大大降低产能、效率埂底下的做法。</p>\n</li>\n<li><p>重构。重构是一种对待吗进行重写而不影响功能实现的的技术，XP要求在开发人员“问到代码的坏味道”时，就有重构代码的勇气。重构的目的是让代码降低因变化引起的风险、使得代码更加易于维护和阅读。</p>\n</li>\n<li><p>结对编程。一开始虽然会牺牲一些速度，但慢慢的，开发速度会逐步加快，究其原因是结对编程大大降低了沟通成本，提高了工作的质量，具体表现在：</p>\n<ol>\n<li>所有的设计决策确保不是一个人做出来的</li>\n<li>系统的任何部分至少有2个人以上熟悉</li>\n<li>不能能同时2个人都忽略测试项</li>\n<li>阶段的动态性，是一个去也知识管理的好途径</li>\n<li>代码总是能够保证评审通过</li>\n<li>XP方法集成的吉他最佳实践能够是的结对编程更加容易进行</li>\n<li>编码标准能够消除一些无谓的分歧</li>\n<li>隐喻可以帮助结对伙伴更好沟通</li>\n<li>简单设计能够是的伙伴更了解他们所从事的工作</li>\n</ol>\n<p>结对编程技术被誉为XP保持工作质量、强调人文主义的一个典型实践，能够是的开发团队之间的协作更加流畅、知识交流更加频繁、团队更加稳定。</p>\n</li>\n</ol>\n<ol start=\"8\">\n<li>集体代码所有制。有XP方法鼓励团队进行结对编程，而且编程组是动态搭配的，每个人会遇到不同的代码，代码所有制就不是局限于某一个人，而是集体所有制，团队中的每个人都有进行修改的权利，每个人都拥有全部代码，也都需要对全部代码负责。同时XP强调代码是谁该坏的就应该有谁来修复。</li>\n<li>持续集成。持续集成是最佳实践的基本支撑条件。</li>\n<li>每周工作40小时。这是一个让开发者开心、管理者反对的一个最佳实践。加班早已成为开发人员的家常便饭，也是管理者最常用的一种策略。而XP方法认为，加班会扼杀团队的积极性，最终导致项目失败，这也体现了XP方法是关注人的因素比关注过程的因素更多一些。这里说的40小时不是绝对的额，是指根据团队公司合理的工作时长。提倡追求有效的、高效的工作时间，而不是绝对的时长。</li>\n<li>现场客户。为了保证开发出来的结果与客户的预想接近，XP方法认为最重要的是将客户请到现场，保持和客户的现场沟通，并让客户参与到开发决策中来。</li>\n<li>编码标准。拥有编码标准可以避免团队无关细节的争论。不过这个标准不是越细越好，而是要能够确保代码清晰，便于交流的一个指导方针。</li>\n</ol>\n<p>XP方法最大价值在于项目中融会贯通地运用这12个最佳实践，而非单独使用。当然可以使用其中一些实践，单并不意味这就应用了XP方法。</p>\n<h2 id=\"4-2-特征驱动开发方法\"><a href=\"#4-2-特征驱动开发方法\" class=\"headerlink\" title=\"4.2 特征驱动开发方法\"></a>4.2 特征驱动开发方法</h2><p>FDD也是一个迭代的开发模型。FDD每一步都强调质量，不断地交付可运行的软件，并以很小的开发提供准确的项目进度报告和状态信息。同敏捷开发一样，FDD弱化了过程在软件开发的地位。</p>\n<h3 id=\"4-2-1-FDD的角色定义\"><a href=\"#4-2-1-FDD的角色定义\" class=\"headerlink\" title=\"4.2.1 FDD的角色定义\"></a>4.2.1 FDD的角色定义</h3><p>FDD认为，有效的软件开发不可或缺的三个要素是：人、过程和技术。软件开发不能没有过程，也不能没有技术，但最重要的还是人。定义了6中关键角色：</p>\n<ol>\n<li>项目经理。项目开发的组织者，是团队的保护屏障，提供一个适宜的开发环境。</li>\n<li>首席架构设计师。负责系统的架构设计</li>\n<li>开发经理。负责团队日常的开发工作的安排，解决开发过程中的技术问题和资源冲突</li>\n<li>主程序员。主程序员将带领小组完成特征的详细设计和构件工作，一般要求主程序员具有一定的工作经验，并能够带动小组工作。</li>\n<li>程序员。若干个程序员在主程序员带领下完成小组的开发，按照特征开发疾患完成开发</li>\n<li>领域专家。领域专家是指对业务精通的人，一般有客户、系统分析师担当。</li>\n</ol>\n<h3 id=\"4-2-2-FDD的最佳实践\"><a href=\"#4-2-2-FDD的最佳实践\" class=\"headerlink\" title=\"4.2.2 FDD的最佳实践\"></a>4.2.2 FDD的最佳实践</h3><p>FDD最佳实践包括：领域对象建模、根据特征进行开发、类的个体所有、组成特征小组、审查、定期构造、配置管理、结果的可见性<br>其中最有特色的是个体所有，激活所有的而开发模型都是代码共有。但在FDD中，将类分配给特定的任何小组，分配给A小组的代码只能由A来维护，除A外的角色都不能修改它，只能使用它。<br>优点是：</p>\n<ol>\n<li>这个类的支配感会促使开发人员产生自豪感，从而更出色地完成任务。不过FDD也提到了类q</li>\n<li>审查也是FDD中很具特设的一项实践。不少人认为审查是非常严格的软件过程特有的，然而FDD中明确将审查作为一项最佳实践。审查是一种很有效的发现缺陷的手段，但经常被忽视，国内的软件组织中很少有严格的审查制度保障软件质量。在开发阶段的代码审查机制能够很好的避免潜在的问题。</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>项目依赖关系增强，形成代码黑盒，除了负责人没人能修改。</li>\n</ol>\n<h2 id=\"4-3-Scrum\"><a href=\"#4-3-Scrum\" class=\"headerlink\" title=\"4.3 Scrum\"></a>4.3 Scrum</h2><p>Scrum是一个用于开发和维护复杂产品框架，是一个增量的、迭代的开发过程。由若干个迭代周期组成，一个短的迭代周期成为Sprint,每个Sprint的建议周期在2到4周。在Scrum中，使用产品的Backlog来管理产品的需求，产品Backlog是一个按商业价值拍下的需求列表。<br>Scrum团队重产品的Backlog中挑选优先级最高的需求进行开发。<br>挑选的需求在sprint的计划会议上进行讨论、分析和估算得到相应的任务列表，称之为Sprint backlog.</p>\n<h3 id=\"4-3-1-Scrum的5个活动\"><a href=\"#4-3-1-Scrum的5个活动\" class=\"headerlink\" title=\"4.3.1 Scrum的5个活动\"></a>4.3.1 Scrum的5个活动</h3><p><img src=\"../images/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/getImage-20220825183846916.png\" alt></p>\n<ol>\n<li><p>产品待办事项的梳理——Prodct Backlog. 产品待办事项通常会很多，也很宽泛，而且想法会变来变去、优先级也会变化，所以产品待办事项列表的梳理是一个贯穿整个Scrum项目的活动。梳理包括：整理需求、优先级排序、事项分解、归并以及商业价值分析等。待办事项的梳理最好是所有团队成员参与，因为有可能需要其他技术或者团队的参与，而不是单单产品经理。</p>\n</li>\n<li><p>Sprint计划会议。每个Sprint工作周期以Sprint计划会议作为开始，让团队共同选择和理解即将到来的Sprint工作事项. Sprint计划会议的成功十分依赖产品待办事项列表的质量。Sprint计划会议工作内容有两部分：</p>\n<ol>\n<li>需要完成那些工作：产品负责人介绍排好序的代办事项，让整个Scrum团队共同理解这些工作。而产品待办事项的数目完全有开发团队决定，开发团队要考虑当天产品的增量状态，团队过去的工作情况，当前生产力等，产品负责人不能强加更多的工作量。</li>\n<li>如何完成工作：开发团队根据当前的“完成的定义”一起决定如何实现一个产品增量，进行任务分解，前几天的工作分解成小单元，每个单元不超过一天，之后的任务可以稍微大一些，以后再对它进行分解。总之产品和开发团队一起考虑斌讨论产品待办事项，确保每个人对事项的理解一致，最终产出待办事项列表就是“Sprint 待办事项列表”，称之为Sprint Backlog</li>\n</ol>\n</li>\n<li><p>每日Scrum会议。开发团队自组织，通过每日Scrum会议来确认他们任然可以实现Sprint的目标，每个人说下三点内容：上一个工作日完成了什么、当前工作日计划完成什么、有什么阻碍或风险。一般不超过15分钟。</p>\n</li>\n<li><p>Sprint评审会议。一个Sprint周期结束时，Scrum团队和相关人员一起评审Sprint的产出，Sprint评审会议向每个人展示当前的产品增量情况，帮助大家了解我们目前的进度到哪里，讨论他们在Sprint过程中看到了什么、有什么想法，并一起探讨下一步如何更好的推进。</p>\n</li>\n<li><p>Sprint回顾会议。每个Sprint周期结束之后，Scrum团队开回顾会议，目的是回顾一下团队在流程人际关系及工作方面做得如何，识别出团队中做得好的与不好的，并找潜在可以改进的事项，为将来的Sprint提供改进的计划</p>\n</li>\n</ol>\n<h3 id=\"4-3-2-Scrum的5大价值观\"><a href=\"#4-3-2-Scrum的5大价值观\" class=\"headerlink\" title=\"4.3.2 Scrum的5大价值观\"></a>4.3.2 Scrum的5大价值观</h3><ol>\n<li>承若——愿意对目标负责</li>\n<li>专注——把你的心思和能力都用到你承诺的工作上去</li>\n<li>开放——Scrum把项目中的一切开放给每个人看，做到信息透明</li>\n<li>尊重——每个人都有他独特的背景和经验，尊重每个人的特点</li>\n<li>勇气——有勇气做出承诺，履行程度，接受别人的尊重</li>\n</ol>\n<h2 id=\"4-4-水晶方法\"><a href=\"#4-4-水晶方法\" class=\"headerlink\" title=\"4.4 水晶方法\"></a>4.4 水晶方法</h2><p>水晶方法有七大体系特征：</p>\n<ol>\n<li>经常交付。没过一段时间或者几个月向用户交付可测试运行的代码，让用户有机会发现原来需求是否是他真正想要的，有机会将结果反馈到开发中。</li>\n<li>反思改进。开发过程中难免会遇到一些技术难题、各种烦心事，会影响项目进度，所以我们应该经常在迭代中及时地进行反思和改进，从慌乱的日常开发中，抽一点时间来思考更为行之有效的方法。</li>\n<li>渗透式交流。渗透式交流就是信息交流在团队成员中形成背景听觉，使得成员就像通过渗透一样获取相关信息。团队通过在一个共同的工作空间内，若其中一个成员提出问题，其他成员可以选择关注或不关注，也可以随时加入到讨论中来，选择性地获取相关交流的信息。</li>\n<li>个人安全。当你勇敢指出了困扰你的问题时，你可以不用担心受到报复，应该有保护机制，鼓励大家发现和改正自身的缺点，而不是知而不言，这样就会对团队造成损害，不利于整个团队的协作和稳定。</li>\n<li>焦点。也叫聚焦，明确知道要做什么，然后再安排时间，确保团队成员都清楚地了解他们自己最重要的任务是什么，确保他们能够充分利用时间去完成这些任务。</li>\n<li>与专家用户简历方便的联系。与专家用户简历方便的联系能够给团队提供很好的帮助，例如对业务的专业理解，成品的质量和快速罚款，设计理念和需求背景，用户最新的需求等。</li>\n<li>自动化测试。自动化测试是在开发在修改代码之后能够进行自动化测试，以便发现一些bug，让开发能够及时地进行修复，节省了整体的开发时间，提高效率。</li>\n</ol>\n<h2 id=\"4-5-其他敏捷方法——开放式源码\"><a href=\"#4-5-其他敏捷方法——开放式源码\" class=\"headerlink\" title=\"4.5 其他敏捷方法——开放式源码\"></a>4.5 其他敏捷方法——开放式源码</h2><p>开放式源码——是指以开放源码的方式运作，特别的就是开发人员可能地域分布很广，这和其他的敏捷方法不同，开放源码的一个好处就是排错的高度并行性，任何人都可以发现错误并修改代码提交给维护者。这里面体现的价值观就是猜测、合作和学习。</p>\n<h1 id=\"5-软件重用\"><a href=\"#5-软件重用\" class=\"headerlink\" title=\"5 软件重用\"></a>5 软件重用</h1><p>软件产品和其他的产品不同，是抽象的，一旦产生就可以无限地复制，因此重复利用软件产品意义重大，可以节约大量的人力物力。软件重用包括：软件产品、源代码、文档、设计思想甚至领域知识。<br>常见的重用形式：</p>\n<ol>\n<li>源代码重用。这是简单最常见的重用形式，由于软件系统的复杂性，很难大规模地重用已有代码</li>\n<li>架构重用。这个重用也很常见，随着软件架构风格和设计模式的推广和应用，架构重用已经对软件开发产生了重大影响</li>\n<li>应用框架的重用。随着技术的发展，应用框架的重用变得越来越普遍，如AOP、EJB、Spring等应用框架技术</li>\n<li>商业建模的重用。虽然软件领域各有不同，但是人们可以总结出常用的领域建模的方法，重用这些领域建模可以降低不确定性因素风险。</li>\n<li>文档及过程的重用。有效地重用已有的文档有助于提高开发的效率</li>\n<li>构件的重用。如第三方的组件，中间件等</li>\n<li>软件服务的重用。随着web服务的提出，人们越来越关注服务的重用。例如SOA架构就是一个服务重用的实践，让一类功能收归到一个服务做不同业务软件的重用服务。</li>\n</ol>\n<h1 id=\"6-基于架构的软件设计\"><a href=\"#6-基于架构的软件设计\" class=\"headerlink\" title=\"6 基于架构的软件设计\"></a>6 基于架构的软件设计</h1><p>基于架构的软件设计（Architecture-Based Software Design,ABSD）是一种架构驱动的设计方法，这种方法有3个基础：</p>\n<ol>\n<li>功能分解。在功能分解中，ABSD方法使用已有的基于模块内聚和耦合技术</li>\n<li>通过选择架构风格来实现质量和业务需求</li>\n<li>软件模板的使用。软件模板利用了一些软件系统的结构。</li>\n</ol>\n<p>ABSB模型是吧整个过程划分为：架构需求、设计、文档化、复审、实现和演化</p>\n<h2 id=\"6-1-ABSB方法与生命周期\"><a href=\"#6-1-ABSB方法与生命周期\" class=\"headerlink\" title=\"6.1 ABSB方法与生命周期\"></a>6.1 ABSB方法与生命周期</h2><p><img src=\"../images/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/getImage-20220825183846654.png\" alt></p>\n<h2 id=\"6-2-基于架构的软件开发模型\"><a href=\"#6-2-基于架构的软件开发模型\" class=\"headerlink\" title=\"6.2 基于架构的软件开发模型\"></a>6.2 基于架构的软件开发模型</h2><p>基于架构的软件开发模型（Architecture-Based Software Design Model，ABSDM）把整个基于架构的软件过程划分为架构需求、架构设计、架构文档化、架构复审、架构实现和架构演化6个子过程：<br><img src=\"../images/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/getImage-20220825183846024.png\" alt></p>\n<ol>\n<li>机构需求。是指用户对目标软件在系统功能、行为、性能、设计约束方面的期望。通过用户的需求，架构师根据技术环境和架构师经验标注出所需要的构件，最后进行需求的评审。必要时“需求获取——标识构件——需求评审”之间进行迭代。</li>\n<li>架构设计。根据架构需求提出架构的模型、映射构件、分析构件相互作用、产生架构、设计评审</li>\n<li>架构文档化。绝大多数架构都是抽象的，有一些概念的构件组成。为了开发人员更好地理解和实现架构，必须把架构进行文档化描述</li>\n<li>架构复审。架构设计完成之后要安排一次由外部人员（用户和领域专家）参与的复审，其目的是识别潜在的风险，及早发现架构设计中的缺陷和错误，包括架构能否满足需求、质量需求是否得到体现、是否清晰、构件是否划分合理、文档标识是否明确、以及构架设计是否满足功能和性能要求等等</li>\n<li>架构实现。开发人员根据复审后的架构文档，分析和实现其中的构件，然后组装测试的一个过程。</li>\n<li>架构演化。在架构开发中，用户的需求可能变动，在开发完成正常运行后，也可能发生需求变化。那么就要相应地调整架构以适应新的软件需求。主要过程包括这7个步骤：需求变动归类、架构演化计划、构件变动、更新构件的相互作用关系、构件组装和测试、技术评审、技术评审，最后得出演化后的架构设计。</li>\n</ol>\n<h1 id=\"7-形式化方法\"><a href=\"#7-形式化方法\" class=\"headerlink\" title=\"7 形式化方法\"></a>7 形式化方法</h1><p>形式化方法是指采用严格的数据方法对软件的描述、开发和验证的过程进行严格规约的一种方法，通过这种方式可以需求和定义人员与开发人员的理解偏差，避免模糊性和二义性。通过形式化描述进行需求分析的质量大大提高，很多自然语言描述无法避免的缺陷在需求分析阶段就会被发现并等到解决，从而降低了后期的开发和维护的成本。形式化描述可以通过计算计算进行自动处理（一些专业软件），进行一致性检查和证明。<br>一般一些安全要求较高的，如地铁、高铁、航空、核电等软件会考虑使用这种开发方法来保证系统的安全和可靠性。</p>\n"},{"_content":"Charles是一款抓包必备的工具，支持Windows、Mac、手机的抓包测试，还能对https的SLL加密内容进行解密。\n\n# 下载安装\n1. 进入官网下载地址：http://www.charlesproxy.com/，点击链接下载30天免费试用版本。\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183037795.png)\n2. 在线破解：\nhttps://www.zzzmode.com/mytools/charles/\n\n# 基本使用\n## 电脑抓包\n\n1. 打开Charles，默认是开启抓包代理的，可以看到电脑http请求的内容,你也可以将电脑的抓包代理给关掉，在Proxy>enable MacOs proxy 勾选去掉\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183037940.png)\n\n2. 设置https证书代理抓包，\n安装证书：\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183038586.png)\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183037648.png)\n打开百度https://www.baidu.com 测试，发现全是乱码：\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183038645.png)\n鼠标点击右键添加Enable SLL Proxy,从新刷新页面，Google Chrome 默认把这个当成不安全证书了，使用FireFox浏览器可以添加例外强制打开：\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183038204.png)\n可以看到Charles已经将https的内容通过Charles 证书加代理的方式能够看到明文请求信息了。\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183038795.png)\n\n# 手机抓包\n1. 设置网络代理\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183038117.png)\n通过上面菜单找到Charles的代理服务器IP和端口\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183038169.png)\n保证你的手机和你的电脑是在同一个局域网内，打开手机的WLAN配置，ip为上图的30.117.52.174，端口为：12345\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183038566.png)\n\n2. 如果想看到https的请求内容，还是得和电脑一样安装Charles证书，通过safari打开https://chls.pro/ssl 下载证书\n手机--setting-->General--->Profiles & Device Management --->Charles Proxy CA...\n将设置为信任。如图：\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183038687.png)\n\n3. 接着就可以查看到手机上的网络请求数据了，如果是https点击右键Enable SLL Proxy，在重新刷新下就可以看到了。","source":"_posts/软件笔记/抓包工具Charles安装、破解及使用.md","raw":"Charles是一款抓包必备的工具，支持Windows、Mac、手机的抓包测试，还能对https的SLL加密内容进行解密。\n\n# 下载安装\n1. 进入官网下载地址：http://www.charlesproxy.com/，点击链接下载30天免费试用版本。\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183037795.png)\n2. 在线破解：\nhttps://www.zzzmode.com/mytools/charles/\n\n# 基本使用\n## 电脑抓包\n\n1. 打开Charles，默认是开启抓包代理的，可以看到电脑http请求的内容,你也可以将电脑的抓包代理给关掉，在Proxy>enable MacOs proxy 勾选去掉\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183037940.png)\n\n2. 设置https证书代理抓包，\n安装证书：\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183038586.png)\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183037648.png)\n打开百度https://www.baidu.com 测试，发现全是乱码：\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183038645.png)\n鼠标点击右键添加Enable SLL Proxy,从新刷新页面，Google Chrome 默认把这个当成不安全证书了，使用FireFox浏览器可以添加例外强制打开：\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183038204.png)\n可以看到Charles已经将https的内容通过Charles 证书加代理的方式能够看到明文请求信息了。\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183038795.png)\n\n# 手机抓包\n1. 设置网络代理\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183038117.png)\n通过上面菜单找到Charles的代理服务器IP和端口\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183038169.png)\n保证你的手机和你的电脑是在同一个局域网内，打开手机的WLAN配置，ip为上图的30.117.52.174，端口为：12345\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183038566.png)\n\n2. 如果想看到https的请求内容，还是得和电脑一样安装Charles证书，通过safari打开https://chls.pro/ssl 下载证书\n手机--setting-->General--->Profiles & Device Management --->Charles Proxy CA...\n将设置为信任。如图：\n![](../images/抓包工具Charles安装、破解及使用/getImage-20220825183038687.png)\n\n3. 接着就可以查看到手机上的网络请求数据了，如果是https点击右键Enable SLL Proxy，在重新刷新下就可以看到了。","slug":"软件笔记/抓包工具Charles安装、破解及使用","published":1,"date":"2022-08-25T10:30:17.066Z","updated":"2022-08-25T10:30:42.335Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl78yczjn0036vwm1au8kf6e6","content":"<p>Charles是一款抓包必备的工具，支持Windows、Mac、手机的抓包测试，还能对https的SLL加密内容进行解密。</p>\n<h1 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h1><ol>\n<li>进入官网下载地址：<a href=\"http://www.charlesproxy.com/，点击链接下载30天免费试用版本。\" target=\"_blank\" rel=\"noopener\">http://www.charlesproxy.com/，点击链接下载30天免费试用版本。</a><br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183037795.png\" alt></li>\n<li>在线破解：<br><a href=\"https://www.zzzmode.com/mytools/charles/\" target=\"_blank\" rel=\"noopener\">https://www.zzzmode.com/mytools/charles/</a></li>\n</ol>\n<h1 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h1><h2 id=\"电脑抓包\"><a href=\"#电脑抓包\" class=\"headerlink\" title=\"电脑抓包\"></a>电脑抓包</h2><ol>\n<li><p>打开Charles，默认是开启抓包代理的，可以看到电脑http请求的内容,你也可以将电脑的抓包代理给关掉，在Proxy&gt;enable MacOs proxy 勾选去掉<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183037940.png\" alt></p>\n</li>\n<li><p>设置https证书代理抓包，<br>安装证书：<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183038586.png\" alt><br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183037648.png\" alt><br>打开百度<a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com</a> 测试，发现全是乱码：<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183038645.png\" alt><br>鼠标点击右键添加Enable SLL Proxy,从新刷新页面，Google Chrome 默认把这个当成不安全证书了，使用FireFox浏览器可以添加例外强制打开：<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183038204.png\" alt><br>可以看到Charles已经将https的内容通过Charles 证书加代理的方式能够看到明文请求信息了。<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183038795.png\" alt></p>\n</li>\n</ol>\n<h1 id=\"手机抓包\"><a href=\"#手机抓包\" class=\"headerlink\" title=\"手机抓包\"></a>手机抓包</h1><ol>\n<li><p>设置网络代理<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183038117.png\" alt><br>通过上面菜单找到Charles的代理服务器IP和端口<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183038169.png\" alt><br>保证你的手机和你的电脑是在同一个局域网内，打开手机的WLAN配置，ip为上图的30.117.52.174，端口为：12345<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183038566.png\" alt></p>\n</li>\n<li><p>如果想看到https的请求内容，还是得和电脑一样安装Charles证书，通过safari打开<a href=\"https://chls.pro/ssl\" target=\"_blank\" rel=\"noopener\">https://chls.pro/ssl</a> 下载证书<br>手机–setting–&gt;General—&gt;Profiles &amp; Device Management —&gt;Charles Proxy CA…<br>将设置为信任。如图：<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183038687.png\" alt></p>\n</li>\n<li><p>接着就可以查看到手机上的网络请求数据了，如果是https点击右键Enable SLL Proxy，在重新刷新下就可以看到了。</p>\n</li>\n</ol>\n","site":{"data":{"musics":[{"name":"以父之名","artist":"周杰伦","url":"/medias/music/周杰伦-以父之名.mp3","cover":"/medias/music/avatars/yifuzhiming.jpg"}],"friends":[{"name":"自然语言处理与深度学习","url":"https://zhuanlan.zhihu.com/okeeper","title":"访问主页","introduction":"我的知乎专栏，欢迎大家关注","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<p>Charles是一款抓包必备的工具，支持Windows、Mac、手机的抓包测试，还能对https的SLL加密内容进行解密。</p>\n<h1 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h1><ol>\n<li>进入官网下载地址：<a href=\"http://www.charlesproxy.com/，点击链接下载30天免费试用版本。\" target=\"_blank\" rel=\"noopener\">http://www.charlesproxy.com/，点击链接下载30天免费试用版本。</a><br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183037795.png\" alt></li>\n<li>在线破解：<br><a href=\"https://www.zzzmode.com/mytools/charles/\" target=\"_blank\" rel=\"noopener\">https://www.zzzmode.com/mytools/charles/</a></li>\n</ol>\n<h1 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h1><h2 id=\"电脑抓包\"><a href=\"#电脑抓包\" class=\"headerlink\" title=\"电脑抓包\"></a>电脑抓包</h2><ol>\n<li><p>打开Charles，默认是开启抓包代理的，可以看到电脑http请求的内容,你也可以将电脑的抓包代理给关掉，在Proxy&gt;enable MacOs proxy 勾选去掉<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183037940.png\" alt></p>\n</li>\n<li><p>设置https证书代理抓包，<br>安装证书：<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183038586.png\" alt><br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183037648.png\" alt><br>打开百度<a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com</a> 测试，发现全是乱码：<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183038645.png\" alt><br>鼠标点击右键添加Enable SLL Proxy,从新刷新页面，Google Chrome 默认把这个当成不安全证书了，使用FireFox浏览器可以添加例外强制打开：<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183038204.png\" alt><br>可以看到Charles已经将https的内容通过Charles 证书加代理的方式能够看到明文请求信息了。<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183038795.png\" alt></p>\n</li>\n</ol>\n<h1 id=\"手机抓包\"><a href=\"#手机抓包\" class=\"headerlink\" title=\"手机抓包\"></a>手机抓包</h1><ol>\n<li><p>设置网络代理<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183038117.png\" alt><br>通过上面菜单找到Charles的代理服务器IP和端口<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183038169.png\" alt><br>保证你的手机和你的电脑是在同一个局域网内，打开手机的WLAN配置，ip为上图的30.117.52.174，端口为：12345<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183038566.png\" alt></p>\n</li>\n<li><p>如果想看到https的请求内容，还是得和电脑一样安装Charles证书，通过safari打开<a href=\"https://chls.pro/ssl\" target=\"_blank\" rel=\"noopener\">https://chls.pro/ssl</a> 下载证书<br>手机–setting–&gt;General—&gt;Profiles &amp; Device Management —&gt;Charles Proxy CA…<br>将设置为信任。如图：<br><img src=\"../images/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E5%AE%89%E8%A3%85%E3%80%81%E7%A0%B4%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/getImage-20220825183038687.png\" alt></p>\n</li>\n<li><p>接着就可以查看到手机上的网络请求数据了，如果是https点击右键Enable SLL Proxy，在重新刷新下就可以看到了。</p>\n</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl78yczfu0001vwm1ebk1ipr7","category_id":"cl78yczg00005vwm1cwyncgxg","_id":"cl78yczg7000cvwm14rxyzonu"},{"post_id":"cl78yczfy0003vwm1wmijztjm","category_id":"cl78yczg00005vwm1cwyncgxg","_id":"cl78yczg8000evwm1rkppzodh"},{"post_id":"cl78yczg20007vwm1ldxxhdbe","category_id":"cl78yczg7000bvwm1u05r6p3a","_id":"cl78yczgb000ivwm1clvrbg5y"},{"post_id":"cl78yczg40008vwm1cai924gj","category_id":"cl78yczg8000fvwm1dig0go7m","_id":"cl78yczgc000nvwm1g0k39s5m"},{"post_id":"cl78yczio000zvwm1f7ct0g6i","category_id":"cl78ycziq0011vwm1ruugkk8k","_id":"cl78yczix001cvwm14egcomq3"},{"post_id":"cl78yczip0010vwm1u8e482qi","category_id":"cl78ycziq0011vwm1ruugkk8k","_id":"cl78ycziz001hvwm144ow3n5m"},{"post_id":"cl78yczis0014vwm1vwt1q90f","category_id":"cl78yczix001bvwm1q5v78wce","_id":"cl78yczj1001mvwm1wezbj3ol"},{"post_id":"cl78yczit0015vwm18822ynaz","category_id":"cl78ycziz001ivwm1hbgoqa4g","_id":"cl78yczj4001uvwm17ok3ozs8"},{"post_id":"cl78yczj0001lvwm1fpyx87p7","category_id":"cl78yczix001bvwm1q5v78wce","_id":"cl78yczj6001xvwm1npa84chv"},{"post_id":"cl78yczj2001pvwm150i466p3","category_id":"cl78yczix001bvwm1q5v78wce","_id":"cl78yczj70021vwm1l0uljx62"},{"post_id":"cl78ycziw001avwm1thahvbuv","category_id":"cl78ycziz001ivwm1hbgoqa4g","_id":"cl78yczj80024vwm1n9eolawz"},{"post_id":"cl78yczj3001rvwm1kft0xvhm","category_id":"cl78yczix001bvwm1q5v78wce","_id":"cl78yczj90027vwm1qym5orto"},{"post_id":"cl78yczix001fvwm1nu256f5j","category_id":"cl78ycziz001ivwm1hbgoqa4g","_id":"cl78yczja002avwm1n5ttgdrp"},{"post_id":"cl78ycziy001gvwm1qka5v5ji","category_id":"cl78ycziz001ivwm1hbgoqa4g","_id":"cl78yczjb002dvwm1n0vxe9s4"}],"PostTag":[{"post_id":"cl78yczfu0001vwm1ebk1ipr7","tag_id":"cl78yczg20006vwm1ej7wzrp2","_id":"cl78yczgb000hvwm1p8g2sgg5"},{"post_id":"cl78yczfu0001vwm1ebk1ipr7","tag_id":"cl78yczg5000avwm1gvu4ey9k","_id":"cl78yczgb000jvwm1ivepxgvp"},{"post_id":"cl78yczfu0001vwm1ebk1ipr7","tag_id":"cl78yczg7000dvwm1olrouejo","_id":"cl78yczgc000lvwm16oc2g632"},{"post_id":"cl78yczfy0003vwm1wmijztjm","tag_id":"cl78yczg9000gvwm1q51ubuod","_id":"cl78yczgc000mvwm10hsoz6zs"},{"post_id":"cl78yczg20007vwm1ldxxhdbe","tag_id":"cl78yczgb000kvwm1l0uatnkp","_id":"cl78yczge000rvwm1s5l0q0gy"},{"post_id":"cl78yczg20007vwm1ldxxhdbe","tag_id":"cl78yczgc000ovwm1we6ili9s","_id":"cl78yczge000svwm1mrohmuzb"},{"post_id":"cl78yczg20007vwm1ldxxhdbe","tag_id":"cl78yczgd000pvwm194971jul","_id":"cl78yczgf000tvwm1ba7s3t53"},{"post_id":"cl78yczg40008vwm1cai924gj","tag_id":"cl78yczge000qvwm1jvo8vuyy","_id":"cl78yczgf000uvwm1n6l9852e"},{"post_id":"cl78yczio000zvwm1f7ct0g6i","tag_id":"cl78ycziq0012vwm1236tws7w","_id":"cl78ycziv0018vwm1p9x88a21"},{"post_id":"cl78yczip0010vwm1u8e482qi","tag_id":"cl78ycziq0012vwm1236tws7w","_id":"cl78yczix001evwm1m4xvsu2h"},{"post_id":"cl78yczis0014vwm1vwt1q90f","tag_id":"cl78yczix001dvwm1c0v8jmzt","_id":"cl78yczj2001qvwm1kj2sntjh"},{"post_id":"cl78yczis0014vwm1vwt1q90f","tag_id":"cl78ycziz001jvwm1yu87ztba","_id":"cl78yczj3001svwm1who1ztjm"},{"post_id":"cl78yczit0015vwm18822ynaz","tag_id":"cl78yczj1001ovwm1crgvuxif","_id":"cl78yczj6001yvwm1n2xspoi5"},{"post_id":"cl78ycziw001avwm1thahvbuv","tag_id":"cl78yczj1001ovwm1crgvuxif","_id":"cl78yczj80025vwm1gexzjfq1"},{"post_id":"cl78yczix001fvwm1nu256f5j","tag_id":"cl78yczj1001ovwm1crgvuxif","_id":"cl78yczja002bvwm1xztg1lo8"},{"post_id":"cl78ycziy001gvwm1qka5v5ji","tag_id":"cl78yczj1001ovwm1crgvuxif","_id":"cl78yczjc002gvwm16y3llsrq"},{"post_id":"cl78yczj0001lvwm1fpyx87p7","tag_id":"cl78yczjb002evwm1fjvcjh7v","_id":"cl78yczje002kvwm1fm7y4ebq"},{"post_id":"cl78yczj0001lvwm1fpyx87p7","tag_id":"cl78ycziz001jvwm1yu87ztba","_id":"cl78yczjf002mvwm11mzhe7e8"},{"post_id":"cl78yczj2001pvwm150i466p3","tag_id":"cl78yczje002jvwm1dng0gj8x","_id":"cl78yczji002tvwm1l8545vs2"},{"post_id":"cl78yczj2001pvwm150i466p3","tag_id":"cl78yczjg002ovwm142i0edbi","_id":"cl78yczjj002vvwm1nl5999pb"},{"post_id":"cl78yczj2001pvwm150i466p3","tag_id":"cl78ycziz001jvwm1yu87ztba","_id":"cl78yczjk002yvwm1b5zrlfn0"},{"post_id":"cl78yczj3001rvwm1kft0xvhm","tag_id":"cl78yczjh002rvwm1n9lz8s7a","_id":"cl78yczjl0031vwm1p6umhrvm"},{"post_id":"cl78yczj3001rvwm1kft0xvhm","tag_id":"cl78yczjj002wvwm1lzwtr8b6","_id":"cl78yczjm0033vwm1n6hxkik7"},{"post_id":"cl78yczj3001rvwm1kft0xvhm","tag_id":"cl78ycziz001jvwm1yu87ztba","_id":"cl78yczjn0035vwm19f3055av"}],"Tag":[{"name":"Blog","_id":"cl78yczg20006vwm1ej7wzrp2"},{"name":"typora-vue-theme","_id":"cl78yczg5000avwm1gvu4ey9k"},{"name":"hexo","_id":"cl78yczg7000dvwm1olrouejo"},{"name":"分享","_id":"cl78yczg9000gvwm1q51ubuod"},{"name":"RocketMQ","_id":"cl78yczgb000kvwm1l0uatnkp"},{"name":"Kafka","_id":"cl78yczgc000ovwm1we6ili9s"},{"name":"MQ","_id":"cl78yczgd000pvwm194971jul"},{"name":"架构","_id":"cl78yczge000qvwm1jvo8vuyy"},{"name":"区块链","_id":"cl78ycziq0012vwm1236tws7w"},{"name":"Dubbo","_id":"cl78yczix001dvwm1c0v8jmzt"},{"name":"学习","_id":"cl78ycziz001jvwm1yu87ztba"},{"name":"操作系统原理","_id":"cl78yczj1001ovwm1crgvuxif"},{"name":"Disruptor","_id":"cl78yczjb002evwm1fjvcjh7v"},{"name":"HTTP","_id":"cl78yczje002jvwm1dng0gj8x"},{"name":"HTTPS","_id":"cl78yczjg002ovwm142i0edbi"},{"name":"Unicode","_id":"cl78yczjh002rvwm1n9lz8s7a"},{"name":"字符集","_id":"cl78yczjj002wvwm1lzwtr8b6"}]}}